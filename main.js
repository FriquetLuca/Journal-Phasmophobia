'use strict';

import { checkboxEmotes } from './assets/database/triboxDB.js';
import { ghostsDB, ghostList } from './assets/database/ghostDB.js';
import { evidenceDB, evidenceList } from './assets/database/evidenceDB.js';
import { behaviourDB, behaviourList } from './assets/database/behaviourDB.js';

const soundBehaviour = [
    {
        id: 'behaviour-air-breath',
        sound: 'sound-air-breath'
    },
    {
        id: 'behaviour-heavy-breath',
        sound: 'deogen-breath'
    },
    {
        id: 'behaviour-parabolic-scream',
        sound: 'banshee-scream'
    }
];

/***
* Return an array of ordered combination without repetition of n objets (a string array) classified in k groups.
*/
function combinationArrayNRNO(objects, k)
{
    let n = typeof objects === 'number' ? objects : objects.length; // Assign n as the length of all objets or the number passed through the function
    if(n < k) // n must be greater or equal to k...
    {
        throw new Error('The number of object must be greater or equal to k.');
    }
    let offset = n - k + 1; // The offset generated by the number of group
    let result = []; // Declare the result
    for(let i = 0; i < offset; i++) // Loop through all possible values on the first element
    {
       let content = [];
       content.push(objects[i]);
        let generated = combinationArrayDepthNRNO(objects, // Pass our objects
           i + 1, // Go to the next index to get the start of the next element
           offset + 1, // Subgroup gain a start offset of 1
           k - 1, // Align k for depth check since array start at 0
           0, // No depth, it's the 1st subgroup
           content // Give the object at the specific position in the array as a string or the position itself
        );
        Array.prototype.push.apply(result, generated); // Combine result
    }
    return result; // Return the result
}
/***
 * Generate an array of the entire set of element made out of binomial coefficient by taking the depth stack into account.
 */
function combinationArrayDepthNRNO(objects, index, offset, k, depth = 0, content = [])
{
    if(depth >= k) // If our depth is grater or equal to k, then we have all we need
    {
       return [content]; // We return the new string we made on the way.
    }
    let result = []; // Declare a result
    for(let i = index; i < offset; i++) // Loop through the possible values between index and offset - 1
    {
       let copyContent = [...content, objects[i]];
        let generated = combinationArrayDepthNRNO(objects,
           i + 1, // Go to the next index to get the start of the next element
           offset + 1, // Subgroup gain a start offset of 1
           k, // Just passing k along, it's already align if nothing goes wrong
           depth + 1, // Next depth of the stack
           copyContent // Give the object at the specific position in the array as a string or the position itself
        ); // Go into nested combinations
        Array.prototype.push.apply(result, generated); // Combine result
    }
    return result; // Return the result
}
function retrieveEvidences()
{
    let actualEvidences = [];
    let hiddenEvidences = [];
    for(let e of evidenceList)
    {
        let evidence = evidenceDB[e];
        let elemEvidence = document.getElementById(evidence.id);
        switch(elemEvidence.value.charAt(0))
        {
            case checkboxEmotes[1]: // True
            actualEvidences.push(evidence);
                break;
            case checkboxEmotes[2]: // False
            hiddenEvidences.push(evidence);
                break;
        }
    }
    return [actualEvidences, hiddenEvidences];
}
function computeSpecialAbilities()
{

}
function generateNormal()
{
    let e = retrieveEvidences();
    let foundEvidences = e[0];
    let notEvidences = e[1];
    for(let ghostName of ghostList)
    {
        let ghostData = ghostsDB[ghostName];
        let ghostElements = document.getElementsByClassName(ghostData.englishName);
        let visibility = true;
        for(let evidence of foundEvidences)
        {
            if(!ghostData.evidences.includes(evidence.englishName))
            {
                visibility = false;
                break;
            }
        }
        for(let evidence of notEvidences)
        {
            if(ghostData.evidences.includes(evidence.englishName))
            {
                visibility = false;
                break;
            }
        }
        collapseGhostVisibility(ghostElements, visibility);
    }
    computeSpecialAbilities();
}
function collapseGhostVisibility(ghostElements, visibility)
{
    for(let ghostElement of ghostElements)
    {
        ghostElement.style.visibility = visibility ? 'visible' : 'collapse';
        ghostElement.style.overflow = visibility ? 'visible' : 'hidden';
    }
}
function evidenceIncludes(foundEvidences, strongEvidence)
{
    for(let evidence of foundEvidences)
    {
        if(evidence.englishName === strongEvidence)
        {
            return true;
        }
    }
    return false;
}
function generateNightmare()
{
    let e = retrieveEvidences();
    let foundEvidences = e[0];
    let hiddenEvidences = e[1];
    for(let ghostName of ghostList)
    {
        let ghostData = ghostsDB[ghostName];
        let ghostElements = document.getElementsByClassName(ghostData.englishName);
        let visibility = true;
        for(let evidence of foundEvidences)
        {
            if(!ghostData.evidences.includes(evidence.englishName))
            {
                visibility = false;
                break;
            }
        }
        // There's more than one evidence for some reason..
        // Let's test the strong evidence.
        let strongEvid = ghostData.strongEvidence;
        if(visibility && (strongEvid !== undefined)) // This ghost have a strong evidence
        {
            if(foundEvidences.length >= 2 && !evidenceIncludes(foundEvidences, strongEvid))
            {
                visibility = false;
            }
        }
        if(visibility && hiddenEvidences.length > 1 && ghostName !== 'The Mimic')
        {
            let combineHidden = combinationArrayNRNO(hiddenEvidences, 2);
            for(let childCombine of combineHidden)
            {
                let nbr = 0;
                for(let child of childCombine)
                {
                    if(ghostData.evidences.includes(child.englishName))
                    {
                        nbr++;
                    }
                }
                if(nbr == 2)
                {
                    visibility = false;
                    break;
                }
            }
        }
        collapseGhostVisibility(ghostElements, visibility);
    }
    computeSpecialAbilities();
}

function generateEvidenceHTML()
{
    let result = '';
    for(let e of evidenceList)
    {
        let evidence = evidenceDB[e];
        let htmlContent = `
        <section class="evidence">
            <img class="evidence-icon" src="assets/icons/${evidence.icon}" alt="${evidence.englishName}">
            <label class="evidence-name" for="${evidence.id}">
                <input id='${evidence.id}' class='evidence-triState'
                type='text' name="${evidence.name}" style='border: none;' onfocus='this.blur()'
                readonly='true' size='1' value='&#x2753;'
                onclick='triState(this)' />
                ${evidence.name}
            </label>
        </section>`;
        result = `${result}${htmlContent}`;
    }
    return result;
}
function generateEvidenceIconHTML(ghostName)
{
    let result = '';
    let ghost = ghostsDB[ghostName];
    for(let e of ghost.evidences)
    {
        let evidence = evidenceDB[e];
        let htmlContent = `
        <img class="ghost-evidence-icon" src="assets/icons/${evidence.icon}" alt="${evidence.englishName}">
        `;
        result = `${result}${htmlContent}`;
    }
    return result;
}
function generateBehaviourHTML()
{
    let result = '';
    for(let b of behaviourList)
    {
        let behaviour = behaviourDB[b];
        let htmlContent = `
        <section class="behaviour">
            <label id="behaviour-${behaviour.id}" class="behaviour-name" for="${behaviour.id}">
                <input id='${behaviour.id}' class='behaviour-${behaviour.state}'
                type='text' name="${behaviour.name}" style='border: none;' onfocus='this.blur()'
                readonly='true' size='1' value='${behaviour.state === 'triState' ? '&#x2753;' : '&#x274c;'}'
                onclick='${behaviour.state}(this)' />
                ${behaviour.name}
            </label>
        </section>
        `;
        result = `${result}${htmlContent}`;
    }
    return result;
}
function generateSoundBehaviour()
{
    for(let sB of soundBehaviour)
    {
        let sound = document.getElementById(sB.sound);
        let e = document.getElementById(sB.id);
        e.addEventListener('mouseover', function() {
            sound.play();
        }, false);
        e.addEventListener('mouseleave', function() {
            sound.pause();
            sound.currentTime = 0;
        }, false);
    }
}
function generateGhostHTML()
{
    let result = '';
    for(let g of ghostList)
    {
        let ghost = ghostsDB[g];
        let htmlContent = `
        <tr class="ghost-table-line ${ghost.englishName} ghost-table-overline">
            <td class="ghost-name ghost-table-row">${ghost.name}<br>(<em>${ghost.englishName}</em>)</td>
            <td class="ghost-strenght ghost-table-row">${ghost.strenght}</td>
            <td class="ghost-weakness ghost-table-row">${ghost.weakness}</td>
        </tr>
        <tr class="ghost-table-line ${ghost.englishName} ghost-table-middleline">
            <td class="ghost-description ghost-table-row" colspan="4">
                <h4>Description</h4>
                <em>“ ${ghost.description} „</em>
                <h4 class="ghost-description-ability">Abilité</h4>
                <div class="ghost-description-ability-trigger">${ghost.ability}</div>
                <h4 class="ghost-description-behaviour">Comportement</h4>
                <div class="ghost-description-behaviour-trigger">${ghost.behaviour}</div>
                <h4 class="ghost-description-hunt">Chasse</h4>
                <div class="ghost-description-hunt-trigger">${ghost.hunt}</div>
            </td>
        </tr>
        <tr class="ghost-table-line ${ghost.englishName} ghost-table-underline">
            <td class="ghost-evidence ghost-table-row-underline" colspan="4">
                ${generateEvidenceIconHTML(ghost.englishName)}
            </td>
        </tr>
        `;
        result = `${result}${htmlContent}`;
    }
    return result;
}
function generateBoard()
{
    let htmlContent = `
    <section class="selectionables">
        <div class="evidences">
            <section class="evidence">
                <h1 class="evidence-title">Évidences</h1>
            </section>
            ${generateEvidenceHTML()}
        </div>
        <div class="behaviours">
            <section class="behaviour">
                <h1 class="behaviour-title">Comportement</h1>
            </section>
            ${generateBehaviourHTML()}
        </div>
        <div class="mod">
            <section class="mode">
                <h1 class="mode-title">Mode</h1>
            </section>
            <section class="mode">
                <label class="mode-name" for="nightmare">
                    <input id='nightmare' class='mode-dualState'
                    type='text' name="Cauchemar" style='border: none;' onfocus='this.blur()'
                    readonly='true' size='1' value='&#x274c;'
                    onclick='dualState(this)' />
                    Cauchemar
                </label>
            </section>
        </div>
    </section>
    <table id='ghost-result'>
        <thead>
            <tr class="ghost-result-line">
                <th class="ghost-result-title" colspan="4"><h1>Liste des entités potentiels :</h1></th>
            </tr>
            <tr class="ghost-table-line">
                <th class="ghost-name ghost-table-row-underline"><h2>Nom</h2></th>
                <th class="ghost-strenght ghost-table-row-underline"><h2>Force</h2></th>
                <th class="ghost-weakness ghost-table-row-underline"><h2>Faiblesse</h2></th>
            </tr>
        </thead>
        ${generateGhostHTML()}
    </table>
    `;
    let opt = document.getElementById('options');
    opt.innerHTML = htmlContent;
}

function updateDatas()
{
    let nightmare = document.getElementById('nightmare');
    if(nightmare.value === checkboxEmotes[1])
    {
        generateNightmare();
    }
    else
    {
        generateNormal();
    }
}

function doubleCheck(control, value1, value2)
{
    switch (control.value.charAt(0)) {
        case value1:
            control.value = value2;
            break;
        case value2:
            control.value = value1;
            break;
        default:
            throw new Error('Unexpected checkbox value');
    }
}
function tripleCheck(control, value1, value2, value3)
{
    switch (control.value.charAt(0))
    {
        case value1:
            control.value = value2;
            break;
        case value2:
            control.value = value3;
            break;
        case value3:
            control.value = value1;
            break;
        default:
            throw new Error('Unexpected checkbox value');
    }
}
function triState(control)
{
    tripleCheck(control, checkboxEmotes[0], checkboxEmotes[1], checkboxEmotes[2]);
    updateDatas();
}
function dualState(control)
{
    doubleCheck(control, checkboxEmotes[1], checkboxEmotes[2]);
    updateDatas();
}

generateBoard();
