/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@lazy-toolbox/client/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyView = exports.LazyTheme = exports.LazyTristate = exports.LazyTabularTextArea = exports.LazySlideContent = exports.LazySchedule = exports.LazyInteractivity = exports.LazyHtNetwork = exports.LazyHashRouter = exports.LazyFile = exports.LazyDualstate = exports.LazyDoc = exports.LazyClient = exports.LazyCaret = exports.LazyAnimate = void 0;\r\nvar lazyAnimate_1 = __webpack_require__(/*! ./lazyAnimate */ \"./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js\");\r\nObject.defineProperty(exports, \"LazyAnimate\", ({ enumerable: true, get: function () { return lazyAnimate_1.LazyAnimate; } }));\r\nvar lazyCaret_1 = __webpack_require__(/*! ./lazyCaret */ \"./node_modules/@lazy-toolbox/client/dist/lazyCaret.js\");\r\nObject.defineProperty(exports, \"LazyCaret\", ({ enumerable: true, get: function () { return lazyCaret_1.LazyCaret; } }));\r\nvar lazyClient_1 = __webpack_require__(/*! ./lazyClient */ \"./node_modules/@lazy-toolbox/client/dist/lazyClient.js\");\r\nObject.defineProperty(exports, \"LazyClient\", ({ enumerable: true, get: function () { return lazyClient_1.LazyClient; } }));\r\nvar lazyDoc_1 = __webpack_require__(/*! ./lazyDoc */ \"./node_modules/@lazy-toolbox/client/dist/lazyDoc.js\");\r\nObject.defineProperty(exports, \"LazyDoc\", ({ enumerable: true, get: function () { return lazyDoc_1.LazyDoc; } }));\r\nvar lazyDualstate_1 = __webpack_require__(/*! ./lazyDualstate */ \"./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js\");\r\nObject.defineProperty(exports, \"LazyDualstate\", ({ enumerable: true, get: function () { return lazyDualstate_1.LazyDualstate; } }));\r\nvar lazyFile_1 = __webpack_require__(/*! ./lazyFile */ \"./node_modules/@lazy-toolbox/client/dist/lazyFile.js\");\r\nObject.defineProperty(exports, \"LazyFile\", ({ enumerable: true, get: function () { return lazyFile_1.LazyFile; } }));\r\nvar lazyHashRouter_1 = __webpack_require__(/*! ./lazyHashRouter */ \"./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js\");\r\nObject.defineProperty(exports, \"LazyHashRouter\", ({ enumerable: true, get: function () { return lazyHashRouter_1.LazyHashRouter; } }));\r\nvar lazyHtNetwork_1 = __webpack_require__(/*! ./lazyHtNetwork */ \"./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js\");\r\nObject.defineProperty(exports, \"LazyHtNetwork\", ({ enumerable: true, get: function () { return lazyHtNetwork_1.LazyHtNetwork; } }));\r\nvar lazyInteractivity_1 = __webpack_require__(/*! ./lazyInteractivity */ \"./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js\");\r\nObject.defineProperty(exports, \"LazyInteractivity\", ({ enumerable: true, get: function () { return lazyInteractivity_1.LazyInteractivity; } }));\r\nvar lazySchedule_1 = __webpack_require__(/*! ./lazySchedule */ \"./node_modules/@lazy-toolbox/client/dist/lazySchedule.js\");\r\nObject.defineProperty(exports, \"LazySchedule\", ({ enumerable: true, get: function () { return lazySchedule_1.LazySchedule; } }));\r\nvar lazySlideContent_1 = __webpack_require__(/*! ./lazySlideContent */ \"./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js\");\r\nObject.defineProperty(exports, \"LazySlideContent\", ({ enumerable: true, get: function () { return lazySlideContent_1.LazySlideContent; } }));\r\nvar lazyTabularTextArea_1 = __webpack_require__(/*! ./lazyTabularTextArea */ \"./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js\");\r\nObject.defineProperty(exports, \"LazyTabularTextArea\", ({ enumerable: true, get: function () { return lazyTabularTextArea_1.LazyTabularTextArea; } }));\r\nvar lazyTristate_1 = __webpack_require__(/*! ./lazyTristate */ \"./node_modules/@lazy-toolbox/client/dist/lazyTristate.js\");\r\nObject.defineProperty(exports, \"LazyTristate\", ({ enumerable: true, get: function () { return lazyTristate_1.LazyTristate; } }));\r\nvar lazyTheme_1 = __webpack_require__(/*! ./lazyTheme */ \"./node_modules/@lazy-toolbox/client/dist/lazyTheme.js\");\r\nObject.defineProperty(exports, \"LazyTheme\", ({ enumerable: true, get: function () { return lazyTheme_1.LazyTheme; } }));\r\nvar lazyView_1 = __webpack_require__(/*! ./lazyView */ \"./node_modules/@lazy-toolbox/client/dist/lazyView.js\");\r\nObject.defineProperty(exports, \"LazyView\", ({ enumerable: true, get: function () { return lazyView_1.LazyView; } }));\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/index.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyAnimate = void 0;\r\nconst lazySlideContent_1 = __webpack_require__(/*! ./lazySlideContent */ \"./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js\");\r\n/**\r\n * A way to inject some animation into elements.\r\n */\r\nclass LazyAnimate {\r\n    /**\r\n     * Add a sliding content to all HTML details elements that passed through the function.\r\n     * @param {HTMLDetailsElement[]} detailsElements HTML details elements that need a sliding content.\r\n     */\r\n    static details(...detailsElements) {\r\n        detailsElements.forEach((element) => {\r\n            new lazySlideContent_1.LazySlideContent(element);\r\n        });\r\n    }\r\n    /**\r\n     * Inject into the HTML new element behaviour.\r\n     */\r\n    static loadDefault() {\r\n        document.querySelectorAll('details[animated]').forEach((el) => {\r\n            new lazySlideContent_1.LazySlideContent(el);\r\n        });\r\n    }\r\n}\r\nexports.LazyAnimate = LazyAnimate;\r\n/**\r\n * The `prefers-reduced-motion: reduce` media query to check for animations.\r\n */\r\nLazyAnimate.MediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyCaret.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyCaret.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyCaret = void 0;\r\n/**\r\n * A lazy way to handle caret and tabulation on textarea.\r\n */\r\nclass LazyCaret {\r\n    /**\r\n     * Set the caret position of the textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @param {number} position The position to set the caret to.\r\n     */\r\n    static setCaretPosition(txtArea, position) {\r\n        txtArea.selectionStart = position;\r\n        txtArea.selectionEnd = position;\r\n        txtArea.focus();\r\n    }\r\n    ;\r\n    /**\r\n     * Get the caret position of the textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @returns {number} Return the caret position of the textarea.\r\n     */\r\n    static getCaretPosition(txtArea) {\r\n        return txtArea.selectionStart;\r\n    }\r\n    ;\r\n    /**\r\n     * Check if the textarea has the selection.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @returns {boolean} Return true if the textare has the selection.\r\n     */\r\n    static hasSelection(txtArea) {\r\n        if (txtArea.selectionStart == txtArea.selectionEnd) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    ;\r\n    /**\r\n     * Get the selected text in a textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @returns {string} The selected text.\r\n     */\r\n    static getSelectedText(txtArea) {\r\n        return txtArea.value.substring(txtArea.selectionStart, txtArea.selectionEnd);\r\n    }\r\n    ;\r\n    /**\r\n     * Set a selection on the textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @param {number} start The start position of the selection.\r\n     * @param {number} end The end position of the selection.\r\n     */\r\n    static setSelection(txtArea, start, end) {\r\n        txtArea.selectionStart = start;\r\n        txtArea.selectionEnd = end;\r\n        txtArea.focus();\r\n    }\r\n    ;\r\n    /**\r\n     * Do a tabulation on a textarea where the caret is currently at.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @param {boolean} antiTab If true, it will do an anti-tabulation, removing space instead of adding it.\r\n     * @param {number} tabLength The length of the tabulation.\r\n     */\r\n    static tabulation(txtArea, antiTab = false, tabLength = 4) {\r\n        let newCaretPosition;\r\n        const caretPos = LazyCaret.getCaretPosition(txtArea);\r\n        const carretContent = txtArea.value.substring(0, caretPos);\r\n        let move = 0;\r\n        if (antiTab) {\r\n            for (let i = carretContent.length - 1; i >= carretContent.length - tabLength && i >= 0; i--) {\r\n                if (carretContent[i] !== ' ') {\r\n                    if (carretContent[i] !== '\\n') {\r\n                        move--;\r\n                    }\r\n                    break;\r\n                }\r\n                move++;\r\n            }\r\n            if (move < 0) {\r\n                move = 0;\r\n            }\r\n            txtArea.value = txtArea.value.substring(0, caretPos - move) + txtArea.value.substring(caretPos, txtArea.value.length);\r\n            newCaretPosition = caretPos - move;\r\n        }\r\n        else {\r\n            let letterTillLine = 0;\r\n            for (let i = carretContent.length - 1; i >= 0; i--) {\r\n                if (carretContent[i] === '\\n') {\r\n                    break;\r\n                }\r\n                letterTillLine++;\r\n            }\r\n            move = tabLength - (letterTillLine % tabLength);\r\n            const generateSpace = (n) => {\r\n                let r = '';\r\n                while (n > 0) {\r\n                    r = `${r} `;\r\n                    n--;\r\n                }\r\n                return r;\r\n            };\r\n            txtArea.value = txtArea.value.substring(0, caretPos) + generateSpace(move) + txtArea.value.substring(caretPos, txtArea.value.length);\r\n            newCaretPosition = caretPos + move;\r\n        }\r\n        LazyCaret.setCaretPosition(txtArea, newCaretPosition);\r\n    }\r\n}\r\nexports.LazyCaret = LazyCaret;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyCaret.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyClient.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyClient = void 0;\r\nconst lazySchedule_1 = __webpack_require__(/*! ./lazySchedule */ \"./node_modules/@lazy-toolbox/client/dist/lazySchedule.js\");\r\n/**\r\n * A lazy socket client to setup a websocket communication.\r\n * @method send Send a packet with datas to the server.\r\n * @method sender Register a sender function to execute when the connection to the server is established.\r\n * @method senders Register an array of sender functions to execute when the connection to the server is established.\r\n * @method hook Add an event to a specific packet.\r\n * @method hooks Add events to specifics packets.\r\n * @method hookObject Add events to specifics packets represented in an object.\r\n * @method start Start listening to the server.\r\n * @method disconnect Disconnect this client.\r\n */\r\nclass LazyClient {\r\n    /**\r\n     * Setup a simple websocket connection.\r\n     * @param {string} host The host to connect to.\r\n     * @param {number} port The port used by the server.\r\n     */\r\n    constructor(host, port) {\r\n        this.timer = new lazySchedule_1.LazySchedule(() => {\r\n            this.disconnect();\r\n            this.connect();\r\n        }, this.reconnectAfterMs, -1);\r\n        this.fns = [];\r\n        this.fnr = {};\r\n        this.socketURL = `ws://${host}:${port}`;\r\n        this.ws = new WebSocket(this.socketURL);\r\n    }\r\n    /**\r\n     * Send a packet with datas to the server.\r\n     * @param {string} packet The name of the packet to send.\r\n     * @param {any} obj The object to send.\r\n     */\r\n    send(packet, obj) {\r\n        obj['_packet'] = packet;\r\n        this.ws.send(JSON.stringify(obj));\r\n    }\r\n    /**\r\n     *  Register a sender function to execute when the connection to the server is established.\r\n     * @param {{ (f:(packet: string, obj: any) => any): void }} f A function taking as argument a sender function that has two parameters: the packet name and the object to send.\r\n     */\r\n    sender(f) {\r\n        this.fns.push(f);\r\n    }\r\n    /**\r\n     * Register an array of sender functions to execute when the connection to the server is established.\r\n     * @param {{ (f:(packet: string, obj: any) => any): void }[]} fns An array of function taking as argument a sender function that has two parameters: the packet name and the object to send.\r\n     */\r\n    senders(...fns) {\r\n        this.fns.push(...fns);\r\n    }\r\n    /**\r\n     * Add an event to a specific packet.\r\n     * @param {string} packet The packet's name.\r\n     * @param {(obj: any, websocket: WebSocket) => void} fn The function to execute when the packet is triggered.\r\n     */\r\n    hook(packet, fn) {\r\n        if (this.fnr[packet]) { // Check if the packet is defined.\r\n            this.fnr[packet].push(fn);\r\n        }\r\n        else {\r\n            this.fnr[packet] = [fn];\r\n        }\r\n    }\r\n    /**\r\n     * Add events to specifics packets.\r\n     * @param {{packet: string, fn: (obj: any, websocket: WebSocket) => void}[]} hooking An array of object containing the packet's name and a function to execute when the packet is triggered.\r\n     */\r\n    hooks(...hooking) {\r\n        for (const hook of hooking) {\r\n            this.hook(hook.packet, hook.fn);\r\n        }\r\n    }\r\n    /**\r\n     * Add events to specifics packets represented in an object.\r\n     * @param {{[packet:string]: (obj: any, websocket: WebSocket) => void}} fns An object containing all the packet's name with it's own associated function.\r\n     */\r\n    hookObject(fns) {\r\n        for (const fn in fns) {\r\n            this.hook(fn, fns[fn]);\r\n        }\r\n    }\r\n    /**\r\n     * Start listening to the server.\r\n     */\r\n    start() {\r\n        this.open();\r\n        this.receive();\r\n        this.onError();\r\n        this.close();\r\n    }\r\n    /**\r\n     * Disconnect this client.\r\n     */\r\n    disconnect() {\r\n        this.ws.onopen = function () { };\r\n        this.ws.onmessage = function () { };\r\n        this.ws.onclose = function () { };\r\n        this.ws.close();\r\n    }\r\n    reconnectAfterMs(tries) {\r\n        return [500, 1000, 2000, 5000][tries - 1] || 10000;\r\n    }\r\n    /**\r\n     * Parse and filter the datas receive and give back the packet and the parsed data.\r\n     * @param {string} data The data to parse and filter.\r\n     * @returns {{packet:string, datas:any}} An object containing both the packet and the datas.\r\n     */\r\n    static filterPacket(data) {\r\n        const jsonFile = JSON.parse(data);\r\n        const packet = jsonFile._packet;\r\n        delete jsonFile._packet;\r\n        return {\r\n            packet: packet,\r\n            datas: jsonFile\r\n        };\r\n    }\r\n    connect() {\r\n        this.ws = new WebSocket(this.socketURL);\r\n        this.start();\r\n    }\r\n    open() {\r\n        this.ws.onopen = () => {\r\n            for (const fn of this.fns) {\r\n                fn((packet, obj) => {\r\n                    this.send(packet, obj);\r\n                });\r\n            }\r\n        };\r\n    }\r\n    receive() {\r\n        this.ws.onmessage = (e) => __awaiter(this, void 0, void 0, function* () {\r\n            const msg = LazyClient.filterPacket(e.data.toString());\r\n            for (const fn of this.fnr[msg.packet]) {\r\n                fn(msg.datas, this.ws);\r\n            }\r\n        });\r\n    }\r\n    onError() {\r\n        this.ws.onerror = (e) => __awaiter(this, void 0, void 0, function* () {\r\n            console.error(e.message);\r\n        });\r\n    }\r\n    close() {\r\n        this.ws.onclose = (e) => __awaiter(this, void 0, void 0, function* () {\r\n            if (e.code === 1006) { // Connection's lost\r\n                this.timer.start();\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyClient = LazyClient;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyClient.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyDoc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyDoc.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyDoc = void 0;\r\n/**\r\n * A lazy way to write document.something.\r\n */\r\nclass LazyDoc {\r\n    static newTag(tagName, element) {\r\n        const eventSection = document.createElement(tagName);\r\n        if (element) {\r\n            if (element.id) {\r\n                eventSection.setAttribute('id', element.id);\r\n            }\r\n            if (element.class) {\r\n                element.class.forEach(c => eventSection.classList.add(c));\r\n            }\r\n            if (element.attributes) {\r\n                for (const att in element.attributes) {\r\n                    eventSection.setAttribute(att, element.attributes[att]);\r\n                }\r\n            }\r\n            if (element.innerHTML) {\r\n                eventSection.innerHTML = element.innerHTML;\r\n            }\r\n            if (element.innerText) {\r\n                eventSection.innerText = element.innerText;\r\n            }\r\n            if (element.childs) {\r\n                for (const child of element.childs) {\r\n                    eventSection.appendChild(child);\r\n                }\r\n            }\r\n            if (element.eventListeners) {\r\n                for (const evt in element.eventListeners) {\r\n                    eventSection.addEventListener(evt, element.eventListeners[evt]);\r\n                }\r\n            }\r\n        }\r\n        return eventSection;\r\n    }\r\n    static onEvent(query, type, listener, options) {\r\n        const currentElement = document.querySelector(query);\r\n        currentElement === null || currentElement === void 0 ? void 0 : currentElement.addEventListener(type, listener, options);\r\n    }\r\n    static onEventAll(query, type, listener, options) {\r\n        const allElements = document.querySelectorAll(query);\r\n        for (let currentElement of allElements) {\r\n            currentElement.addEventListener(type, listener, options);\r\n        }\r\n    }\r\n    static removeEvent(query, type, listener, options) {\r\n        const currentElement = document.querySelector(query);\r\n        currentElement === null || currentElement === void 0 ? void 0 : currentElement.removeEventListener(type, listener, options);\r\n    }\r\n    static removeEventAll(query, type, listener, options) {\r\n        const allElements = document.querySelectorAll(query);\r\n        for (const currentElement of allElements) {\r\n            currentElement.removeEventListener(type, listener, options);\r\n        }\r\n    }\r\n}\r\nexports.LazyDoc = LazyDoc;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyDoc.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyDualstate = void 0;\r\nconst lazyTristate_1 = __webpack_require__(/*! ./lazyTristate */ \"./node_modules/@lazy-toolbox/client/dist/lazyTristate.js\");\r\nconst DUAL_STATE = {\r\n    true: 'true',\r\n    false: 'false',\r\n    TRUE: 'true',\r\n    FALSE: 'false'\r\n};\r\n/**\r\n * A lazy way to use two states.\r\n */\r\nclass LazyDualstate {\r\n    constructor(item) {\r\n        var _a;\r\n        const itemValue = (_a = (item.value !== \"\" ? item.value : undefined)) !== null && _a !== void 0 ? _a : 'false';\r\n        item.readOnly = true;\r\n        item.size = 1;\r\n        if (!itemValue) {\r\n            item.value = lazyTristate_1.LazyTristate.FALSE;\r\n            item.innerText = lazyTristate_1.LazyTristate.FALSE;\r\n        }\r\n        else {\r\n            const stateSymbol = LazyDualstate.getState(itemValue);\r\n            item.value = stateSymbol;\r\n            item.innerText = stateSymbol;\r\n        }\r\n        item.addEventListener('click', (e) => {\r\n            const nextVal = LazyDualstate.nextState(e.target.value);\r\n            item.value = nextVal;\r\n            item.innerText = nextVal;\r\n            if (\"createEvent\" in document) {\r\n                var evt = document.createEvent(\"Event\");\r\n                evt.initEvent(\"change\", false, true);\r\n                item.dispatchEvent(evt);\r\n            }\r\n            else {\r\n                item.dispatchEvent(new Event('change'));\r\n            }\r\n        });\r\n    }\r\n    static stateToBool(actualDualstate) {\r\n        switch (actualDualstate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return true;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return false;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    static getState(actualDualstate) {\r\n        switch (actualDualstate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return lazyTristate_1.LazyTristate.TRUE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return lazyTristate_1.LazyTristate.FALSE;\r\n        }\r\n    }\r\n    static nextState(actualDualstate) {\r\n        switch (actualDualstate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return lazyTristate_1.LazyTristate.FALSE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return lazyTristate_1.LazyTristate.TRUE;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n}\r\nexports.LazyDualstate = LazyDualstate;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyFile.js":
/*!************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyFile.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyFile = void 0;\r\n/**\r\n * An easy way to manage file from a browser.\r\n */\r\nclass LazyFile {\r\n    /**\r\n     * Save a string content as a file.\r\n     * @param {string} fileName Name of the file.\r\n     * @param {string} content Content of the file.\r\n     */\r\n    static saveAs(fileName, content = \"\") {\r\n        const a = document.createElement(\"a\");\r\n        a.href = window.URL.createObjectURL(new Blob([content], { type: \"text/plain\" }));\r\n        a.download = fileName;\r\n        LazyFile.fakeClick(a);\r\n    }\r\n    static fakeClick(node) {\r\n        try {\r\n            node.dispatchEvent(new MouseEvent('click'));\r\n        }\r\n        catch (e) {\r\n            let evt = document.createEvent('MouseEvents');\r\n            evt === null || evt === void 0 ? void 0 : evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\r\n            node.dispatchEvent(evt);\r\n        }\r\n    }\r\n}\r\nexports.LazyFile = LazyFile;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyFile.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyHashRouter = void 0;\r\n/**\r\n * A lazy way to handle url parameters on a page.\r\n */\r\nclass LazyHashRouter {\r\n    /**\r\n     * Get the page route and an object represented in the url.\r\n     * @param {string | undefined} url The url to get the params from. If no url is provided, it's going to search the current url on the page.\r\n     * @returns {getter} A getter containing the page route and the resulting object represented in the url.\r\n     */\r\n    static getAllUrlParams(url) {\r\n        let queryString;\r\n        // get query string from url (optional) or window\r\n        if (url) {\r\n            const splitUrl = url.split('?');\r\n            splitUrl.shift();\r\n            queryString = splitUrl.join('?');\r\n        }\r\n        else {\r\n            queryString = window.location.search.slice(1);\r\n        }\r\n        let getPage = queryString.split('?');\r\n        queryString = getPage.length > 1 ? getPage[1] : getPage[0];\r\n        const getter = {\r\n            page: getPage.length > 1 ? getPage[0] : undefined,\r\n            result: undefined\r\n        };\r\n        // we'll store the parameters here\r\n        const obj = {};\r\n        // if query string exists\r\n        if (queryString) {\r\n            // stuff after # is not part of query string, so get rid of it\r\n            queryString = queryString.split('#')[0];\r\n            // split our query string into its component parts\r\n            const arr = queryString.split('&');\r\n            for (var i = 0; i < arr.length; i++) {\r\n                // separate the keys and the values\r\n                const a = arr[i].split('=');\r\n                // set parameter name and value (use 'false' if empty)\r\n                let paramName = a[0];\r\n                let paramValue = typeof (a[1]) === 'undefined' ? false : JSON.parse(decodeURIComponent(a[1]));\r\n                // (optional) keep case consistent\r\n                paramName = paramName.toLowerCase();\r\n                if (typeof paramValue === 'string') {\r\n                    paramValue = paramValue.toLowerCase();\r\n                }\r\n                // if the paramName ends with square brackets, e.g. colors[] or colors[2]\r\n                if (paramName.match(/\\[(\\d+)?\\]$/)) {\r\n                    // create key if it doesn't exist\r\n                    const key = paramName.replace(/\\[(\\d+)?\\]/, '');\r\n                    if (!obj[key]) {\r\n                        obj[key] = [];\r\n                    }\r\n                    // if it's an indexed array e.g. colors[2]\r\n                    if (paramName.match(/\\[\\d+\\]$/)) {\r\n                        // get the index value and add the entry at the appropriate position\r\n                        const index = /\\[(\\d+)\\]/.exec(paramName)[1];\r\n                        obj[key][index] = paramValue;\r\n                    }\r\n                    else {\r\n                        // otherwise add the value to the end of the array\r\n                        obj[key].push(paramValue);\r\n                    }\r\n                }\r\n                else {\r\n                    // we're dealing with a string\r\n                    if (!obj[paramName]) {\r\n                        // if it doesn't exist, create property\r\n                        obj[paramName] = paramValue;\r\n                    }\r\n                    else if (obj[paramName] && typeof obj[paramName] === 'string') {\r\n                        // if property does exist and it's a string, convert it to an array\r\n                        obj[paramName] = [obj[paramName]];\r\n                        obj[paramName].push(paramValue);\r\n                    }\r\n                    else {\r\n                        // otherwise add the property\r\n                        obj[paramName].push(paramValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        getter.result = obj;\r\n        return getter;\r\n    }\r\n    /**\r\n     * Create a string containing the parameters from a page route and an object.\r\n     * @param {string} page The route of the page.\r\n     * @param {{[name: string]: any}} object The object to make the parameters.\r\n     * @returns {string} The string containing the parameters from a page route and an object.\r\n     */\r\n    static setAllUrlParams(page, object) {\r\n        let result = `?${encodeURIComponent(page)}`;\r\n        let i = 0;\r\n        for (const objName in object) {\r\n            result += `${i++ == 0 ? '?' : '&'}${objName}=${encodeURIComponent(JSON.stringify(object[objName]))}`;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LazyHashRouter = LazyHashRouter;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyHtNetwork = void 0;\r\n/**\r\n * A lazy way to handle JS fetch API.\r\n * @function post Post data the same way an HTML form does.\r\n * @function postJSON Post a stringify JSON to an URL.\r\n * @function getJSON Get a stringify JSON from an URL.\r\n */\r\nclass LazyHtNetwork {\r\n    /**\r\n     * Post data the same way an HTML form does.\r\n     * @param {string} path The URL where we post datas.\r\n     * @param {{[name: string]: any}} datas The datas to post.\r\n     * @param {(json: Promise<any>) => void} execute A function to execute for any callback from the server.\r\n     * @param {(e: any) => void} error A function to handle any potential error.\r\n     */\r\n    static post(path, datas, execute = (e) => { }, error = (e) => console.error(e)) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const form = new FormData();\r\n                for (let data in datas) {\r\n                    form.append(data, datas[data]);\r\n                }\r\n                const fetchResult = yield fetch(path, {\r\n                    method: 'POST',\r\n                    body: form\r\n                });\r\n                const jsonData = yield fetchResult.json();\r\n                execute(jsonData);\r\n            }\r\n            catch (e) {\r\n                error(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Post a stringify JSON to an URL.\r\n     * @param {string} path The URL where we post datas.\r\n     * @param {{[name: string]: any}} datas The datas to post.\r\n     * @param {(json: Promise<any>) => void} execute A function to execute for any callback from the server.\r\n     * @param {(e: any) => void} error A function to handle any potential error.\r\n     */\r\n    static postJSON(path, datas, execute = (e) => { }, error = (e) => console.error(e)) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const fetchResult = yield fetch(path, {\r\n                    method: 'POST',\r\n                    body: JSON.stringify(datas),\r\n                    headers: {\r\n                        \"Accept\": \"application/json\",\r\n                        \"Content-type\": \"application/json\"\r\n                    }\r\n                });\r\n                const jsonData = yield fetchResult.json();\r\n                execute(jsonData);\r\n            }\r\n            catch (e) {\r\n                error(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Get a stringify JSON from an URL.\r\n     * @param {string} path The URL where the JSON file is located.\r\n     * @param {(json: Promise<any>) => void} execute A function to execute for the fetched JSON.\r\n     * @param {(e: any) => void} error A function to handle any potential error.\r\n     */\r\n    static getJSON(path, execute = (e) => { }, error = (e) => console.error(e)) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const fetchResult = yield fetch(path);\r\n                const jsonData = yield fetchResult.json();\r\n                execute(jsonData);\r\n            }\r\n            catch (e) {\r\n                error(e);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyHtNetwork = LazyHtNetwork;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyInteractivity = void 0;\r\nconst lazyDualstate_1 = __webpack_require__(/*! ./lazyDualstate */ \"./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js\");\r\nconst lazyTristate_1 = __webpack_require__(/*! ./lazyTristate */ \"./node_modules/@lazy-toolbox/client/dist/lazyTristate.js\");\r\n/**\r\n * A lazy way to make interactive elements.\r\n */\r\nclass LazyInteractivity {\r\n    /**\r\n     * Inject into the HTML new element behaviour.\r\n     */\r\n    static loadDefault() {\r\n        document.querySelectorAll('input[tristate]').forEach((el) => {\r\n            new lazyTristate_1.LazyTristate(el);\r\n        });\r\n        document.querySelectorAll('input[dualstate]').forEach((el) => {\r\n            new lazyDualstate_1.LazyDualstate(el);\r\n        });\r\n    }\r\n    /**\r\n     * Add support for an input with two states acting like boolean.\r\n     * @param {HTMLInputElement[]} inputsElements HTML input elements that need a dualstate.\r\n     */\r\n    static dualstate(...inputsElements) {\r\n        inputsElements.forEach((element) => {\r\n            if (element.getAttribute('dualstate') !== null) {\r\n                new lazyDualstate_1.LazyDualstate(element);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Add support for an input with three states acting like some kind of boolean.\r\n     * @param {HTMLInputElement[]} inputsElements HTML input elements that need a tristate.\r\n     */\r\n    static tristate(...inputsElements) {\r\n        inputsElements.forEach((element) => {\r\n            if (element.getAttribute('tristate') !== null) {\r\n                new lazyTristate_1.LazyTristate(element);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyInteractivity = LazyInteractivity;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazySchedule.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazySchedule.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazySchedule = void 0;\r\n/**\r\n * A lazy way to create a smart setInterval that handle a number of tries and can be paused.\r\n * @method start Start the schedule.\r\n * @method stop Stop the schedule. If the schedule had to be triggered in 30ms, when you'll start the schedule again, the schedule would be executed after those remaining 30ms.\r\n * @method reset Reset the schedule as if it has never started to begin with.\r\n */\r\nclass LazySchedule {\r\n    /**\r\n     * Create a new schedule.\r\n     * @param {(tries: number) => void} callback The callback function to execute when the interval's done.\r\n     * @param {(tries: number) => number} timerCalc A function to get the delay for the next schedule depending on the number of tries.\r\n     * @param {number} maxTries The maximum number of times to execute the schedule. If it's less than 0 then there's no maxTries and it will go on forever.\r\n     */\r\n    constructor(callback, timerCalc, maxTries = 1) {\r\n        this.startingTime = -1;\r\n        this.deltaTime = 0;\r\n        this.isStopped = false;\r\n        this.hasBeenStarted = false;\r\n        this.callback = callback;\r\n        this.timerCalc = timerCalc;\r\n        this.timer = undefined;\r\n        this.tries = 0;\r\n        this.maxTries = maxTries;\r\n    }\r\n    /**\r\n     * Reset the schedule as if it has never started to begin with.\r\n     */\r\n    reset() {\r\n        this.startingTime = -1;\r\n        this.tries = 0;\r\n        this.deltaTime = 0;\r\n        this.isStopped = false;\r\n        this.hasBeenStarted = false;\r\n        clearTimeout(this.timer);\r\n    }\r\n    /**\r\n     * Stop the schedule. If the schedule had to be triggered in 30ms, when you'll start the schedule again, the schedule would be executed after those remaining 30ms.\r\n     */\r\n    stop() {\r\n        clearTimeout(this.timer);\r\n        if (!this.isStopped && this.hasBeenStarted) {\r\n            this.deltaTime = Date.now() - this.startingTime;\r\n            this.tries--;\r\n        }\r\n        this.isStopped = true;\r\n    }\r\n    /**\r\n     * Start the schedule.\r\n     */\r\n    start() {\r\n        clearTimeout(this.timer);\r\n        this.hasBeenStarted = true;\r\n        this.isStopped = false;\r\n        // Either maxTries is not defined or maxTries is greater than the number of tries\r\n        if ((this.maxTries < 0) || (this.tries < this.maxTries)) {\r\n            this.startingTime = Date.now();\r\n            this.timer = setTimeout(() => {\r\n                this.tries = this.tries + 1;\r\n                this.callback(this.tries);\r\n            }, this.timerCalc(this.tries + 1) - this.deltaTime);\r\n            this.deltaTime = 0;\r\n        }\r\n    }\r\n}\r\nexports.LazySchedule = LazySchedule;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazySchedule.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazySlideContent = void 0;\r\nconst lazyAnimate_1 = __webpack_require__(/*! ./lazyAnimate */ \"./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js\");\r\n/**\r\n * Insert a smooth sliding effect in a `HTMLDetailsElement`. This `HTMLDetailsElement` should contain a `<summary>` element and a `<content>` element to be valid for the animation.\r\n * `shr_duration`: Shrinking duration. By default it's set to `200` ms.\r\n * `shr_ease`: Shrinking easing. By default it's set to \"ease-out\".\r\n * `exp_duration`: Expending duration. By default it's set to `200` ms.\r\n * `exp_ease`: Expending easing. By default it's set to \"ease-out\".\r\n */\r\nclass LazySlideContent {\r\n    constructor(el) {\r\n        var _a;\r\n        this.isClosing = false; // Store if the element is closing\r\n        this.isExpanding = false; // Store if the element is expanding\r\n        this.el = el; // Store the <details> element\r\n        this.summary = el.querySelector('summary'); // Store the <summary> element\r\n        this.content = el.querySelector('content'); // Store the <content> element\r\n        this.animation = null; // Store the animation object (so we can cancel it if needed)\r\n        // Detect user clicks on the summary element\r\n        (_a = this.summary) === null || _a === void 0 ? void 0 : _a.addEventListener('click', (e) => this.onClick(e));\r\n    }\r\n    onClick(e) {\r\n        if (lazyAnimate_1.LazyAnimate.MediaQuery && !lazyAnimate_1.LazyAnimate.MediaQuery.matches) { // Execute the animation only if the user allow animation being executed\r\n            e.preventDefault(); // Stop default behaviour from the browser\r\n            this.el.style.overflow = 'hidden'; // Add an overflow on the <details> to avoid content overflowing\r\n            if (this.isClosing || !this.el.open) { // Check if the element is being closed or is already closed\r\n                this.open();\r\n            }\r\n            else if (this.isExpanding || this.el.open) { // Check if the element is being openned or is already open\r\n                this.shrink();\r\n            }\r\n        }\r\n    }\r\n    shrink() {\r\n        var _a, _b, _c;\r\n        this.isClosing = true; // Set the element as \"being closed\"\r\n        const startHeight = `${this.el.offsetHeight}px`; // Store the current height of the element\r\n        const endHeight = `${(_a = this.summary) === null || _a === void 0 ? void 0 : _a.offsetHeight}px`; // Calculate the height of the summary\r\n        if (this.animation) { // If there is already an animation running\r\n            this.animation.cancel(); // Cancel the current animation\r\n        }\r\n        this.animation = this.el.animate({\r\n            height: [startHeight, endHeight] // Set the keyframes from the startHeight to endHeight\r\n        }, {\r\n            duration: Number((_b = this.el.getAttribute('shr_duration')) !== null && _b !== void 0 ? _b : 250),\r\n            easing: (_c = this.el.getAttribute('shr_ease')) !== null && _c !== void 0 ? _c : \"ease-out\"\r\n        });\r\n        this.animation.onfinish = () => this.onAnimationFinish(false); // When the animation is complete, call onAnimationFinish()\r\n        this.animation.oncancel = () => this.isClosing = false; // If the animation is cancelled, isClosing variable is set to false\r\n    }\r\n    open() {\r\n        this.el.style.height = `${this.el.offsetHeight}px`; // Apply a fixed height on the element\r\n        this.el.open = true; // Force the [open] attribute on the details element\r\n        window.requestAnimationFrame(() => this.expand()); // Wait for the next frame to call the expand function\r\n    }\r\n    expand() {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        this.isExpanding = true; // Set the element as \"being expanding\"\r\n        const startHeight = `${this.el.offsetHeight}px`; // Get the current fixed height of the element\r\n        const endHeight = `${((_b = (_a = this.summary) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = this.content) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0)}px`; // Calculate the open height of the element (summary height + content height)\r\n        if (this.animation) { // If there is already an animation running\r\n            this.animation.cancel(); // Cancel the current animation\r\n        }\r\n        this.animation = this.el.animate({\r\n            height: [startHeight, endHeight] // Set the keyframes from the startHeight to endHeight\r\n        }, {\r\n            duration: Number((_e = this.el.getAttribute('exp_duration')) !== null && _e !== void 0 ? _e : 250),\r\n            easing: (_f = this.el.getAttribute('exp_ease')) !== null && _f !== void 0 ? _f : \"ease-out\"\r\n        });\r\n        this.animation.onfinish = () => this.onAnimationFinish(true); // When the animation is complete, call onAnimationFinish()\r\n        this.animation.oncancel = () => this.isExpanding = false; // If the animation is cancelled, isExpanding variable is set to false\r\n    }\r\n    onAnimationFinish(open) {\r\n        this.el.open = open; // Set the open attribute based on the parameter\r\n        this.animation = null; // Clear the stored animation\r\n        // Reset isClosing & isExpanding\r\n        this.isClosing = false;\r\n        this.isExpanding = false;\r\n        this.el.style.height = this.el.style.overflow = ''; // Remove the overflow hidden and the fixed height\r\n    }\r\n}\r\nexports.LazySlideContent = LazySlideContent;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyTabularTextArea = void 0;\r\nconst lazyCaret_1 = __webpack_require__(/*! ./lazyCaret */ \"./node_modules/@lazy-toolbox/client/dist/lazyCaret.js\");\r\n/**\r\n * Add support for tabulation in a text area.\r\n */\r\nclass LazyTabularTextArea {\r\n    constructor(el, tabLength = 4) {\r\n        this.tabLength = tabLength;\r\n        this.editor = el;\r\n        this.onKeydown();\r\n    }\r\n    onKeydown() {\r\n        this.editor.addEventListener('keydown', (event) => {\r\n            if (event.key === 'Tab') {\r\n                lazyCaret_1.LazyCaret.tabulation(this.editor, event.shiftKey, this.tabLength);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyTabularTextArea = LazyTabularTextArea;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyTheme.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyTheme.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyTheme = void 0;\r\n/**\r\n * A lazy theme implementation.\r\n * @method theme Get the current theme used.\r\n * @method setNextTheme Change the theme to the next one available in the list.\r\n * @method setPreviousTheme Change the theme to the previous one available in the list.\r\n * @method setTheme Set the current theme on the page.\r\n * @method useTheme Use a theme that exist on the page otherwise it will use the current theme.\r\n */\r\nclass LazyTheme {\r\n    /**\r\n     * Create a theme handle by giving it a bunch of CSS classes for theme and all the elements that should be affected by it.\r\n     * @param themesClasses An array of all CSS classes that handle the theme.\r\n     * @param elementsQueries An array of all queries of the HTML elements that are affected by the theme.\r\n     */\r\n    constructor(themesClasses, elementsQueries) {\r\n        this.defaultTheme = 0;\r\n        this.themes = themesClasses;\r\n        this.elements = elementsQueries;\r\n    }\r\n    /**\r\n     * Get the current theme used.\r\n     * @returns {string} The name of the current CSS class that handle the theme.\r\n     */\r\n    theme() {\r\n        return this.themes[this.defaultTheme];\r\n    }\r\n    /**\r\n     * Change the theme to the next one available in the list.\r\n     */\r\n    setNextTheme() {\r\n        this.defaultTheme++;\r\n        this.toggleTheme();\r\n        this.setTheme();\r\n    }\r\n    /**\r\n     * Change the theme to the previous one available in the list.\r\n     */\r\n    setPreviousTheme() {\r\n        this.defaultTheme--;\r\n        this.toggleTheme();\r\n        this.setTheme();\r\n    }\r\n    /**\r\n     * Set the current theme on the page.\r\n     */\r\n    setTheme() {\r\n        const useTheme = this.themes[this.defaultTheme];\r\n        for (const element of this.elements) {\r\n            this.setNewTheme(element, useTheme);\r\n        }\r\n    }\r\n    /**\r\n     * Use a theme that exist on the page otherwise it will use the current theme.\r\n     * @param {string} newTheme The name of the theme to use.\r\n     */\r\n    useTheme(newTheme) {\r\n        let useTheme = newTheme;\r\n        if (!this.themes.includes(newTheme)) {\r\n            useTheme = this.themes[this.defaultTheme];\r\n        }\r\n        for (const element of this.elements) {\r\n            this.setNewTheme(element, useTheme);\r\n        }\r\n    }\r\n    /**\r\n     * Clamp the value of the defaultTheme with modulo.\r\n     */\r\n    toggleTheme() {\r\n        this.defaultTheme = this.defaultTheme - Math.floor(this.defaultTheme / this.themes.length) * this.themes.length;\r\n    }\r\n    /**\r\n     * Handle the DOM changes for the theme.\r\n     * @param elementQuery\r\n     * @param newTheme\r\n     */\r\n    setNewTheme(elementQuery, newTheme) {\r\n        const elements = document.querySelectorAll(elementQuery);\r\n        for (const e of elements) {\r\n            for (const t of this.themes) {\r\n                e.classList.remove(t);\r\n            }\r\n            e.classList.add(newTheme);\r\n        }\r\n    }\r\n}\r\nexports.LazyTheme = LazyTheme;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyTheme.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyTristate.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyTristate.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyTristate = void 0;\r\nconst TRISTATE_STATE = {\r\n    true: 'true',\r\n    false: 'false',\r\n    neutral: 'neutral',\r\n    TRUE: 'TRUE',\r\n    FALSE: 'FALSE',\r\n    NEUTRAL: 'NEUTRAL'\r\n};\r\n/**\r\n * A lazy way to use three states.\r\n */\r\nclass LazyTristate {\r\n    constructor(item) {\r\n        var _a;\r\n        const itemValue = (_a = (item.value !== \"\" ? item.value : undefined)) !== null && _a !== void 0 ? _a : 'neutral';\r\n        item.readOnly = true;\r\n        item.size = 1;\r\n        if (!itemValue) {\r\n            item.value = LazyTristate.NEUTRAL;\r\n            item.innerText = LazyTristate.NEUTRAL;\r\n        }\r\n        else {\r\n            const stateSymbol = LazyTristate.getState(itemValue);\r\n            item.value = stateSymbol;\r\n            item.innerText = stateSymbol;\r\n        }\r\n        item.addEventListener('click', (e) => {\r\n            const nextVal = LazyTristate.nextState(e.target.value);\r\n            item.value = nextVal;\r\n            item.innerText = nextVal;\r\n            if (\"createEvent\" in document) {\r\n                var evt = document.createEvent(\"Event\");\r\n                evt.initEvent(\"change\", false, true);\r\n                item.dispatchEvent(evt);\r\n            }\r\n            else {\r\n                item.dispatchEvent(new Event('change'));\r\n            }\r\n        });\r\n    }\r\n    static stateToString(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return \"true\";\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return \"neutral\";\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return \"false\";\r\n            default:\r\n                return \"undefined\";\r\n        }\r\n    }\r\n    static getState(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return LazyTristate.TRUE;\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return LazyTristate.NEUTRAL;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return LazyTristate.FALSE;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    static nextState(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return LazyTristate.FALSE;\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return LazyTristate.TRUE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return LazyTristate.NEUTRAL;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    static previousState(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return LazyTristate.NEUTRAL;\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return LazyTristate.FALSE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return LazyTristate.TRUE;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n}\r\nexports.LazyTristate = LazyTristate;\r\nLazyTristate.TRUE = '\\u2705';\r\nLazyTristate.FALSE = '\\u274C';\r\nLazyTristate.NEUTRAL = '\\u2753';\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyTristate.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyView.js":
/*!************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyView.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyView = void 0;\r\n/**\r\n * A bunch of lazy ways to handle some HTML injection or extraction.\r\n * @function replaceInsert Replace entirely an HTML <insert data=\"MyDataName\">Just some HTML comment code</insert> to any value contained inside the `newHTMLContent`.\r\n * @function inject Inject a bunch of datas inside a HTML document.\r\n * @function toNode Convert some HTML content into a ChildNode (if possible). If there's multiple HTML elements, only the first one will be returned.\r\n * @function toNodeList Convert some HTML content to a NodeListOf<ChildNode>.\r\n * @function toArray Convert some HTML content to an array of ChildNode.\r\n * @function toText Convert an array of ChildNode to string.\r\n */\r\nclass LazyView {\r\n    /**\r\n     * Get the innerHTML of the div element.\r\n     * @returns The innerHTML of the div element.\r\n     */\r\n    static extractHTML() {\r\n        const result = LazyView.div.innerHTML;\r\n        LazyView.div.innerHTML = '';\r\n        return result;\r\n    }\r\n    /**\r\n     * Replace entirely an HTML <insert data=\"MyDataName\">Just some HTML comment code</insert> to any value contained inside the `newHTMLContent`.\r\n     * @param {HTMLElement} actualElement An HTML element.\r\n     * @param {string} targetElement The value's name contained inside an insert tag.\r\n     * @param {string} newHTMLContent The content to inject.\r\n     */\r\n    static replaceInsert(actualElement, targetElement, newHTMLContent) {\r\n        while (true) {\r\n            let i, tmp, elm, last;\r\n            // find our target\r\n            const target = actualElement.querySelector(`insert[data=${targetElement}]`);\r\n            if (!target) {\r\n                break;\r\n            }\r\n            // create a temporary div or tr (to support tds)\r\n            tmp = document.createElement(newHTMLContent.indexOf('<td') != -1 ? 'tr' : 'div');\r\n            // fill that div with our html, this generates our children\r\n            tmp.innerHTML = newHTMLContent;\r\n            // step through the temporary div's children and insertBefore our target\r\n            i = tmp.childNodes.length;\r\n            last = target;\r\n            if (target.parentNode) {\r\n                while (i--) {\r\n                    target.parentNode.insertBefore((elm = tmp.childNodes[i]), last);\r\n                    last = elm;\r\n                }\r\n                /// remove the target.\r\n                target.parentNode.removeChild(target);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Inject a bunch of datas inside a HTML document.\r\n     * @param {string} htmlDoc The HTML document given as a string.\r\n     * @param {{[name: string]: string}} toInject The data to inject inside the document.\r\n     * @returns {string} The new HTML string with all the injections done.\r\n     */\r\n    static inject(htmlDoc, toInject) {\r\n        LazyView.div.innerHTML = htmlDoc;\r\n        for (const inject in toInject) {\r\n            LazyView.replaceInsert(LazyView.div, inject, toInject[inject]);\r\n        }\r\n        return LazyView.extractHTML();\r\n    }\r\n    /**\r\n     * Convert some HTML content into a ChildNode (if possible). If there's multiple HTML elements, only the first one will be returned.\r\n     * @param {string} content The HTML to convert into a ChildNode.\r\n     * @returns {ChildNode | null} The ChildNode made from the HTML string.\r\n     */\r\n    static toNode(content) {\r\n        LazyView.div.innerHTML = content;\r\n        const node = LazyView.div.firstChild;\r\n        LazyView.div.innerHTML = '';\r\n        return node;\r\n    }\r\n    /**\r\n     * Convert some HTML content to a NodeListOf<ChildNode>.\r\n     * @param {string} content The HTML to convert into a ChildNode.\r\n     * @returns {NodeListOf<ChildNode>} The NodeListOf<ChildNode> made from the HTML string.\r\n     */\r\n    static toNodeList(content) {\r\n        LazyView.div.innerHTML = content;\r\n        const nodes = LazyView.div.childNodes;\r\n        LazyView.div.innerHTML = '';\r\n        return nodes;\r\n    }\r\n    /**\r\n     * Convert some HTML content to an array of ChildNode.\r\n     * @param {string} content The HTML to convert into a ChildNode.\r\n     * @returns {ChildNode[]} The array of ChildNode made from the HTML string.\r\n     */\r\n    static toArray(content) {\r\n        LazyView.div.innerHTML = content;\r\n        const nodes = [...LazyView.div.childNodes];\r\n        LazyView.div.innerHTML = '';\r\n        return nodes;\r\n    }\r\n    /**\r\n     * Convert an array of ChildNode to string.\r\n     * @param {ChildNode[]} content The array of ChildNode to convert.\r\n     * @returns {string} The string made with the array of ChildNode.\r\n     */\r\n    static toText(content) {\r\n        for (const node of content) {\r\n            LazyView.div.appendChild(node);\r\n        }\r\n        return LazyView.extractHTML();\r\n    }\r\n}\r\nexports.LazyView = LazyView;\r\ntry {\r\n    LazyView.div = document.createElement('div');\r\n}\r\ncatch (e) { }\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyView.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.dateLogMS = exports.dateLog = exports.getType = exports.LazyRule = exports.LazyPattern = exports.LazyParsing = exports.LazyText = exports.LazyDataGraph = exports.LazyMapper = exports.LazyMath = void 0;\r\nvar lazyMath_1 = __webpack_require__(/*! ./lazyMath */ \"./node_modules/@lazy-toolbox/portable/dist/lazyMath.js\");\r\nObject.defineProperty(exports, \"LazyMath\", ({ enumerable: true, get: function () { return lazyMath_1.LazyMath; } }));\r\nvar lazyMapper_1 = __webpack_require__(/*! ./lazyMapper */ \"./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js\");\r\nObject.defineProperty(exports, \"LazyMapper\", ({ enumerable: true, get: function () { return lazyMapper_1.LazyMapper; } }));\r\nvar lazyDataGraph_1 = __webpack_require__(/*! ./lazyDataGraph */ \"./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js\");\r\nObject.defineProperty(exports, \"LazyDataGraph\", ({ enumerable: true, get: function () { return lazyDataGraph_1.LazyDataGraph; } }));\r\nvar lazyText_1 = __webpack_require__(/*! ./lazyText */ \"./node_modules/@lazy-toolbox/portable/dist/lazyText.js\");\r\nObject.defineProperty(exports, \"LazyText\", ({ enumerable: true, get: function () { return lazyText_1.LazyText; } }));\r\nvar lazyParsing_1 = __webpack_require__(/*! ./parser/lazyParsing */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js\");\r\nObject.defineProperty(exports, \"LazyParsing\", ({ enumerable: true, get: function () { return lazyParsing_1.LazyParsing; } }));\r\nvar lazyPattern_1 = __webpack_require__(/*! ./parser/lazyPattern */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js\");\r\nObject.defineProperty(exports, \"LazyPattern\", ({ enumerable: true, get: function () { return lazyPattern_1.LazyPattern; } }));\r\nvar lazyRule_1 = __webpack_require__(/*! ./parser/lazyRule */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js\");\r\nObject.defineProperty(exports, \"LazyRule\", ({ enumerable: true, get: function () { return lazyRule_1.LazyRule; } }));\r\nvar lazyTypeof_1 = __webpack_require__(/*! ./lazyTypeof */ \"./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js\");\r\nObject.defineProperty(exports, \"getType\", ({ enumerable: true, get: function () { return lazyTypeof_1.getType; } }));\r\nvar lazyLog_1 = __webpack_require__(/*! ./lazyLog */ \"./node_modules/@lazy-toolbox/portable/dist/lazyLog.js\");\r\nObject.defineProperty(exports, \"dateLog\", ({ enumerable: true, get: function () { return lazyLog_1.dateLog; } }));\r\nObject.defineProperty(exports, \"dateLogMS\", ({ enumerable: true, get: function () { return lazyLog_1.dateLogMS; } }));\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/index.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyDataGraph = void 0;\r\n/**\r\n * A non-visual graph to analyze variation in datas.\r\n */\r\nclass LazyDataGraph {\r\n    /**\r\n     * Create a new graph with some points.\r\n     * @param {GraphPoint[]} datas An array of points on the graph.\r\n     */\r\n    constructor(...datas) {\r\n        this._points = [...datas];\r\n        this.isTan = false;\r\n    }\r\n    /**\r\n     * Get the points on the graph.\r\n     */\r\n    get points() {\r\n        return [...this._points];\r\n    }\r\n    /**\r\n     * Set the points on the graph.\r\n     */\r\n    set points(pts) {\r\n        this._points = [...pts];\r\n    }\r\n    /**\r\n     * Check if the graph is a tangent graph or a root graph.\r\n     * @returns {boolean} True if the graph is a tangent graph.\r\n     */\r\n    isTangentGraph() {\r\n        return this.isTan;\r\n    }\r\n    /**\r\n     * Get the tangent graph, showing the difference happening between each points and the increased / decreased percentage.\r\n     * @returns {LazyDataGraph} The tangent graph.\r\n     */\r\n    getTangentGraph() {\r\n        const tanGraph = new LazyDataGraph(...this.generateSlope());\r\n        tanGraph.isTan = true;\r\n        return tanGraph;\r\n    }\r\n    /**\r\n     * Generate a bunch of tangent points from this graph.\r\n     * @returns {GraphPoint[]} The tangent points array.\r\n     */\r\n    generateSlope() {\r\n        if (this._points.length <= 1) {\r\n            return [];\r\n        }\r\n        const lastI = this._points.length - 1;\r\n        const slope = [];\r\n        for (let i = 0; i < lastI; i++) {\r\n            const actual = this._points[i];\r\n            const next = this._points[i + 1];\r\n            const preSlope = next.value - actual.value;\r\n            const result = {\r\n                value: preSlope,\r\n                label: `${actual.label}-${next.label}`,\r\n                increasePercent: preSlope / (actual.value != 0 ? actual.value : 1)\r\n            };\r\n            slope.push(result);\r\n        }\r\n        return slope;\r\n    }\r\n}\r\nexports.LazyDataGraph = LazyDataGraph;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyLog.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyLog.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.dateLog = exports.dateLogMS = void 0;\r\n/**\r\n * Create a message with the time display up to the ms.\r\n *\r\n * It will be showned as `[HH:MM:SS.DCM] MY_MESSAGE`.\r\n * @param {any} msg The message to display.\r\n * @returns {string} The string with the time displayed.\r\n */\r\nfunction dateLogMS(msg) {\r\n    const actualTime = new Date(Date.now());\r\n    let hours = `${actualTime.getHours()}`;\r\n    hours = hours.length == 1 ? `0${hours}` : hours;\r\n    let min = `${actualTime.getMinutes()}`;\r\n    min = min.length == 1 ? `0${min}` : min;\r\n    let sec = `${actualTime.getSeconds()}`;\r\n    sec = sec.length == 1 ? `0${sec}` : sec;\r\n    let milSec = `${actualTime.getMilliseconds()}`;\r\n    milSec = milSec.length == 1 ? `00${milSec}` : milSec.length == 2 ? `0${milSec}` : milSec;\r\n    return `[${hours}:${min}:${sec}.${milSec}] ${msg.toString()}`;\r\n}\r\nexports.dateLogMS = dateLogMS;\r\n;\r\n/**\r\n * Create a message with the time display up to the s.\r\n *\r\n * It will be showned as `[HH:MM:SS] MY_MESSAGE`.\r\n * @param {any} msg The message to display.\r\n * @returns {string} The string with the time displayed.\r\n */\r\nfunction dateLog(msg) {\r\n    const actualTime = new Date(Date.now());\r\n    let hours = `${actualTime.getHours()}`;\r\n    hours = hours.length == 1 ? `0${hours}` : hours;\r\n    let min = `${actualTime.getMinutes()}`;\r\n    min = min.length == 1 ? `0${min}` : min;\r\n    let sec = `${actualTime.getSeconds()}`;\r\n    sec = sec.length == 1 ? `0${sec}` : sec;\r\n    return `[${hours}:${min}:${sec}] ${msg.toString()}`;\r\n}\r\nexports.dateLog = dateLog;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyLog.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyMapper = void 0;\r\n/**\r\n * A mapper to allow some filtering for retrieved variables that could be undefined.\r\n */\r\nclass LazyMapper {\r\n    /**\r\n     * Filter a data and set a default value if the data is undefined. If it's defined, transform the data the way you want then filter whatever the result is.\r\n     * @param {any} data The data to filter.\r\n     * @param {T} defaultValue The default value to set to your data in case it's undefined.\r\n     * @param {(d: any) => T} transform A function to transform your any data type into your actual type.\r\n     * @param {(d: T) => T} filter A function to filter your data.\r\n     * @returns {T} The data with your choosen filtered data type.\r\n     */\r\n    static filterData(data, defaultValue, transform, filter) {\r\n        let result = defaultValue;\r\n        if (data !== undefined) {\r\n            result = transform(data);\r\n        }\r\n        return filter(result);\r\n    }\r\n    /**\r\n     * Filter the value of a received number or the default number in case the received number was undefined.\r\n     * @param {any} data The data to filter.\r\n     * @param {number} defaultValue The default number to set.\r\n     * @param {(d: number) => number} filter The filtering function.\r\n     * @returns {number} The filtered number.\r\n     */\r\n    static filterNumber(data, defaultValue, filter) {\r\n        return LazyMapper.filterData(data, defaultValue, (d) => d === null ? 0 : Number(d), filter);\r\n    }\r\n    /**\r\n     * Filter the value of a received string or the default string in case the received string was undefined.\r\n     * @param {any} data The data to filter.\r\n     * @param {string} defaultValue The default string to set.\r\n     * @param {(d: string) => string} filter The filtering function.\r\n     * @returns {string} The filtered number.\r\n     */\r\n    static filterString(data, defaultValue, filter) {\r\n        return LazyMapper.filterData(data, defaultValue, (d) => d === null ? defaultValue : String(d), filter);\r\n    }\r\n    /**\r\n     * Filter a data and set a default value if the data is undefined. If it's defined, transform the data the way you want.\r\n     * @param {any} data The data to filter.\r\n     * @param {T} defaultValue The default value to set to your data in case it's undefined.\r\n     * @param {(d: any) => T} transform A function to transform your any data type into your actual type.\r\n     * @returns {T} The data with your choosen filtered data type.\r\n     */\r\n    static defaultData(data, defaultValue, transform) {\r\n        return LazyMapper.filterData(data, defaultValue, transform, (d) => d);\r\n    }\r\n    /**\r\n     * Retrieve a boolean from a data. If the data is undefined, the value will be set to a default value.\r\n     * @param {any} data The data to filter.\r\n     * @param {boolean} defaultValue The default value to set to your data in case it's undefined.\r\n     * @returns {boolean} The filtered data.\r\n     */\r\n    static defaultBoolean(data, defaultValue) {\r\n        return LazyMapper.defaultData(data, defaultValue, (d) => d === null ? defaultValue : Boolean(d));\r\n    }\r\n    /**\r\n     * Retrieve a number from a data. If the data is undefined, the value will be set to a default value.\r\n     * @param {any} data The data to filter.\r\n     * @param {number} defaultValue The default value to set to your data in case it's undefined.\r\n     * @returns {number} The filtered data.\r\n     */\r\n    static defaultNumber(data, defaultValue) {\r\n        return LazyMapper.defaultData(data, defaultValue, (d) => d === null ? 0 : Number(d));\r\n    }\r\n    /**\r\n     * Retrieve a string from a data. If the data is undefined, the value will be set to a default value.\r\n     * @param {any} data The data to filter.\r\n     * @param {string} defaultValue The default value to set to your data in case it's undefined.\r\n     * @returns {string} The filtered data.\r\n     */\r\n    static defaultString(data, defaultValue) {\r\n        return LazyMapper.defaultData(data, defaultValue, (d) => d === null ? defaultValue : String(d));\r\n    }\r\n    /**\r\n     * Convert a data to a boolean type. If undefined, it's set to false by default.\r\n     * @param {any} data The data to convert.\r\n     * @returns {boolean} The boolean representation of the data.\r\n     */\r\n    static boolean(data) {\r\n        return LazyMapper.defaultData(data, false, (d) => Boolean(d));\r\n    }\r\n    /**\r\n     * Convert a data to a number type. If undefined, it's set to 0 by default.\r\n     * @param {any} data The data to convert.\r\n     * @returns {number} The number representation of the data.\r\n     */\r\n    static number(data) {\r\n        return LazyMapper.defaultData(data, 0, (d) => Number(d));\r\n    }\r\n    /**\r\n     * Convert a data to a string type. If undefined, it's set to \"\" by default.\r\n     * @param {any} data The data to convert.\r\n     * @returns {string} The string representation of the data.\r\n     */\r\n    static string(data) {\r\n        return LazyMapper.defaultData(data, \"\", (d) => d.toString());\r\n    }\r\n}\r\nexports.LazyMapper = LazyMapper;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyMath.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyMath.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyMath = void 0;\r\n/**\r\n * Add some lazy math that should have been available at first on JS.\r\n*/\r\nclass LazyMath {\r\n    /**\r\n     * Compute the remainder of a / b. a % b IS NOT modulo in JS for some reason.\r\n     * @param {number} a What we want the remainder from.\r\n     * @param {number} b What's dividing a.\r\n     * @returns A value between 0 (included) and the remainder of the divisor (not included).\r\n     */\r\n    static modulo(a, b) {\r\n        return a - Math.floor(a / b) * b;\r\n    }\r\n    /**\r\n     * Get the leftover to obtain an integer less or equal to n.\r\n     * @param {number} n The number to get the fractional part from.\r\n     * @returns {number} The fractional part of the number a.\r\n     */\r\n    static frac(n) {\r\n        return n - Math.floor(n);\r\n    }\r\n    /**\r\n     * Clamp a value between 0 and 1.\r\n     * @param {number} a The number to clamp.\r\n     * @returns {number} A value between 0 and 1.\r\n     */\r\n    static saturate(a) {\r\n        return (a > 1) ? 1 : (a < 0) ? 0 : a;\r\n    }\r\n    /**\r\n     * Iterative sum of f.\r\n     * @param {number} k The start index.\r\n     * @param {number} n The last index.\r\n     * @param {(i: number) => number} f A function to execute.\r\n     * @returns {number} The result of the sum.\r\n     */\r\n    static sum(k, n, f) {\r\n        let result = 0;\r\n        for (let i = k; i <= n; i++) {\r\n            result += f(i);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Iterative product of f.\r\n     * @param {number} k The start index.\r\n     * @param {number} n The last index.\r\n     * @param {(i: number) => number} f A function to execute.\r\n     * @returns {number} The result of the product.\r\n     */\r\n    static product(k, n, f) {\r\n        let result = 1;\r\n        for (let i = k; i <= n; i++) {\r\n            result *= f(i);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * A primary test that will return true if the number is prime. Since JS use floating point arithmetic on number, the number is floored before the test.\r\n     * @param {number} n The number to test.\r\n     * @returns {boolean} True if the number is prime.\r\n     */\r\n    static isPrime(n) {\r\n        n = Math.floor(n);\r\n        if (n <= 3) {\r\n            if (n < 0) {\r\n                n = -n;\r\n            }\r\n            if (n <= 3) {\r\n                return (n > 1);\r\n            }\r\n        }\r\n        if (n % 2 == 0 || n % 3 == 0) {\r\n            return false;\r\n        }\r\n        for (let i = 5; i * i <= n; i += 6) {\r\n            if (n % i == 0 || n % (i + 2) == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Return 1 if x is gequal to n, otherwise n.\r\n     * @param {number} n Number to apply step.\r\n     * @param {number} x Step comparison.\r\n     * @returns {number} The result of the operation.\r\n     */\r\n    static step(n, x) {\r\n        return x >= n ? 1 : n;\r\n    }\r\n    /**\r\n     * Do a linear interpolation between a and b using the parameter t for the interpolated distance.\r\n     * @param {number} a The starting position.\r\n     * @param {number} b The ending position.\r\n     * @param {number} t A value between 0 and 1 (0 being 0% and 1 being 100%), determining how much we interpolate between a and b.\r\n     * @returns {number} A number between a and b depending on t.\r\n     */\r\n    static lerp(a, b, t) {\r\n        return a + (b - a) * t;\r\n    }\r\n    /**\r\n     * Get the interpolated distance of p on the line from a to b.\r\n     * @param {number} a The starting position.\r\n     * @param {number} b The ending position.\r\n     * @param {number} p A value between a and b.\r\n     * @returns {number} A value between 0 and 1 representing the interpolated percentage between a and b.\r\n     */\r\n    static unlerp(a, b, p) {\r\n        return (p - a) / (b - a);\r\n    }\r\n    /**\r\n     * Compute the number of ways to choose an unordered subset of k elements from a fixed set of n elements. n  k  0.\r\n     * @param {number} n Number of elements.\r\n     * @param {number} k Number of subset.\r\n     * @returns {number} The positive integers that occur as coefficients in the binomial theorem.\r\n     */\r\n    static binomialCoefficient(n, k) {\r\n        const mid = n / 2;\r\n        if (k > n) {\r\n            throw new Error(\"k can't be greater than n.\");\r\n        }\r\n        if (k == n) {\r\n            return 1;\r\n        }\r\n        if (k > mid) {\r\n            let num = 1;\r\n            let den = 1;\r\n            for (let i = k + 1, j = 1; i <= n; i++, j++) {\r\n                num *= i;\r\n                den *= j;\r\n            }\r\n            return num / den;\r\n        }\r\n        else if (n % 2 == 0 && mid == k) {\r\n            let num = 1;\r\n            let den = 1;\r\n            let i;\r\n            for (i = 1; i <= mid; i++) {\r\n                den *= i;\r\n            }\r\n            for (; i <= n; i++) {\r\n                num *= i;\r\n            }\r\n            return num / den;\r\n        }\r\n        else {\r\n            const nk = n - k;\r\n            let num = 1;\r\n            let den = 1;\r\n            for (let i = nk + 1, j = 1; i <= n; i++, j++) {\r\n                num *= i;\r\n                den *= j;\r\n            }\r\n            return num / den;\r\n        }\r\n    }\r\n    /**\r\n     * Evaluate the derivative of a function f at a point x. d/dx f(x)\r\n     * @param {number} x Evaluation point.\r\n     * @param {number} f Function f.\r\n     * @returns {number} The result of f'(x).\r\n     */\r\n    static derivative(x, f) {\r\n        const eps = 0.000000000000000919191919;\r\n        return (f(x + eps) - f(x)) / eps;\r\n    }\r\n    /**\r\n     * Evaluate the anti-derivative of a function f' at a point x.  f'(x) dx\r\n     * @param {number} x Evaluation point.\r\n     * @param {number} f Function f'.\r\n     * @param {number} subdivide The number of subdivision to use. The more you have, the better the approximation.\r\n     * @returns {number} The result of F(x).\r\n     */\r\n    static antiDerivative(x, f, subdivide = 50) {\r\n        if (subdivide <= 0) {\r\n            subdivide = 1;\r\n        }\r\n        let result = 0;\r\n        const offset = x / subdivide;\r\n        for (let i = 0; i < subdivide; i++) {\r\n            result += f(offset * i) * offset;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Evaluate the area under the curve of a function f' from a to b. _a^b f'(x) dx\r\n     * @param {number} a The point to start.\r\n     * @param {number} b The point to end.\r\n     * @param {number} f Function f'.\r\n     * @param {number} subdivide The number of subdivision to use. The more you have, the better the approximation.\r\n     * @returns {number} The result of F(b) - F(a).\r\n     */\r\n    static integral(a, b, f, subdivide = 50) {\r\n        if (subdivide <= 0) {\r\n            subdivide = 1;\r\n        }\r\n        let result = 0;\r\n        const offset = (b - a) / subdivide;\r\n        for (let i = 0; i < subdivide; i++) {\r\n            result += f(a + offset * i) * offset;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Return an array of ordered combination without repetition of n objets (a string array) classified in k groups.\r\n     * @param {T[]} objects An array of object to reorder.\r\n     * @param {number} k The number of classified groups.\r\n     * @returns {any[]} Return an array where each cell contain the grouping result of the object.\r\n     */\r\n    static combinationArrayNRNO(objects, k) {\r\n        let n = objects.length; // Assign n as the length of all objets or the number passed through the function\r\n        if (n < k) // n must be greater or equal to k...\r\n         {\r\n            throw new Error('The number of object must be greater or equal to k.');\r\n        }\r\n        const offset = n - k + 1; // The offset generated by the number of group\r\n        let result = []; // Declare the result\r\n        for (let i = 0; i < offset; i++) // Loop through all possible values on the first element\r\n         {\r\n            let content = [];\r\n            content.push(objects[i]);\r\n            let generated = LazyMath.combinationArrayDepthNRNO(objects, // Pass our objects\r\n            i + 1, // Go to the next index to get the start of the next element\r\n            offset + 1, // Subgroup gain a start offset of 1\r\n            k - 1, // Align k for depth check since array start at 0\r\n            0, // No depth, it's the 1st subgroup\r\n            content // Pass the container of objets itself for referencing\r\n            );\r\n            Array.prototype.push.apply(result, generated); // Combine result\r\n        }\r\n        return result; // Return the result\r\n    }\r\n    /***\r\n     * Generate an array of the entire set of element made out of binomial coefficient by taking the depth stack into account.\r\n     */\r\n    static combinationArrayDepthNRNO(objects, index, offset, k, depth = 0, content = []) {\r\n        if (depth >= k) { // If our depth is grater or equal to k, then we have all we need\r\n            return [content]; // We return the new array of objects made on the way.\r\n        }\r\n        let result = []; // Declare a result\r\n        for (let i = index; i < offset; i++) // Loop through the possible values between index and offset - 1\r\n         {\r\n            let copyContent = [...content, objects[i]];\r\n            let generated = LazyMath.combinationArrayDepthNRNO(objects, i + 1, // Go to the next index to get the start of the next element\r\n            offset + 1, // Subgroup gain a start offset of 1\r\n            k, // Just passing k along, it's already align if nothing goes wrong\r\n            depth + 1, // Next depth of the stack\r\n            copyContent // Pass the container of newly packed objets itself for referencing\r\n            ); // Go into nested combinations\r\n            Array.prototype.push.apply(result, generated); // Combine result\r\n        }\r\n        return result; // Return the result\r\n    }\r\n}\r\nexports.LazyMath = LazyMath;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyMath.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyText.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyText.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyText = void 0;\r\n/**\r\n * Shorthand static class for special string functions.\r\n */\r\nclass LazyText {\r\n    /**\r\n     * A shorthand function to extract a certain number of character from a string.\r\n     * @param {string} content The string where we want to extract content from.\r\n     * @param {number} index The index from which we start.\r\n     * @param {number} nbrLetters The number of letters to extract.\r\n     * @returns {string} Return a string of nbrLetters characters if there is that many from a starting point.\r\n     */\r\n    static extract(content, index, nbrLetters) {\r\n        return content.substring(index, index + nbrLetters);\r\n    }\r\n    /**\r\n     * Extract the content from a string starting at a specific index until the predicate is false.\r\n     * @param {string} content The source string from which we get the content to extract.\r\n     * @param {number} startIndex The starting index.\r\n     * @param {(c: string, i: number, txt: string)=>boolean} predicate A function to check if we include the character.\r\n     * @returns {{lastIndex: number, value:string}} An object containing the substring made by following the predicate rule and the last index extracted.\r\n     */\r\n    static extractFromUntil(content, startIndex, predicate) {\r\n        let lastIndex = startIndex;\r\n        for (let i = startIndex; content.length; i++) {\r\n            if (!predicate(content[i], i, content)) {\r\n                break;\r\n            }\r\n            lastIndex = i;\r\n        }\r\n        return {\r\n            value: LazyText.extract(content, startIndex, lastIndex - startIndex),\r\n            lastIndex: lastIndex\r\n        };\r\n    }\r\n    /**\r\n     * Return the number of lines contained inside a string.\r\n     * @param {string} content The string content from which we want to count the lines.\r\n     * @returns {number} The number of lines contained in the string.\r\n     */\r\n    static countLines(content) {\r\n        let line = 1;\r\n        for (let i = 0; i < content.length; i++) {\r\n            if (content[i] === '\\n') {\r\n                line++;\r\n            }\r\n        }\r\n        return line;\r\n    }\r\n    /**\r\n     * Find the number of lines from the start of a string until a specified index, finding the character position of that element on the way.\r\n     * @param {string} content The string we're going to look.\r\n     * @param {number} maxIndex The last index we're going to look.\r\n     * @returns {{lines: number; lineChar: number;}} An object containing the number of lines found and the character position of the last index in it's current line.\r\n     */\r\n    static countLinesChar(content, maxIndex) {\r\n        const result = {\r\n            lines: 1,\r\n            lineChar: 0\r\n        };\r\n        const lastIndex = maxIndex !== null && maxIndex !== void 0 ? maxIndex : content.length - 1;\r\n        for (let i = 0; i <= lastIndex; i++) {\r\n            result.lineChar++;\r\n            if (content[i] === '\\n') {\r\n                result.lines++;\r\n                result.lineChar = 0;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LazyText = LazyText;\r\nLazyText.letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\r\n    '', '', '', '',\r\n    '', '', '', '',\r\n    '', '', '', '',\r\n    '', '', '', '',\r\n    '', '', '', '',\r\n    '', ''\r\n];\r\nLazyText.digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\r\nLazyText.variables = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\r\n    '_', '$', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\r\n];\r\nLazyText.controls = ['\\n', '\\t'];\r\nLazyText.whitespaces = [' '];\r\nLazyText.symbols = ['', '@', '', '', '', '&', '|', '#', '^', '*', '$', '%', '', '=', '+', '-', '*', '/', '\\\\', '<', '>', '~', '', '_', '`', '', '', '(', ')', '[', ']', '{', '}'];\r\nLazyText.punctuations = ['.', ',', ';', ':', '?', '!', '\"', '\\'', '', '', '', ''];\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyText.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getType = void 0;\r\n/**\r\n * Get the type of the parameter, extending `typeof` to support `class` and `array` as native options.\r\n * @param {any} parameter The parameter to test.\r\n * @returns {string} The type attributed to the parameter.\r\n */\r\nfunction getType(parameter) {\r\n    if (typeof parameter === 'function' && /^\\s*class\\s+/.test(parameter.toString())) {\r\n        return 'class';\r\n    }\r\n    if (Array.isArray(parameter)) {\r\n        return 'array';\r\n    }\r\n    return typeof parameter;\r\n}\r\nexports.getType = getType;\r\n;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyParsing = void 0;\r\nconst lazyText_1 = __webpack_require__(/*! ../lazyText */ \"./node_modules/@lazy-toolbox/portable/dist/lazyText.js\");\r\nconst lazyPattern_1 = __webpack_require__(/*! ./lazyPattern */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js\");\r\nconst lazyTypeof_1 = __webpack_require__(/*! ../lazyTypeof */ \"./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js\");\r\n/**\r\n * A more natural way to parse datas with custom rules set in specific testing order.\r\n */\r\nclass LazyParsing {\r\n    /**\r\n     * The constructor of the parser.\r\n     * @param {BasicRule[]} rules The rules to implement into the parser.\r\n     */\r\n    constructor(...rules) {\r\n        this.rules = [];\r\n        this.rules.push(...rules);\r\n    }\r\n    /**\r\n     * Add rules to the parser.\r\n     * @param {BasicRule[]} rules The rules to implement into the parser.\r\n     */\r\n    addRules(...rules) {\r\n        this.rules.push(...rules);\r\n    }\r\n    /**\r\n     * Remove rules from the parser.\r\n     * @param {string[]} rulesName The name of the rules to remove from the parser.\r\n     */\r\n    removeRules(...rulesName) {\r\n        for (const ruleName of rulesName) {\r\n            for (let i = this.rules.length - 1; i >= 0; i--) {\r\n                if (this.rules[i].name && this.rules[i].name === ruleName) {\r\n                    delete this.rules[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Convert a string to an object representation following specific rules.\r\n     * @param {string} text The text to parse.\r\n     * @returns {PatternFound[]} The parsed content.\r\n     */\r\n    parse(text) {\r\n        return LazyParsing.parse(text, LazyParsing.createSet(...this.rules)).result;\r\n    }\r\n    /**\r\n     * Create a set of patterns from a set of rules.\r\n     * @param {BasicRule[]} rules The set of rules to use.\r\n     * @returns {LazyPattern[]} An array of all patterns.\r\n     */\r\n    static createSet(...rules) {\r\n        const result = [];\r\n        for (const pattern of rules) {\r\n            result.push(new lazyPattern_1.LazyPattern(pattern));\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n    * Search every pattern to parse it into an object.\r\n    * @param {string} txtContent The string we're currently parsing.\r\n    * @param {LazyPattern[]} patternSet A list of different pattern to compute.\r\n    * @param {number} i The index with default value to 0. Can be modified for nested searching.\r\n    * @param {(index: number, c: string, text: string) => boolean} endPattern A function to check if a pattern ended.\r\n    * @return {{isPatternEnd: boolean, result: PatternFound[], lastIndex: number}} Return an object representing the value parsed.\r\n    */\r\n    static parse(txtContent, patternSet, i = 0, endPattern = (i, c, t) => { return false; }) {\r\n        var _a;\r\n        const subdivided = []; // A result called subdivided since it's the input subdivided in multiple pieces.\r\n        for (; i < txtContent.length; i++) // Let's navigate the input\r\n         {\r\n            if (endPattern(i, txtContent[i], txtContent)) // We're in a nested pattern that just ended\r\n             {\r\n                return {\r\n                    isPatternEnd: true,\r\n                    result: subdivided,\r\n                    lastIndex: i\r\n                };\r\n            }\r\n            for (let j = 0; j < patternSet.length; j++) // Let's check all the possible patterns\r\n             {\r\n                if (patternSet[j].isActualPattern(i, txtContent[i], txtContent)) // It's the pattern, let's execute something\r\n                 {\r\n                    const lineData = lazyText_1.LazyText.countLinesChar(txtContent, i);\r\n                    const fetchResult = patternSet[j].fetchContent(i, txtContent[i], txtContent, patternSet, patternSet[j]); // Execute something then return the fetched result\r\n                    if (fetchResult.lastIndex !== undefined) {\r\n                        i = fetchResult.lastIndex; // Assign the new index\r\n                    }\r\n                    else {\r\n                        throw new Error('Missing returned lastIndex in a fetch.');\r\n                    }\r\n                    let resultObject = {\r\n                        name: (_a = patternSet[j]) === null || _a === void 0 ? void 0 : _a.name,\r\n                        currentName: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.name,\r\n                        begin: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.begin,\r\n                        end: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.end,\r\n                        nested: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.nested,\r\n                        content: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.content,\r\n                        error: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.error,\r\n                        line: lineData === null || lineData === void 0 ? void 0 : lineData.lines,\r\n                        lineChar: lineData === null || lineData === void 0 ? void 0 : lineData.lineChar\r\n                    };\r\n                    subdivided.push(resultObject); // Insert an array of 2 elements (name and content) of the tested pattern inside our subdivided variable.\r\n                    break; // No need to check more pattern, we've got one already\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            isPatternEnd: false,\r\n            result: subdivided,\r\n            lastIndex: i - 1\r\n        };\r\n    }\r\n    /**\r\n     * Convert the result of a pattern to a string representation.\r\n     * @param {PatternResult | PatternFound[]} content The parsed content.\r\n     * @param {boolean} spacing If true, the result will be written while taking into account the spacing of every elements.\r\n     * @returns {string} The stringified content of the pattern.\r\n     */\r\n    static toString(content, spacing = false) {\r\n        return LazyParsing.extractString((0, lazyTypeof_1.getType)(content) !== 'array' ? content.result : content, spacing);\r\n    }\r\n    /**\r\n     * Convert the result of a pattern to a string representation with some datas represented.\r\n     * @param {PatternResult | PatternFound[]} content The parsed content.\r\n     * @param spacing If true, the result will be written while taking into account the spacing of every elements.\r\n     * @returns {string} The stringified content of the pattern.\r\n     */\r\n    static toStringDebug(content, spacing = false) {\r\n        return LazyParsing.stringifyParse((0, lazyTypeof_1.getType)(content) !== 'array' ? content.result : content, spacing);\r\n    }\r\n    static generateSpace(d) {\r\n        let spacing = '';\r\n        for (let i = 0; i < d; i++) {\r\n            spacing = `${spacing}    `;\r\n        }\r\n        return spacing;\r\n    }\r\n    static extractString(nodes, spacing = false, depth = 0) {\r\n        const space = spacing ? LazyParsing.generateSpace(depth) : '';\r\n        const lineReturn = spacing ? '\\n' : '';\r\n        let result = '';\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].nested) { // This node is a sub element (an array if nothing goes wrong)\r\n                result = `${result}${space}${nodes[i].begin}${lineReturn}`;\r\n                if (!nodes[i].error) {\r\n                    result = `${result}${LazyParsing.extractString(nodes[i].content, spacing, depth + 1)}${lineReturn}${space}${nodes[i].end}${lineReturn}`;\r\n                }\r\n            }\r\n            else { // It's a string, ez pz let's write it with some spacing\r\n                result = `${result}${space}${nodes[i].content}${lineReturn}`;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static stringifyParse(nodes, spacing = false, depth = 0) {\r\n        const space = spacing ? LazyParsing.generateSpace(depth) : '';\r\n        const lineReturn = spacing ? '\\n' : '';\r\n        let result = '';\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].nested) { // This node is a sub element (an array if nothing goes wrong)\r\n                result = `${result}${space}[${nodes[i].name}][Nested]: ${nodes[i].begin}${lineReturn}`;\r\n                if (!nodes[i].error) {\r\n                    result = `${result}${LazyParsing.stringifyParse(nodes[i].content, spacing, depth + 1)}${space}${nodes[i].end}${lineReturn}`;\r\n                }\r\n            }\r\n            else { // It's a string, ez pz let's write it with some spacing\r\n                result = `${result}${space}[${nodes[i].name}]: ${nodes[i].content}${lineReturn}`;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LazyParsing = LazyParsing;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyPattern = void 0;\r\n/**\r\n * LazyPattern is a generic class made to check for pattern while looking inside a string.\r\n * It fetch it's inner value with the pattern founded and then return it's last index.\r\n */\r\nclass LazyPattern {\r\n    /**\r\n    * Create a pattern object with a bunch of parameters for full customisation.\r\n    * @param {BasicRule} pattern\r\n    */\r\n    constructor(pattern) {\r\n        var _a;\r\n        this._name = (_a = pattern.name) !== null && _a !== void 0 ? _a : \"\";\r\n        this.defaultValue = pattern.defaultValue;\r\n        this.isPattern = pattern.isPattern;\r\n        this.isPatternEnd = pattern.isPatternEnd;\r\n        this.fetch = pattern.fetch;\r\n    }\r\n    /**\r\n    * Get the name of the current pattern.\r\n    */\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    /**\r\n    * Check if we found the pattern.\r\n    * @param {number} i The actual index tested.\r\n    * @param {string} c The actual character tested.\r\n    * @param {string} t The actual text content parsed for special cases.\r\n    * @returns True only if it match the pattern.\r\n    */\r\n    isActualPattern(i, c, t) {\r\n        if (this.isPattern !== undefined && this.isPattern !== null) {\r\n            return this.isPattern(i, c, t);\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * Check if the pattern ended, used to handle nesting.\r\n    * @param {number} i The actual index tested.\r\n    * @param {string} c The actual character tested.\r\n    * @param {string} t The actual text content parsed for special cases.\r\n    * @returns True only if it match the pattern.\r\n    */\r\n    isEndPattern(i, c, t) {\r\n        if (this.isPatternEnd !== undefined && this.isPatternEnd !== null) {\r\n            return this.isPatternEnd(i, c, t);\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * Assign the new content matching the desired pattern then return the last index of the pattern.\r\n    * @param {number} i The actual index tested.\r\n    * @param {string} c The actual character tested.\r\n    * @param {string} t The actual text content parsed for special cases.\r\n    * @param {LazyPattern[]} patternSet The actual text content parsed for special cases.\r\n    * @param {LazyPattern} actualPattern The actual pattern we're testing, used for referencing.\r\n    * @returns An object containing the last index of the pattern and the content to fetch. Content is equal to the default value in case fetch isn't defined.\r\n    */\r\n    fetchContent(i, c, t, patternSet, actualPattern) {\r\n        if (this.fetch !== undefined && this.fetch !== null) {\r\n            return this.fetch(i, c, t, actualPattern.isPatternEnd, patternSet);\r\n        }\r\n        return {\r\n            lastIndex: i,\r\n            content: this.defaultValue\r\n        };\r\n    }\r\n}\r\nexports.LazyPattern = LazyPattern;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyRule = void 0;\r\nconst lazyParsing_1 = __webpack_require__(/*! ./lazyParsing */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js\");\r\nconst lazyText_1 = __webpack_require__(/*! ../lazyText */ \"./node_modules/@lazy-toolbox/portable/dist/lazyText.js\");\r\n/**\r\n * A generic rule maker. It creates rules for LazyParsing.\r\n */\r\nclass LazyRule {\r\n    /**\r\n     * A basic pattern to extract a specific character.\r\n     * @param {string} name Name of the pattern.\r\n     * @param {(c:string) => boolean} predicate The function to test the character.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static simpleChar(name, predicate) {\r\n        return {\r\n            name: name,\r\n            defaultValue: null,\r\n            isPattern: (i, c, txt) => { return predicate(c); },\r\n            fetch: (index, c, txt) => {\r\n                return { name: name, content: c, lastIndex: index };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern to extract a specific string.\r\n     * @param {string} name Name of the pattern.\r\n     * @param {string} extractString The function to test the string.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static simpleKeys(name, ...extractStrings) {\r\n        return {\r\n            name: name,\r\n            defaultValue: null,\r\n            isPattern: (i, c, txt) => {\r\n                for (let extracted of extractStrings) {\r\n                    if (txt.substring(i, i + extracted.length) === extracted) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                let result = {\r\n                    name: name,\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                for (let extracted of extractStrings) {\r\n                    if (txt.substring(index, index + extracted.length) === extracted) {\r\n                        result.content = txt.substring(index, index + extracted.length);\r\n                        result.lastIndex = index + extracted.length - 1;\r\n                        break;\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic charbox that will contain the nested in-between string content.\r\n     * @param {string} name The name of the charbox.\r\n     * @param {string} begin The string that begin the charbox.\r\n     * @param {string} end The string that end the charbox.\r\n     * @param {LazyPattern[] | undefined} overridePatternSet An override to use new rules inside the charbox.\r\n     * @param {(i: number, c: string, txt: string) => boolean | undefined} overrideIsPatternEnd An override to use a new end pattern to handle special cases.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static simpleCharbox(name, begin, end, overridePatternSet, overrideIsPatternEnd) {\r\n        return {\r\n            name: name,\r\n            defaultValue: begin,\r\n            begin: begin,\r\n            end: end,\r\n            isPattern: (i, c, txt) => { return txt.substring(i, i + begin.length) === begin; },\r\n            isPatternEnd: (i, c, txt) => {\r\n                if (overrideIsPatternEnd) {\r\n                    return overrideIsPatternEnd(i, c, txt);\r\n                }\r\n                return txt.substring(i, i + end.length) === end;\r\n            },\r\n            fetch: (index, c, txt, endPattern, patternSet) => {\r\n                const p = lazyParsing_1.LazyParsing.parse(txt, overridePatternSet ? (overridePatternSet.length == 0 ? (patternSet !== null && patternSet !== void 0 ? patternSet : []) : overridePatternSet) : (patternSet !== null && patternSet !== void 0 ? patternSet : []), index + begin.length, overrideIsPatternEnd !== null && overrideIsPatternEnd !== void 0 ? overrideIsPatternEnd : endPattern); // Let's look for nested pattern over here..\r\n                // We could filter patternSet if we wanted to get rid of some functions for this case or use whatever we want anyway.\r\n                if (p.isPatternEnd) // It's the end of our pattern\r\n                 {\r\n                    return {\r\n                        name: name,\r\n                        content: p.result,\r\n                        error: false,\r\n                        nested: true,\r\n                        begin: begin,\r\n                        end: end,\r\n                        lastIndex: p.lastIndex + end.length - 1\r\n                    }; // Return what we got\r\n                }\r\n                else // Something went wrong with brackets (user input) since it was never closed.\r\n                 {\r\n                    return {\r\n                        name: name,\r\n                        content: begin,\r\n                        nested: true,\r\n                        error: true,\r\n                        begin: begin,\r\n                        end: end,\r\n                        lastIndex: index\r\n                    };\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract words. Words can only be made with letters.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static word() {\r\n        return {\r\n            name: 'word',\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => { return lazyText_1.LazyText.letters.includes(c); },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'word',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                for (let i = index; i < txt.length; i++) {\r\n                    if (!lazyText_1.LazyText.letters.includes(txt[i])) { // Not a letter?\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                }\r\n                result.content = txt.substring(index, result.lastIndex + 1);\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract numbers. The number can only be written in the form `125` or either `1.2123` if `comaOverDot = false` otherwise `1,2123`.\r\n     * @param {boolean} comaOverDot If true, numbers must be written as \"x,y\" instead of \"x.y\".\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static number(comaOverDot = false, exp = false) {\r\n        let dot = comaOverDot ? ',' : '.';\r\n        return {\r\n            name: 'number',\r\n            defaultValue: 0,\r\n            isPattern: (i, c, txt) => {\r\n                const isDecimal = c === dot && lazyText_1.LazyText.digits.includes(lazyText_1.LazyText.extract(txt, i + 1, 1));\r\n                return lazyText_1.LazyText.digits.includes(c) || isDecimal;\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'number',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                let alreadyDecimal = false;\r\n                let isExp = false;\r\n                for (let i = index; i < txt.length; i++) {\r\n                    if (!lazyText_1.LazyText.digits.includes(txt[i])) // Not a digit?\r\n                     {\r\n                        if (txt[i] === 'e' && exp && !isExp) {\r\n                            isExp = true;\r\n                            if (\r\n                            // e+D || e-D || eD\r\n                            (i + 2 < txt.length && (txt[i + 1] === '+' || txt[i + 1] === '-') && lazyText_1.LazyText.digits.includes(txt[i + 2]))\r\n                                || (i + 1 < txt.length && lazyText_1.LazyText.digits.includes(txt[i + 1]))) {\r\n                                result.content = `${result.content}${txt[i]}${txt[i + 1]}`;\r\n                                result.lastIndex = ++i; // Assign the last index\r\n                                continue;\r\n                            }\r\n                            else { // Is not an exponent ! => e?\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!alreadyDecimal && txt[i] === dot) // It's decimal number\r\n                         {\r\n                            alreadyDecimal = true; // We defined it as decimal to skip problems in case of multiple decimal marks\r\n                            if (result.content.length == 0) // .5 as example\r\n                             {\r\n                                result.content = `0.`; // 0.5 now\r\n                            }\r\n                            else {\r\n                                result.content = `${result.content}.`; // xxx.yyy\r\n                            }\r\n                            result.lastIndex = i; // Assign the last index\r\n                            continue;\r\n                        }\r\n                        result.lastIndex = i - 1; // Since this index is something we shouldn't bother with, let him tested by something else\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                    result.content = `${result.content}${txt[i]}`;\r\n                }\r\n                result.content = result.content; // Type hack\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract a variable name. The variable name must be composed of only letters and underscores.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static variable() {\r\n        return {\r\n            name: 'variable',\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => {\r\n                return lazyText_1.LazyText.letters.includes(c) || (c === '_'); // begin with _\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'variable',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                for (let i = index; i < txt.length; i++) {\r\n                    if (!lazyText_1.LazyText.letters.includes(txt[i]) && txt[i] !== '_') // Not a letter and not underscore\r\n                     {\r\n                        result.lastIndex = i - 1; // Since this index is something we shouldn't bother with, let him tested by something else\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                }\r\n                result.content = txt.substring(index, result.lastIndex + 1);\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract keywords. They must begin by a letter or an underscore and can only contains letters or underscores.\r\n     * @param {string[]} keywordList A list of keywords.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static keyword(...keywordList) {\r\n        return {\r\n            name: 'keyword',\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => {\r\n                const sizeLeft = txt.length - i;\r\n                for (const keyword of keywordList) {\r\n                    if (keyword.length <= sizeLeft) {\r\n                        const currentContent = txt.substring(i, i + keyword.length);\r\n                        if (currentContent === keyword) { // Probably keyword\r\n                            const currentNextIndex = i + keyword.length;\r\n                            if (!(currentNextIndex < txt.length && (lazyText_1.LazyText.letters.includes(txt[currentNextIndex]) || txt[currentNextIndex] === '_'))) {\r\n                                // Definitly keyword\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'keyword',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                const sizeLeft = txt.length - index;\r\n                for (let keyword of keywordList) {\r\n                    if (keyword.length <= sizeLeft) {\r\n                        const currentContent = txt.substring(index, index + keyword.length);\r\n                        if (currentContent === keyword) { // Probably keyword\r\n                            const currentNextIndex = index + keyword.length;\r\n                            if (!(currentNextIndex < txt.length && (lazyText_1.LazyText.letters.includes(txt[currentNextIndex]) || txt[currentNextIndex] === '_'))) {\r\n                                // Definitly keyword\r\n                                result.content = currentContent;\r\n                                result.lastIndex = currentNextIndex - 1;\r\n                                return result;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern to extract any character without exception.\r\n     * @param {string} name Name of the rule.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static any(name) {\r\n        return {\r\n            name: name,\r\n            defaultValue: null,\r\n            isPattern: (i, c, txt) => true,\r\n            fetch: (index, c, txt) => {\r\n                return { name: name, content: c, lastIndex: index };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern to extract a string like syntax. It will work the same as c/c++/c#/js/java/... string. So whatever is your `between` value, if it's \"\\\\myStringValue\", it will be escaped.\r\n     * @param {string} name Name of the rule.\r\n     * @param {string} between The string container. If between = '\"', then it will parse a string the same way js does.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static parseString(name, between) {\r\n        return {\r\n            name: name,\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => txt.substring(i, i + between.length) === between,\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: name,\r\n                    content: '',\r\n                    error: false,\r\n                    lastIndex: index\r\n                };\r\n                let isOut = false;\r\n                for (let i = index + between.length; i < txt.length; i++) {\r\n                    if (txt[i] === \"\\\\\") { // is anti-slash\r\n                        i++;\r\n                        result.lastIndex = i; // Assign the last index\r\n                        continue; // Skip next iteration\r\n                    }\r\n                    else if (txt.substring(i, i + between.length) === between) {\r\n                        isOut = true;\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                }\r\n                if (isOut) {\r\n                    result.content = txt.substring(index + between.length, result.lastIndex + 1);\r\n                    result.lastIndex = result.lastIndex + between.length;\r\n                }\r\n                else {\r\n                    result.error = true;\r\n                    result.lastIndex = index + between.length;\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern rule to test a regex. Note: when you write your regex, think like you're at the start of the string for the test.\r\n     * @param {string} name Name of the rule.\r\n     * @param {RegExp} regex The regex\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static regex(name, regex) {\r\n        let regExpResult;\r\n        return {\r\n            name: name,\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => {\r\n                const result = regex.exec(txt.slice(i));\r\n                if (result && result.index == 0) {\r\n                    regExpResult = result;\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: name,\r\n                    content: txt.substring(index, index + regExpResult[0].length),\r\n                    lastIndex: index + regExpResult[0].length - 1\r\n                };\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n}\r\nexports.LazyRule = LazyRule;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js?");

/***/ }),

/***/ "./src/db/database.ts":
/*!****************************!*\
  !*** ./src/db/database.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Database = void 0;\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst ghosts_1 = __webpack_require__(/*! ./ghosts */ \"./src/db/ghosts.ts\");\r\nclass Database {\r\n    static getEvidences() {\r\n        var _a;\r\n        const allEvidences = document.querySelectorAll(\".evidenceInput\");\r\n        const result = {};\r\n        for (const evidence of allEvidences) {\r\n            result[(_a = evidence.getAttribute('id')) !== null && _a !== void 0 ? _a : ''] = client_1.LazyTristate.stateToString(evidence.value);\r\n        }\r\n        return result;\r\n    }\r\n    static getEvidencesByValue(value) {\r\n        const result = [];\r\n        const evidences = Database.getEvidences();\r\n        for (const evidence in evidences) {\r\n            const evidenceValue = evidences[evidence];\r\n            if (evidenceValue === value) {\r\n                result.push(evidence);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.Database = Database;\r\nDatabase.ghostDB = (0, ghosts_1.GHOST_DATABASE)();\r\nDatabase.evidenceIcons = {\r\n    'dots': 'dots-projector.webp',\r\n    'emf-5': 'emf-reader.webp',\r\n    'fingerprints': 'fingerprints.webp',\r\n    'freezing-temperatures': 'thermometer.webp',\r\n    'ghost-orb': 'ghost-orb.webp',\r\n    'ghost-writing': 'writing-book.webp',\r\n    'spirit-box': 'spirit-box.webp'\r\n};\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/db/database.ts?");

/***/ }),

/***/ "./src/db/ghosts.ts":
/*!**************************!*\
  !*** ./src/db/ghosts.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GHOST_DATABASE = void 0;\r\nconst GHOST_DATABASE = (ghostSpeed = '100', difficultyMultiplier = 1.0) => {\r\n    return {\r\n        'banshee': {\r\n            name: 'Banshee',\r\n            evidences: [\r\n                'dots',\r\n                'fingerprints',\r\n                'ghost-orb'\r\n            ],\r\n            strenght: \"Ne s'attaque qu' une victime  la fois.\",\r\n            weakness: \"Ses cris s'entendent au microphone parabolique.\",\r\n            description: \"La sirne qui chante, connue pour attirer ses victimes  travers ses chants. Elle est connue pour isoler sa proie avant de mettre le coup fatal.\",\r\n            ability: \"<p>Elle choisie une cible au dbut du jeu et ne changera de cible que si cette dernire meurt (ou quitte la partie).</p>\",\r\n            behaviour: `\r\n                <p>Elle a 33% de chance de faire un son paranormal unique lorsque le <strong class=\"italic\">microphone parabolique</strong> est utilis.</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/banshee-scream.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>Lorsqu'elle dcide d'rer, si la cible est dans la zone d'investigation, il y a 66% de chance qu'elle re dans la direction de sa cible, s'arrtant sur sa cible si possible.</p>\r\n                <p>Elle prfre causer des vnements o elle chante. Si elle fait un vnement fantmatique o elle chante, que l'vnement soit dirig vers sa cible et que sa cible la fait disparatre prmaturment en la touchant, alors il perdra 15% de sant mentale au lieu de 10%.</p>\r\n            `,\r\n            hunt: `\r\n                <p>La chasse est base sur la sant mentale de la cible de la Banshee, ainsi une chasse sera dmarre si sa cible est en dessous de 50% de sant mentale. a signifie qu'une chasse peut dbuter entre 87,5% et 12,5% de sant mentale moyenne.</p>\r\n                <p>Tous les joueurs, autres que sa cible, seront ignors durant une chasse. Si une chasse dmarre sans sa cible prsente dans la zone d'investigation, elle chassera comme les autres fantmes.</p>\r\n                <p>L'objectif <strong class=\"italic\">\"repousser le fantme lorsqu'il chasse quelqu'un\"</strong> n'est pas possible avec de <strong class=\"italic\">l'encent</strong> ( moins qu'elle ne chasse sa cible lorsque a se produit).</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'demon': {\r\n            name: 'Dmon',\r\n            evidences: [\r\n                'fingerprints',\r\n                'freezing-temperatures',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Ils chassent plus souvent que les autres entits.\",\r\n            weakness: \"L'effet du crucifix est accrus contre eux jusqu' 5 mtres.\",\r\n            description: \"Un dmon est l'une des pires entits que l'on puisse rencontrer. Il est connu pour attaquer sans raison.\",\r\n            ability: \"<p>Il peut dcider de dmarrer une chasse quand il le dsire.</p>\",\r\n            behaviour: \"<p>La porte du <strong class=\\\"italic\\\">crucifix</strong> est de 5 mtres pour lui (au lieu de 3 mtres pour les autres).</p>\",\r\n            hunt: `\r\n                <p>Il peut dmarrer des chasses ds que la sant moyenne de l'quipe est en dessous de 70%.</p>\r\n                <p>Le Dmon peut dmarrer une chasse toutes les 20 secondes (contrairement aux autres entits peuvent dmarrer une chasse toutes les 25 secondes).</p>\r\n                <p>Si l'encent est employ sur le dmon, son temps avant de pouvoir relancer une chasse est de 60 secondes au lieu de 90 secondes.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 100\r\n        },\r\n        'deogen': {\r\n            name: 'Deogen',\r\n            evidences: [\r\n                'dots',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strongEvidence: 'spirit-box',\r\n            strenght: \"Ils sentent constamment les vivants durant une chasse et avancent rapidement vers leurs positions.\",\r\n            weakness: \"Ils avancent lentement quand ils voient leurs victimes.\",\r\n            description: \"Parfois entours d'un brouillard sans fin, les Deogen ont chapp aux chasseurs de fantmes pendant des annes. Les rapports indiquent que ces entits trouvent mme leurs proies les mieux cachs, avant de les harceles jusqu' l'puisement.\",\r\n            ability: \"<p>Il connat la position de tous les joueurs.</p>\",\r\n            behaviour: `\r\n                <p>Il a 33% de chance par question de produire une rponse unique  la <strong class=\"italic\">Spirit Box </strong> lorsque le joueur est situ  1 mtre de ce dernier: une respiration lourde et constante durant 3  4 secondes.</p>\r\n                <audio controls id=\"deogen-breath\" class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/deogen-breath.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            hunt: `\r\n                <p>Il ne peut dmarrer une chasse que lorsque la sant mentale est en dessous de 40%.</p>\r\n                <p>Lors du dbut d'une chasse, il ira vers le joueur le plus proche de lui. Il peut occasionnellement choisir un joueur au hasard.</p>\r\n                <p>Durant une chasse, sa vitesse est dtermine par la distance qui le spare du joueur (2.5  6 mtres de distance). Au plus le joueur est loin, au plus il sera rapide.</p>\r\n                <p>Si il est  plus de 6 mtres, il avancera  3 m/s et si il est  moins de 2.5 mtres, alors il avancera  0.4 m/s. Sa vitesse entre les deux distances ralentie au plus il s'approche du joueur.</p>\r\n                <p>Il clignotte plus rapidement ; il est visible durant de plus long intervales et/ou il est invisible durant de plus court intervales.</p>\r\n                <p>Si on utilise l'encent contre lui ou qu'il ne chasse pas d'autres joueurs, sa vitesse restera constante, o sera de 1.6 m/s si sa vitesse actuelle est suprieur  3 m/s.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse proche d'une victime :</strong> ${difficultyMultiplier * 0.4} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/0.40.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Vitesse loin d'une victime :</strong> ${difficultyMultiplier * 3} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/3.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 40\r\n        },\r\n        'goryo': {\r\n            name: 'Goryo',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'fingerprints'\r\n            ],\r\n            strongEvidence: 'dots',\r\n            strenght: \"Ses interactions avec le projecteur D.O.T.S. ne sont visible qu'au travers une camra.\",\r\n            weakness: \"Tends  rester dans sa pice.\",\r\n            description: \"Lorsqu'un Goryo passe  travers un projecteur D.O.T.S., employer une camra est le seul moyen pour le voir.\",\r\n            ability: `<p>Rien  signaler.</p>`,\r\n            behaviour: `\r\n                <p>Il ne peut err que jusqu' 5 mtres de distance, au lieu des 10 mtres maximum pour les autres fantmes.</p>\r\n                <p>Il ne peut pas changer sa pice favorite.</p>\r\n                <p>Il ne ragit aux <strong class=\"italic\">D.O.T.S.</strong> que si aucun joueur n'est dans sa pice.</p>\r\n                <p>Aussi, sa silhouette au <strong class=\"italic\">Projecteur D.O.T.S.</strong> n'est visible qu'au travers la camra et n'est donc pas visible  l'oeil nu.</p>\r\n                <p>Dans quelques rares cas, il est possible de le voir avec les yeux en tant dans la mme pice: si il re dans une pice adjacente, il peut interagir avec le <strong class=\"italic\">Projecteur D.O.T.S.</strong>.</p>\r\n            `,\r\n            hunt: `<p>Rien  signaler.</p>`,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'hantu': {\r\n            name: 'Hantu',\r\n            evidences: [\r\n                'fingerprints',\r\n                'freezing-temperatures',\r\n                'ghost-orb'\r\n            ],\r\n            strongEvidence: 'freezing-temperatures',\r\n            strenght: \"Il avance plus rapidement dans les tempratures les plus basses.\",\r\n            weakness: \"Les tempratures les plus leves le font ralentir.\",\r\n            description: \"Le Hantu est une entite rare qui apprcie les climats les plus froids. Le froid tends  les rendres plus aggressif et puissant.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il ne peut pas allumer le fusible.</p>\r\n                <p>Il peut teindre le fusible deux fois plus souvent.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Sa vitesse dpends de la temprature autour de lui. Lorsque le fusible est branch, il sera en consquent plus lent parce que la maison sera chauffe.</p>\r\n                <p>Il n'acclre pas si on le garde en ligne de vue.</p>\r\n                <p>Lorsque le Hantu est visible lors d'une chasse, il met une respiration glace au niveau de sa tte et ce dans toutes les pices tant que le disjoncteur est teint (Les joueurs dcds ne peuvent pas voir ce souffle).</p>\r\n                <p>Il est conseill de ne pas le faire tourner trop longtemps autour de fourniture lorsque la pice est chaude puisque la simple prsence du Hantu suffit  faire baisser la temprature et donc lui augmente sa vitesse au fur et  mesure.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse dpendante de la <strong class=\"italic\">temprature</strong> :</strong></p>\r\n                <p> <strong>infrieur  3C :</strong> ${difficultyMultiplier * 2.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p> <strong>entre 3 - 6C :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p> <strong>entre 6 - 9C :</strong> ${difficultyMultiplier * 2.3} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.30.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p> <strong>entre 9 - 12C :</strong> ${difficultyMultiplier * 2.1} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.10.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p> <strong>entre 12 - 15C :</strong> ${difficultyMultiplier * 1.75} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.75.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p> <strong>suprieur  15C :</strong> ${difficultyMultiplier * 1.4} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.40.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'jinn': {\r\n            name: 'Djinn',\r\n            evidences: [\r\n                'emf-5',\r\n                'fingerprints',\r\n                'freezing-temperatures'\r\n            ],\r\n            strenght: \"Il avance  plus grande vitesse lorsque sa victime s'loigne.\",\r\n            weakness: \"Il ne peut pas utiliser son abilit si le courant est coup.\",\r\n            description: \"Un Djinn est une entite territorial qui attaque quand il est menac. Il est galement connu pour se dplacer  une vitesse signifiante.\",\r\n            ability: `\r\n                <p>Si le fusible est branch, il peut utiliser son abilit qui rduit de 25% la sant mentale de tous les joueurs prsent dans la mme pice ou aux environs de 3 mtres de lui et gnre au fusible un <strong class=\"italic\">EMF 2</strong> ou <strong class=\"italic\">EMF 5</strong> si la sant mentale d'un joueur a t draine.</p>\r\n                <p>En laissant un <strong class=\"italic\">EMF</strong> au niveau du fusible, si il capte quelque chose mais que le fusible ne s'est jamais allum ou teint, alors il est fort probable que ce soit le Jinn.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il ne peut pas teindre le fusible, seulement le faire sauter en allumant une lampe de trop.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si il voit un joueur, il avance jusqu'au joueur  une vitesse de 2,5 m/s instantanment jusqu' ce qu'il soit  environs 2 mtres du joueur avant d'avancer  sa vitesse de base.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s (instantan)</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'mare': {\r\n            name: 'Cauchemar',\r\n            evidences: [\r\n                'ghost-orb',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Attaque plus souvent dans le noir.\",\r\n            weakness: \"Allumer la lumire rduit les chances qu'il attaque.\",\r\n            description: \"Le Cauchemar est la source de tous les cauchemars, le rendant plus puissant dans la pnombre.\",\r\n            ability: \"<p>Rien  signaler.</p>\",\r\n            behaviour: `\r\n                <p>Si on allume une lampe prs de lui, il a une chance de l'teindre presque immdiatement. a s'applique galement aux tlvisions et ordinateurs.</p>\r\n                <p>Il n'allume jamais de lampe. Si il dcide d'err, il choisira plus souvent des pices qui ne sont pas claires.</p>\r\n                <p>Il fait plus souvent des vnements o il explose des ampoules.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si les lampes sont teintes, il peut dclancher une chasse  partir de 60% de sant mentale. Dans le cas contraire, ce sera  partir de 40%.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 60\r\n        },\r\n        'moroi': {\r\n            name: 'Moro',\r\n            evidences: [\r\n                'freezing-temperatures',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strongEvidence: 'spirit-box',\r\n            strenght: \"Il avance relativement plus vite lorsque les enquteurs ont peu de sant mentale. Ils peuvent galement faire perdre la sant mentale des enquteurs plus rapidement qu'usuellement durant une enqute.\",\r\n            weakness: \"L'encent les aveugles plus longtemps durant les chasses.\",\r\n            description: \"Le Moro est sorti de sa tombe pour absorber l'nergie des vivants. Ils sont connu pour placer des maldictions sur leurs victimes, curable uniquement par antidotes ou en partant au loin.\",\r\n            ability: `\r\n                <p>Si un joueur obtient une rponse  la <strong class=\"italic\">Spirit Box</strong> o entends un bruit au <strong class=\"italic\">microphone parabolique</strong>, il maudira ce joueur tant qu'il restera dans la zone d'investigation (la lumire n'a aucune importance). Il est possible d'tre maudit plusieurs fois mais pas d'accumuler la maldiction.</p>\r\n                <p>On peut briser la maldiction en prenant des <strong class=\"italic\">pillules</strong>.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Il devient plus rapide au plus la sant mentale est basse. Entre 1,5 m/s avec une sant mentale moyenne de 50% et 2,25 m/s  0%. Il y a une augmentation de sa vitesse de 0.075 m/s pour chaque 5% de sant mentale perdue.</p>\r\n                <p>Si on utilise <strong class=\"italic\">l'encent</strong>, la dure durant laquelle il ne peut pas voir est de 12 secondes (au lieu des 6 usuelles).</p>\r\n                <p>Il acclre lorsqu'il est vu par le joueur. A sa vitesse maximum, il est plus rapide qu'un Revenant.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> entre ${difficultyMultiplier * 1.5} et ${difficultyMultiplier * 2.25} m/s</p>\r\n                <p><strong>${difficultyMultiplier * 1.5} :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>${difficultyMultiplier * 2.25} :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.25.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.25} et ${difficultyMultiplier * 3.71} m/s</p>\r\n                <p><strong>${difficultyMultiplier * 3.71} :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/3.71.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'myling': {\r\n            name: 'Myling',\r\n            evidences: [\r\n                'emf-5',\r\n                'fingerprints',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Ses pas sont plus silencieux lorsqu'il chasse.\",\r\n            weakness: \"Produit des sons paranormaux plus frquement.\",\r\n            description: \"Le Myling est une entite trs vocale et active. Il y a des rumeurs comme quoi ils sont silencieux lorsqu'ils chassent leurs proies.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il met beaucoup plus de son paranormal que les autres entits au <strong class=\"italic\">microphone parabolique</strong>.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Le son de ses pas ne s'entends que s'il se situe  une distance d'environs 12 mtres.</p>\r\n                <p>La distance audible des pas d'un Myling lors d'une chasse est perceptible plus ou moins lorsqu'il commence  interfrer avec l'lectronique.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'obake': {\r\n            name: 'Obake',\r\n            evidences: [\r\n                'emf-5',\r\n                'fingerprints',\r\n                'ghost-orb'\r\n            ],\r\n            strongEvidence: 'fingerprints',\r\n            strenght: \"Ils peuvent laisser des empruntes qui disparaissent rapidement.\",\r\n            weakness: \"Il laisse parfois une emprunte  six doigts.\",\r\n            description: \"Les Obakes sont terrifiant au changement de corps, capable de prendre bien des formes. Ils ont t vu prendre une forme humanode pour attirer leurs proies.\",\r\n            ability: `\r\n                <p>Il peut occasionnellement utiliser son abiliter qui rduit le temps d'existence des <strong class=\"italic\">empruntes</strong> sur la map de moiti (il peut aussi l'utiliser plusieurs fois de suite, rduisant drastiquement le temps de vie des <strong class=\"italic\">empruntes</strong>).</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Lorsqu'il interagit avec une surface, il a 75% de chance de laisser une <strong class=\"italic\">emprunte</strong> (au lieu des 100% usuel).</p>\r\n                <p>Il y a 16,7% de chance qu'il cre une <strong class=\"italic\">emprunte</strong> unique:</p>\r\n                <p> Une trace de main  six doigts.</p>\r\n                <p> Deux empruntes de doigts sur un interrupteur au lieu d'une seule.</p>\r\n                <p> Cinq traces de doigts sur le clavier ou les portes de prison au lieu de quatre.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Il a 6.66% de chance  chaque fois qu'il clignotte de changer sa forme en une autre entit puis de reprendre sa forme originel. C'est garanti d'avoir lieu au moins une fois par chasse (les joueurs dcds ne peuvent pas le voir).</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'oni': {\r\n            name: 'Oni',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'freezing-temperatures'\r\n            ],\r\n            strenght: \"Augmentation des activits et des vnements fantmatiques.\",\r\n            weakness: \"L'augmentation des activits des Onis les rends plus aiss  trouver.\",\r\n            description: \"Les Onis aiment effrayer leurs victimes autant que possible avant d'attaquer. Ils sont souvent vu dans une forme physique, gardant le lieu de leur dcs.\",\r\n            ability: `\r\n                <p>Il draine le double de la sant mentale (20%) par rapport aux autres fantmes (10%) lorsqu'on le touche lors d'un vnement fantmatique.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il est trs actif et interagit plus souvent avec les objets, surtout si il y a des joueurs dans sa pice.</p>\r\n                <p>Il peut se manifester entirement durant un vnement.</p>\r\n                <p>Il est incapable de produire l'vnement de type \"ballon d'air\". Ainsi, on peut retirer l'Oni si l'on entends le son :</p>\r\n                <audio controls id=\"sound-air-breath\" class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/air-breath.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            hunt: `\r\n                <p>Il peut tre vu plus longtemps lorsqu'il chasse.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'onryo': {\r\n            name: 'Onryo',\r\n            evidences: [\r\n                'freezing-temperatures',\r\n                'ghost-orb',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Une flamme qui s'teint peu provoquer l'attaque d'un Onryo.\",\r\n            weakness: \"La prsence des flammes rduit l'abilit de l'Onryo  attaquer.\",\r\n            description: \"L'Onryo est souvent rfrer en tant qu'  Esprit vengeur . Ils volent les mes des de ses victimes mourrantes pour se venger. Cette entit est connue pour tre effraye du feu, et fera tout en son pouvoir pour s'en loigner.\",\r\n            ability: `\r\n                <p>Si une <strong class=\"italic\">bougie</strong>, un <strong class=\"italic\">briquet</strong> ou un feu de camp est teint par ce dernier, on considre qu'il teint une flamme.</p>\r\n                <p>L'Onryo possde un compteur de flamme teinte (qui ne vaut que pour celles qu'il teint lui-mme).</p>\r\n                <p>Il peut teindre deux flammes puis, lorsqu'il en teindra une troisime, le compteur se rinitialisera et il aura une probabilit de 50% de dmarrer une chasse.</p>\r\n                <p>En multijoueur, la probabilit qu'il dmarre une chasse lorsqu'il teint la troisime flamme est accue de 25% par joueur dcd.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il a une plus haute chance que les autres fantmes d'teindre une <strong class=\"italic\">bougie</strong>.</p>\r\n                <p>Si une flamme est proche de lui, elle agit tel un <strong class=\"italic\">crucifix</strong>, l'empchant de chasser  une distance de 4 mtres.</p>\r\n                <p>Plusieurs situations particulires peuvent avoir lieu en consquence de son comportement et son abilit :</p>\r\n                <p> Une <strong class=\"italic\">bougie</strong> et un <strong class=\"italic\">crucifix</strong> sont  porte de l'Oryo, et il teint la <strong class=\"italic\">bougie</strong>. Les 50% de chances russissent mais suite  la prsence du <strong class=\"italic\">crucifix</strong>, la chasse n'a pas lieu.</p>\r\n                <p> Deux <strong class=\"italic\">bougies</strong> sont  porte de l'Onryo et il en teint l'une d'entre elles. Les 50% de chances russissent mais comme il y a une autre <strong class=\"italic\">bougie</strong>, la chasse n'a pas lieu.</p>\r\n                <p> Une <strong class=\"italic\">bougie</strong> est  porte de l'Onryo et il tente de chasser naturellement. La <strong class=\"italic\">bougie</strong> s'teindra et la chasse n'aura pas lieu.</p>\r\n                <p> <strong class=\"italic\">Remarque:</strong> Il peut y avoir jusqu' 6 secondes de dlais avant le dbut de l'initialisation de la chasse.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Il peut dmarrer une chasse ds que la sant mentale est en dessous de 60%.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 60\r\n        },\r\n        'phantom': {\r\n            name: 'Fantme',\r\n            evidences: [\r\n                'dots',\r\n                'fingerprints',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Regarder un fantme fait perdre considrablement la sant mentale.\",\r\n            weakness: \"Prendre une photo d'un fantme le fait disparatre brivement.\",\r\n            description: \"Un fantme est une entite qui peut possder le vivant, instaurant la peur  quiconque auprs de lui. Ils sont communment invoqus depuis une Ouija.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Si il est prit en photo durant un vnement, il disparat temporairement pour le reste de l'vnement mais le son de son vnement continue. Les interfrences cessent et il ne sera pas visible sur la photo.</p>\r\n                <p>tre aux environs de 10 mtres d'un fantme en tant en ligne de vue de ce dernier rduit la sant mentale de ~0.5% par seconde.</p>\r\n                <p>Il peut choisir un joueur au hasard et marcher vers ce dernier crant un <strong class=\"italic\">EMF 2</strong>  la position o il a dbuter son rrance.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si il est prit en photo durant une chasse, il ne sera pas visible sur la photo.</p>\r\n                <p>Le fantme clignotte environs toutes les 1  ~ 2s compar aux autres qui ont 0.3 ~ 1s de dlais.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'poltergeist': {\r\n            name: 'Poltergeist',\r\n            evidences: [\r\n                'fingerprints',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Capable de lancer plusieurs objets en une fois.\",\r\n            weakness: \"Il deviennent impuissant sans rien autour d'eux.\",\r\n            description: \"L'une des entits les plus connues, le Poltergeist. Connu pour manipulater les objets autour de lui pour instaurer la peur en ses victimes.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il peut occasionnellement lancer de multiples objets d'un coup, crant un <strong class=\"italic\">EMF 3</strong>. Les objets sont lancs avec plus de force que tous les autres fantmes (une force de 2 ~ 6 par opposition aux autres fantmes ayant une force de 1 ~ 3).</p>\r\n                <p>La sant mentale est rduite de 2% pour chaque objet lanc.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Pendant une chasse, lance un objet toutes les 0,5 secondes si il y en a un  sa proximit contrairement aux autres entits qui n'ont que 50% de chance d'en lancer toutes les 0,5 secondes.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'raiju': {\r\n            name: 'Raiju',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'ghost-orb'\r\n            ],\r\n            strenght: \"Il avance rapidement prs des objets lectroniques.\",\r\n            weakness: \"Il brouille l'quipement lectronique de plus loin lorsqu'il chasse.\",\r\n            description: \"Un Raiju est un dmon qui se courrit du courant lectrique. Gnralement calme, ils peuvent commencer  s'agiter quand ils sont submergs de puissance.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Lors d'un vnement, il interagit avec l'lectronique dans un rayon de 15 mtres (au lieu de 10 mtres pour les autres entits).</p>\r\n            `,\r\n            hunt: `\r\n                <p>Lorsqu'un objet lectronique est  port, il peut dmarr une chasse ds 65% de sant mentale, sinon il ne pourra que ds 50%.</p>\r\n                <p>Suivant la taille de la map, si il est dans la porte d'une pice d'quipement lectronique, sa vitesse sera de 2,5 m/s:</p>\r\n                <p> 6 mtres sur une petite map.</p>\r\n                <p> 8 mtres sur une map moyenne.</p>\r\n                <p> 10 mtres sur une grande map.</p>\r\n                <p>Ces effets s'appliquent sur l'quipement au sol et tenu dans les mains.</p>\r\n                <p>Ne sont pas compts  l'acclration de la vitesse :</p>\r\n                <p> La camra frontale</p>\r\n                <p> Les camras et appareils photos jets au sol</p>\r\n                <p> Les <strong class=\"italic\">capteurs de mouvements</strong>, les <strong class=\"italic\">capteurs sonores</strong> et les projecteurs <strong class=\"italic\">D.O.T.S.</strong> jets au sol ou tenu en main.</p>\r\n                <p> Les objets dans l'inventaire (sauf la <strong class=\"italic\">lampe de poche</strong> et <strong class=\"italic\">lampe de poche puissante</strong> lorsqu'elles sont allumes)</p>\r\n                <p> Les quipements lectroniques qui ne proviennent pas du camion</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Prs d'quipement lectronique :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 65\r\n        },\r\n        'revenant': {\r\n            name: 'Revenant',\r\n            evidences: [\r\n                'freezing-temperatures',\r\n                'ghost-orb',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Il avance beaucoup plus vite lorsqu'il peroit ses cibles lorsqu'il chasse.\",\r\n            weakness: \"Il est trs lent lorsqu'il ne chasse pas une cible.\",\r\n            description: \"Le Revenant est une entite violente qui attaque sans discrimination. Leur vitesse peut tre dcevante, vu qu'ils sont lent pendant la dormance ; cependant, aussitt qu'ils chassent ils peuvent avancer incroyablement vite.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Sa vitesse lors d'une chasse varie fortement des autres entits. Il est trs lent si il n'a pas de cible en vue (1 m/s), sinon il est extrmement rapide (3 m/s).</p>\r\n                <p>Il acclre lorsqu'il voit un joueur et continuera d'acclrer jusqu' atteindre la dernire position connue du joueur. Ce sera seulement aprs qu'il ralentira durant 2.7 secondes.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 3} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/3.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'shade': {\r\n            name: 'Ombre',\r\n            evidences: [\r\n                'emf-5',\r\n                'freezing-temperatures',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Sa timidit la rends difficile  localiser et  obtenir une vidence.\",\r\n            weakness: \"Elle a moins de chance d'attaquer si plusieurs personnes sont dans les alentours.\",\r\n            description: \"Une ombre est connue pour tre trs timide. Plusieurs vidences supposent que l'Ombre arrtera toute activit paranormal si il y a plusieurs personnes dans les environs.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Au plus la sant mentale est haute, au moins elle est active.</p>\r\n                <p>Elle possde 0% de chance de russir un vnement lorsque la sant mentale est  100%. La chance de succs d'un vnement crot de 2% par pourcentage de sant mentale perdue.</p>\r\n                <p>Ainsi, une ombre aura 100% de chance de pouvoir effectuer un vnement lorsque la sant mentale sera de 50% et moins.</p>\r\n                <p>L'ombre prfre se hisser dans les oreilles du joueur, mais peut se manifester en tant qu'ombre (rare).</p>\r\n                <p>Il est incapable de donner une interaction <strong class=\"italic\">EMF 3</strong> lorsqu'il y a un ou plusieurs joueurs dans la mme pice que lui, mais peut le faire dans une pice adjacente.</p>\r\n                <p>Si elle est invoqu, elle a une chance d'apparatre en tant qu'ombre noir transparente plutt que dans sa forme complte tant qu'elle est pige dans le cercle d'invocation.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Elle ne dmarre pas de chasse tant que la sant mentale n'est pas en dessous de 35%.</p>\r\n                <p>Elle est incapable de chasser lorsqu'il y a un ou plusieurs joueurs dans la mme pice que lui.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 35\r\n        },\r\n        'spirit': {\r\n            name: 'Esprit',\r\n            evidences: [\r\n                'emf-5',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Aucune.\",\r\n            weakness: \"L'encent est trs efficace, empchant une chasse durant plus longtemps.\",\r\n            description: \"L'Esprit est une entite trs commune. Ils sont trs puissants, mais passif, et n'attaque que quand ils doivent le faire. Ils dfendent cote que cote le lieu de leur dcs, tuant quiconque est surpris  dpasser son temps d'accueil.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Si un encent est utilis prs de lui, il ne pourra pas dmarrer une chasse pendant 180 secondes (au lieu de 90 secondes pour les autres entits).</p>\r\n            `,\r\n            hunt: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'thaye': {\r\n            name: 'Thay',\r\n            evidences: [\r\n                'dots',\r\n                'ghost-orb',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Entrer dans leur champ d'action les rends plus actifs, dfensif et agile.\",\r\n            weakness: \"Ils deviennent plus lent et moins actif au fil du temps.\",\r\n            description: \"Le Thay est connu pour vieillir rapidement au fil du temps, mme dans l'au-del. De ce que nous avons appris, ils semblent se dtriorer plus rapidement  la prsence des vivants.\",\r\n            ability: `\r\n                <p>Toutes les 1  2 minutes, le Thay va tenter de vieillir. Si un joueur se trouve dans la mme pice que lui, alors il vieilli. Si aucun joueur n'est prsent, alors il recommencera le processus 30 secondes plus tard.</p>\r\n                <p>Il peut vieillir jusqu' 10 fois</p>\r\n                <p>Chaque fois qu'il prends de l'ge :</p>\r\n                <p> La sant mentale minimum pour qu'il dmarre une chasse diminue de 6%.</p>\r\n                <p> Sa vitesse se rduit de 0.175 m/s lors de la chasse.</p>\r\n                <p> 15% de rduction sur les chances d'obtenir un vnement / une interaction.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Au dbut de la partie, le Thay a 200% de faire une interaction ou un vnement paranormal.</p>\r\n                <p>Au fil du temps, l'ge donn par la planche Ouija augmentera.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Suite  son abilit, le Thay n'acclre pas lors d'une chasse.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse quand il est jeune :</strong> ${difficultyMultiplier * 2.75} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.75.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Vitesse quand il est vieux :</strong> ${difficultyMultiplier} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 75\r\n        },\r\n        'mimic': {\r\n            name: 'Le Mimic',\r\n            evidences: [\r\n                'fingerprints',\r\n                'freezing-temperatures',\r\n                'ghost-orb',\r\n                'spirit-box'\r\n            ],\r\n            strongEvidence: 'ghost-orb',\r\n            strenght: \"Peut copier les abilits et les trats des autres entites.\",\r\n            weakness: \"Prsente les orbes fantmatique en vidence secondaire.\",\r\n            description: \"Le Mimic est un fantme insaisissable, mystrieux et imitateur qui reproduit les traits et les comportements d'autres personnes, y compris d'autres types de fantmes.\",\r\n            ability: `\r\n                <p>Il peut imiter tous les types d'entits et ainsi hrit de toutes les capacits et abilits de l'entit qu'il dcide de copier.</p>\r\n                <p>Il peut copier des caractristiques des vidences (exemple: les traces de pas invisible aux <strong class=\"italic\">lampes UV</strong> du Spectre) mais pas les vidences elles-mmes.</p>\r\n                <p>Il peut imiter le joueur ou le Mimic, mais dans ce cas il agira alors comme un fantme normal.</p>\r\n                <p>Lorsqu'il choisit d'imiter le Thay, il choisira un ge alatoire et au lieu de vieillir comme le Thay, il imitera une autre entit.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il donne pour vidence les orbes fantmatiques en plus de ses trois vidences de base et ce qu'importe la difficult.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Varie suivant l'entit imite.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Varie selon l'entit qu'il incarne.</strong></p>\r\n            `,\r\n            sanity: 100\r\n        },\r\n        'twins': {\r\n            name: 'Les Jumeaux',\r\n            evidences: [\r\n                'emf-5',\r\n                'freezing-temperatures',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Les deux jumeaux peuvent lancer une chasse, mais pas en mme temps.\",\r\n            weakness: \"Interagit souvent avec l'environnement en mme temps.\",\r\n            description: \"Ces entits ont t signals comme imitant les actions des autres. Ils alternent leurs attaques pour confondre leurs proies.\",\r\n            ability: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Les Jumeaux ne sont qu'une seule entit compose d'un corps principal et d'un leurre.</p>\r\n                <p>Le leurre ne fait pas marcher les <strong class=\"italic\">dtecteurs de mouvements</strong>, ne rduit pas la <strong class=\"italic\">temprature</strong> et ne rponds pas  la <strong class=\"italic\">Spirit Box</strong>. Le leure et l'entit principale ont 25% de chance de produire un <strong class=\"italic\">EMF 5</strong> au lieu de 2 ou 3.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si il dmarre une chasse, il y a une chance sur deux que ce soit le leurre qui chasse.</p>\r\n                <p>Le leurre est 10% plus rapide qu'un fantme usuel tandis que le corps principal est 10% plus lent.</p>\r\n                <p>Lorsqu'un <strong class=\"italic\">crucifix</strong> est utilis pour empcher une chasse, qu'importe le jumeau qui chasse, le <strong class=\"italic\">crucifix</strong> s'appliquera uniquement au corps principal.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} ( ${difficultyMultiplier * 0.2}) m/s</p>\r\n                <p><strong>Jumeau lent :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Jumeau rapide :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.90.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} ( ${difficultyMultiplier * 0.2}) m/s</p>\r\n                <p><strong>Jumeau lent :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.30.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Jumeau rapide :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'wraith': {\r\n            name: 'Spectre',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Ils ne laissent pas de traces de pas visible  la lumire UV aprs avoir march dans le sel.\",\r\n            weakness: \"Il devient plus actif si il marche dans du sel.\",\r\n            description: \"Le Spectre est l'une des entites les plus dangereuse que vous pourrez trouver. C'est aussi la seule entite connue qui a la capacit de voler et qui est parfois connu pour voyager  travers les murs.\",\r\n            ability: `\r\n                <p>Il a une chance de se tlporter  environs 3 mtres d'un joueur avec 75% chance de gnrer un <strong class=\"italic\">EMF 2</strong> et 25% chance de gnrer un <strong class=\"italic\">EMF 5</strong>.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il est incapable de marcher dans le sel et donc il ne laisse aucune trace de pas visible aux <strong class=\"italic\">lumires UV</strong>.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'yokai': {\r\n            name: 'Yokai',\r\n            evidences: [\r\n                'dots',\r\n                'ghost-orb',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Parler prs d'un Yokai le mettra en colre, ce qui augmentera ses chances d'attaquer.\",\r\n            weakness: \"Il ne peut entendre que des voix proches de lui pendant qu'il chasse.\",\r\n            description: \"Les Yokai sont des entites communes qui sont attires par les voix humaines. On les trouve gnralement dans les maisons familiales.\",\r\n            ability: \"<p>Rien  signaler.</p>\",\r\n            behaviour: \"<p>Si au moins un joueur parle ou met du bruit, l'activit du Yokai augmente.</p>\",\r\n            hunt: `\r\n                <p>Si au moins un joueur parle ou met du bruit, une chasse peut tre dmarre en dessous de 80% de sant mentale, sinon il dmarre une chasse  50% comme les autres entits.</p>\r\n                <p>Il ne peut qu'entendre les joueurs ou sentir les appareils lectroniques dans une porte de 2.5 mtres (sa ligne de vue n'est pas affecte).</p>\r\n                <p>Lorsque la bote  musique est utilise, le Yokai doit tre plus proche du joueur tenant la bote que tous les autres fantmes pour initier une chasse maudite.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 80\r\n        },\r\n        'yurei': {\r\n            name: 'Yurei',\r\n            evidences: [\r\n                'dots',\r\n                'freezing-temperatures',\r\n                'ghost-orb'\r\n            ],\r\n            strenght: \"Il affecte plus fortement la sant mentale.\",\r\n            weakness: \"Allumer de l'encent dans la pice du Yurei rduira la frquence de ses errances.\",\r\n            description: \"Un Yurei est une entite qui est revenue dans le monde physique, gnralement dans un but de vengeance ou de haine.\",\r\n            ability: `\r\n                <p>Il peut utiliser son abilit qui rduit de 15% la sant mentale de tous les joueurs situs dans une porte de 7.5 mtres.</p>\r\n                <p>Il ne peut utiliser son abilit que lorsque la pice dans laquelle il se situe possde au moins une porte.</p>\r\n                <p>Lorsqu'il emploie son abilite, une porte choisie alatoirement dans la pice du Yurei se fermera, produisant un <strong class=\"italic\">EMF 2</strong>.</p>\r\n                <p>Les casiers et plaquards ne sont pas affects par l'abilit du Yurei.</p>\r\n                <p>Lorsque la porte avant (la porte de sortie) se ferme entirement sans qu'il n'y aie eu un vnement fantmatique ou une chasse, alors c'est un Yurei.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Si on emploie de <strong class=\"italic\">l'encent</strong> sur lui, en plus des effets de base, il ne quittera pas sa pice durant 90s.</p>\r\n                <p>Il offre plus souvent des vnements de type \"ballon d'air\".</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/air-breath.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            hunt: `\r\n                <p>Rien  signaler.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        }\r\n    };\r\n};\r\nexports.GHOST_DATABASE = GHOST_DATABASE;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/db/ghosts.ts?");

/***/ }),

/***/ "./src/db/interactiveDatabase.ts":
/*!***************************************!*\
  !*** ./src/db/interactiveDatabase.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.interactiveDatabase = void 0;\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst portable_1 = __webpack_require__(/*! @lazy-toolbox/portable */ \"./node_modules/@lazy-toolbox/portable/dist/index.js\");\r\nconst database_1 = __webpack_require__(/*! ./database */ \"./src/db/database.ts\");\r\nconst initializeGhosts_1 = __webpack_require__(/*! ../initializeGhosts */ \"./src/initializeGhosts.ts\");\r\nexports.interactiveDatabase = {\r\n    \"behaviourVisibility\": (ghostName) => {\r\n        let visibility = true;\r\n        if (visibility) {\r\n            const bansheeTestC = document.querySelector('#farEventGhost');\r\n            let currentState = client_1.LazyTristate.stateToString(bansheeTestC.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"wraith\" || ghostName === \"banshee\" || ghostName === \"mimic\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const wraithTest = document.querySelector('#saltFootsteps');\r\n            let currentState = client_1.LazyTristate.stateToString(wraithTest.value);\r\n            if (currentState === \"false\") {\r\n                visibility = visibility && (ghostName === \"wraith\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"wraith\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mareTestA = document.querySelector('#turnOnLight');\r\n            let currentState = client_1.LazyTristate.stateToString(mareTestA.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"mare\";\r\n            }\r\n            if (visibility) {\r\n                const mareTestB = document.querySelector('#notMare');\r\n                currentState = client_1.LazyTristate.stateToString(mareTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && ghostName !== \"mare\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const mareTestC = document.querySelector('#mareLight');\r\n                currentState = client_1.LazyTristate.stateToString(mareTestC.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"mare\" || ghostName === \"mimic\");\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const hantuTest = document.querySelector('#turnOnBreaker');\r\n            let currentState = client_1.LazyTristate.stateToString(hantuTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"hantu\";\r\n            }\r\n            if (visibility) {\r\n                const hantuTestB = document.querySelector('#hantuTest');\r\n                currentState = client_1.LazyTristate.stateToString(hantuTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"hantu\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"hantu\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const hantuTestB = document.querySelector('#hantuSpeedTest');\r\n                currentState = client_1.LazyTristate.stateToString(hantuTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"hantu\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"hantu\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const longSeeTest = document.querySelector('#longSeeTest');\r\n            let currentState = client_1.LazyTristate.stateToString(longSeeTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"oni\" || ghostName === \"mimic\" || ghostName === \"deogen\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"oni\" && ghostName !== \"deogen\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const jinnTest = document.querySelector('#turnOffBreaker');\r\n            let currentState = client_1.LazyTristate.stateToString(jinnTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"jinn\";\r\n            }\r\n            if (visibility) {\r\n                const jinnTestB = document.querySelector('#jinnBreaker');\r\n                let currentState = client_1.LazyTristate.stateToString(jinnTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"jinn\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"jinn\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const phantomTest = document.querySelector('#phantomTest');\r\n            let currentState = client_1.LazyTristate.stateToString(phantomTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"phantom\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"phantom\";\r\n            }\r\n            if (visibility) {\r\n                const phantomTestB = document.querySelector('#phantomPic');\r\n                let currentState = client_1.LazyTristate.stateToString(phantomTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"phantom\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"phantom\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const phantomTestB = document.querySelector('#phantomPicHunt');\r\n                let currentState = client_1.LazyTristate.stateToString(phantomTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"phantom\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"phantom\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const oniTestB = document.querySelector('#notOni');\r\n            let currentState = client_1.LazyTristate.stateToString(oniTestB.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"oni\";\r\n            }\r\n            if (visibility) {\r\n                const oniTestC = document.querySelector('#oniSanityTest');\r\n                let currentState = client_1.LazyTristate.stateToString(oniTestC.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"oni\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"oni\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const goryoTest = document.querySelector('#goryoTest');\r\n            let currentState = client_1.LazyTristate.stateToString(goryoTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"goryo\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"goryo\";\r\n            }\r\n            if (visibility) {\r\n                const goryoTestB = document.querySelector('#goryoRoaming');\r\n                let currentState = client_1.LazyTristate.stateToString(goryoTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"goryo\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"goryo\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const goryoTestB = document.querySelector('#goryoFavourite');\r\n                let currentState = client_1.LazyTristate.stateToString(goryoTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"goryo\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"goryo\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let countTests = 0;\r\n            const bansheeTest = document.querySelector('#bansheeScream');\r\n            let currentState = client_1.LazyTristate.stateToString(bansheeTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                countTests++;\r\n            }\r\n            if (visibility) {\r\n                const bansheeTestB = document.querySelector('#bansheeHuntTest');\r\n                currentState = client_1.LazyTristate.stateToString(bansheeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    countTests++;\r\n                    visibility = visibility && (ghostName !== \"banshee\");\r\n                }\r\n                if (visibility) {\r\n                    const bansheeTestC = document.querySelector('#farEventGhost');\r\n                    currentState = client_1.LazyTristate.stateToString(bansheeTestC.value);\r\n                    if (currentState === \"true\") {\r\n                        visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\" || ghostName === \"wraith\");\r\n                    }\r\n                    else if (currentState === \"false\") {\r\n                        countTests++;\r\n                    }\r\n                }\r\n            }\r\n            if (countTests == 3) {\r\n                visibility = visibility && (ghostName !== \"banshee\");\r\n            }\r\n            if (visibility) {\r\n                const bansheeTestC = document.querySelector('#bansheeSanityTest');\r\n                currentState = client_1.LazyTristate.stateToString(bansheeTestC.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"banshee\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const deogenTest = document.querySelector('#deogenBreath');\r\n            let currentState = client_1.LazyTristate.stateToString(deogenTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"deogen\" || ghostName === \"mimic\");\r\n            }\r\n            if (visibility) {\r\n                const deogenTestB = document.querySelector('#deogenHiding');\r\n                let currentState = client_1.LazyTristate.stateToString(deogenTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"deogen\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"deogen\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const yureiTest = document.querySelector('#yureiDoor');\r\n            let currentState = client_1.LazyTristate.stateToString(yureiTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"yurei\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"yurei\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let testCount = 0;\r\n            const obakeTestA = document.querySelector('#obakeFringer');\r\n            let currentState = client_1.LazyTristate.stateToString(obakeTestA.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"obake\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                testCount++;\r\n            }\r\n            if (visibility) {\r\n                const obakeTestB = document.querySelector('#obakeShapeshift');\r\n                currentState = client_1.LazyTristate.stateToString(obakeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"obake\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    testCount++;\r\n                }\r\n            }\r\n            if (testCount == 2) {\r\n                visibility = visibility && (ghostName !== \"obake\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const demonTest = document.querySelector('#demonTest');\r\n            let currentState = client_1.LazyTristate.stateToString(demonTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"demon\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"demon\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const spiritTest = document.querySelector('#spiritTest');\r\n            let currentState = client_1.LazyTristate.stateToString(spiritTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"spirit\";\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && (ghostName === \"spirit\" || ghostName === \"mimic\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let testCount = 0;\r\n            const shadeTestA = document.querySelector('#shadeTestA');\r\n            let currentState = client_1.LazyTristate.stateToString(shadeTestA.value);\r\n            if (currentState === \"true\") {\r\n                testCount++;\r\n            }\r\n            const shadeTestB = document.querySelector('#shadeTestB');\r\n            currentState = client_1.LazyTristate.stateToString(shadeTestB.value);\r\n            if (currentState === \"true\") {\r\n                testCount++;\r\n            }\r\n            if (testCount == 2) {\r\n                visibility = visibility && (ghostName === \"shade\" || ghostName === \"mimic\");\r\n            }\r\n            if (visibility) {\r\n                const shadeTestB = document.querySelector('#shadeTestC');\r\n                currentState = client_1.LazyTristate.stateToString(shadeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"shade\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"shade\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const shadeTestB = document.querySelector('#shadeEMFTest');\r\n                currentState = client_1.LazyTristate.stateToString(shadeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"shade\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"shade\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mylingTest = document.querySelector('#mylingTest');\r\n            let currentState = client_1.LazyTristate.stateToString(mylingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"myling\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"myling\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mylingTest = document.querySelector('#raijuGhostEvent');\r\n            let currentState = client_1.LazyTristate.stateToString(mylingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"raiju\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"raiju\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mylingTest = document.querySelector('#onryoTest');\r\n            let currentState = client_1.LazyTristate.stateToString(mylingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"onryo\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"onryo\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const moroiTest = document.querySelector('#moroiTest');\r\n            let currentState = client_1.LazyTristate.stateToString(moroiTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"moroi\";\r\n            }\r\n            if (visibility) {\r\n                const moroiTestB = document.querySelector('#moroiHuntTest');\r\n                let currentState = client_1.LazyTristate.stateToString(moroiTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"moroi\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const moroiTestB = document.querySelector('#moroiSmudged');\r\n                let currentState = client_1.LazyTristate.stateToString(moroiTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"moroi\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#revTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"revenant\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"revenant\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#twinsSpeedTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"twins\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"twins\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#yureiActivityTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"yurei\" || ghostName === \"mimic\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#yokaiTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"yokai\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"yokai\";\r\n            }\r\n            if (visibility) {\r\n                const revTest = document.querySelector('#yokaiActivityTest');\r\n                let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"yokai\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"yokai\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const sprintTest = document.querySelector('#sprintTest');\r\n            let currentState = client_1.LazyTristate.stateToString(sprintTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"revenant\" || ghostName === \"mimic\" || ghostName === \"jinn\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"revenant\" || ghostName === \"jinn\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const thayeTest = document.querySelector('#thayeTest');\r\n            let currentState = client_1.LazyTristate.stateToString(thayeTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"thaye\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"thaye\";\r\n            }\r\n            if (visibility) {\r\n                const thayeTestB = document.querySelector('#thayeAge');\r\n                let currentState = client_1.LazyTristate.stateToString(thayeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"thaye\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"thaye\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const thayeTestB = document.querySelector('#thayeAgeTesting');\r\n                let currentState = client_1.LazyTristate.stateToString(thayeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"thaye\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"thaye\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let nbrTest = 0;\r\n            const polterTestA = document.querySelector('#polterTestA');\r\n            let currentState = client_1.LazyTristate.stateToString(polterTestA.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"poltergeist\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                nbrTest++;\r\n            }\r\n            if (visibility) {\r\n                const polterTestB = document.querySelector('#polterTestB');\r\n                currentState = client_1.LazyTristate.stateToString(polterTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"poltergeist\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    nbrTest++;\r\n                }\r\n                if (visibility) {\r\n                    const polterTestC = document.querySelector('#polterTestC');\r\n                    currentState = client_1.LazyTristate.stateToString(polterTestC.value);\r\n                    if (currentState === \"true\") {\r\n                        visibility = visibility && (ghostName === \"poltergeist\" || ghostName === \"mimic\");\r\n                    }\r\n                    else if (currentState === \"false\") {\r\n                        nbrTest++;\r\n                    }\r\n                }\r\n            }\r\n            if (nbrTest === 3) {\r\n                visibility = visibility && (ghostName !== \"poltergeist\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const huntSpeedHidingTest = document.querySelector('#huntSpeedHidingTest');\r\n            let currentState = client_1.LazyTristate.stateToString(huntSpeedHidingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\" || ghostName === \"raiju\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"moroi\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\" || ghostName === \"raiju\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const huntSpeedHidingTest = document.querySelector('#huntSpeedSkipRaijuTest');\r\n            let currentState = client_1.LazyTristate.stateToString(huntSpeedHidingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"moroi\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const variableHuntSpeedTest = document.querySelector('#variableHuntSpeedTest');\r\n            let currentState = client_1.LazyTristate.stateToString(variableHuntSpeedTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"thaye\" || ghostName === \"hantu\" || ghostName === \"twins\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"moroi\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"twins\");\r\n            }\r\n        }\r\n        return visibility;\r\n    },\r\n    \"triggerGhostSpeedRender\": (event) => {\r\n        (0, initializeGhosts_1.initializeGhosts)(event.target.value);\r\n        exports.interactiveDatabase.triggerGhostRendering();\r\n    },\r\n    \"triggerEvidence\": (event) => {\r\n        exports.interactiveDatabase.triggerGhostRendering();\r\n    },\r\n    \"resetEvidences\": () => {\r\n        const evidences = database_1.Database.getEvidences();\r\n        for (const label in evidences) {\r\n            const evid = document.querySelector(`#${label}`);\r\n            evid.value = client_1.LazyTristate.NEUTRAL;\r\n            evid.innerText = client_1.LazyTristate.NEUTRAL;\r\n        }\r\n        const subEvidences = [...document.querySelectorAll('.subevidenceInput')];\r\n        for (const subEvidence of subEvidences) {\r\n            subEvidence.value = client_1.LazyTristate.NEUTRAL;\r\n            subEvidence.innerText = client_1.LazyTristate.NEUTRAL;\r\n        }\r\n        const allGhosts = [...document.querySelectorAll('.ghostsContainer > .ghostContainer')];\r\n        for (const ghost of allGhosts) {\r\n            ghost.style.display = \"block\";\r\n        }\r\n        const resultNumber = document.querySelector('.resultNumber');\r\n        resultNumber.innerText = `${allGhosts.length} rsultat${allGhosts.length > 1 ? 's' : ''}`;\r\n    },\r\n    \"triggerGhostRendering\": () => {\r\n        const obtainedEvidences = database_1.Database.getEvidencesByValue('true');\r\n        const hiddenEvidences = database_1.Database.getEvidencesByValue('false');\r\n        const allGhosts = [...document.querySelectorAll('.ghostsContainer > .ghostContainer')];\r\n        const evidenceCount = Number(document.getElementById('evidencesCount').value);\r\n        switch (evidenceCount) {\r\n            case 3:\r\n                exports.interactiveDatabase.allEvidences(obtainedEvidences, hiddenEvidences, allGhosts);\r\n                break;\r\n            default:\r\n                exports.interactiveDatabase.fiewEvidences(obtainedEvidences, hiddenEvidences, allGhosts, evidenceCount);\r\n                break;\r\n        }\r\n    },\r\n    \"allEvidences\": (gotEvidences, notEvidences, ghosts) => {\r\n        var _a;\r\n        let ghostResults = ghosts.length;\r\n        for (const ghostHTMLElement of ghosts) {\r\n            ghostHTMLElement.style.display = \"block\";\r\n            const ghostName = (_a = ghostHTMLElement.getAttribute('id')) !== null && _a !== void 0 ? _a : \"\";\r\n            const currentGhost = database_1.Database.ghostDB[ghostName];\r\n            const hasEvidences = exports.interactiveDatabase.hasEvidences(currentGhost.evidences, gotEvidences);\r\n            if (!hasEvidences) {\r\n                ghostHTMLElement.style.display = \"none\";\r\n                ghostResults--;\r\n                continue;\r\n            }\r\n            const rejectedEvidences = exports.interactiveDatabase.hasHiddenEvidences(currentGhost.evidences, notEvidences);\r\n            if (rejectedEvidences) {\r\n                ghostHTMLElement.style.display = \"none\";\r\n                ghostResults--;\r\n                continue;\r\n            }\r\n            if (!exports.interactiveDatabase.behaviourVisibility(ghostName)) {\r\n                ghostHTMLElement.style.display = \"none\";\r\n                ghostResults--;\r\n                continue;\r\n            }\r\n        }\r\n        const resultNumber = document.querySelector('.resultNumber');\r\n        resultNumber.innerText = `${ghostResults} rsultat${ghostResults > 1 ? 's' : ''}`;\r\n    },\r\n    \"fiewEvidences\": (obtainedEvidences, hiddenEvidences, ghosts, totalEvidences = 2) => {\r\n        var _a;\r\n        let ghostResults = ghosts.length;\r\n        for (const ghostHTMLElement of ghosts) {\r\n            ghostHTMLElement.style.display = \"block\";\r\n            const ghostName = (_a = ghostHTMLElement.getAttribute('id')) !== null && _a !== void 0 ? _a : \"\";\r\n            const currentGhost = database_1.Database.ghostDB[ghostName];\r\n            let actualGhost = currentGhost;\r\n            let visibility = true;\r\n            if (totalEvidences > 0) {\r\n                if (actualGhost.strongEvidence) {\r\n                    if (!obtainedEvidences.includes(actualGhost.strongEvidence) && hiddenEvidences.includes(actualGhost.strongEvidence)) {\r\n                        visibility = false;\r\n                    }\r\n                }\r\n                if (visibility) {\r\n                    visibility = exports.interactiveDatabase.behaviourVisibility(ghostName);\r\n                }\r\n                if (visibility) {\r\n                    for (let evidence of obtainedEvidences) {\r\n                        visibility = visibility && actualGhost.evidences.includes(evidence);\r\n                    }\r\n                }\r\n                if (visibility) {\r\n                    if (obtainedEvidences.length > totalEvidences) {\r\n                        if (ghostName !== 'mimic') {\r\n                            visibility = false;\r\n                        }\r\n                        else {\r\n                            let isMimic = true;\r\n                            for (const evd of obtainedEvidences) {\r\n                                if (!actualGhost.evidences.includes(evd)) {\r\n                                    isMimic = false;\r\n                                }\r\n                            }\r\n                            if (!isMimic) {\r\n                                visibility = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (totalEvidences == 2) {\r\n                            if (visibility && hiddenEvidences.length > 1 && ghostName !== 'mimic') {\r\n                                let combineHidden = portable_1.LazyMath.combinationArrayNRNO(hiddenEvidences, 2);\r\n                                for (let childCombine of combineHidden) {\r\n                                    let nbr = 0;\r\n                                    for (let child of childCombine) {\r\n                                        if (actualGhost.evidences.includes(child)) {\r\n                                            nbr++;\r\n                                        }\r\n                                    }\r\n                                    if (nbr == 2) {\r\n                                        visibility = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (totalEvidences == 1) {\r\n                            if (visibility && hiddenEvidences.length > 2 && ghostName !== 'mimic') {\r\n                                let combineHidden = portable_1.LazyMath.combinationArrayNRNO(hiddenEvidences, 3);\r\n                                for (let childCombine of combineHidden) {\r\n                                    let nbr = 0;\r\n                                    for (let child of childCombine) {\r\n                                        if (actualGhost.evidences.includes(child)) {\r\n                                            nbr++;\r\n                                        }\r\n                                    }\r\n                                    if (nbr == 3) {\r\n                                        visibility = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!visibility) {\r\n                    ghostHTMLElement.style.display = \"none\";\r\n                    ghostResults--;\r\n                }\r\n            }\r\n            else {\r\n                if (obtainedEvidences.includes('ghost-orb')) {\r\n                    if (ghostName !== 'mimic') {\r\n                        ghostHTMLElement.style.display = \"none\";\r\n                        ghostResults--;\r\n                    }\r\n                }\r\n                else {\r\n                    if (ghostName === 'mimic') {\r\n                        ghostHTMLElement.style.display = \"none\";\r\n                        ghostResults--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const resultNumber = document.querySelector('.resultNumber');\r\n        resultNumber.innerText = `${ghostResults} rsultat${ghostResults > 1 ? 's' : ''}`;\r\n    },\r\n    \"hasEvidences\": (ghostEvidences, currentEvidences) => {\r\n        for (const evidence of currentEvidences) {\r\n            if (!ghostEvidences.includes(evidence)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    \"hasHiddenEvidences\": (ghostEvidences, currentEvidences) => {\r\n        for (const evidence of currentEvidences) {\r\n            if (ghostEvidences.includes(evidence)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/db/interactiveDatabase.ts?");

/***/ }),

/***/ "./src/initializeGhosts.ts":
/*!*********************************!*\
  !*** ./src/initializeGhosts.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.initializeGhosts = void 0;\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst ghostRenderer_1 = __webpack_require__(/*! ./renderer/ghostRenderer */ \"./src/renderer/ghostRenderer.ts\");\r\nconst initializeGhosts = (rndr = '100') => {\r\n    const allRenderedGhosts = ghostRenderer_1.GhostRenderer.render(rndr);\r\n    allRenderedGhosts.sort(function (a, b) {\r\n        var _a, _b;\r\n        const idA = (_a = a.getAttribute('name')) !== null && _a !== void 0 ? _a : '';\r\n        const idB = (_b = b.getAttribute('name')) !== null && _b !== void 0 ? _b : '';\r\n        return idA.localeCompare(idB);\r\n    });\r\n    const ghostContainer = document.querySelector('.ghostsContainer');\r\n    ghostContainer.innerHTML = \"\";\r\n    for (let renderedGhost of allRenderedGhosts) {\r\n        ghostContainer.appendChild(renderedGhost);\r\n    }\r\n    client_1.LazyAnimate.loadDefault();\r\n};\r\nexports.initializeGhosts = initializeGhosts;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/initializeGhosts.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __webpack_unused_export__;\n\r\n__webpack_unused_export__ = ({ value: true });\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst initializeGhosts_1 = __webpack_require__(/*! ./initializeGhosts */ \"./src/initializeGhosts.ts\");\r\nconst evidenceRenderer_1 = __webpack_require__(/*! ./renderer/evidenceRenderer */ \"./src/renderer/evidenceRenderer.ts\");\r\nconst initializeMenu = () => {\r\n    client_1.LazyInteractivity.loadDefault();\r\n    evidenceRenderer_1.EvidenceRenderer.optionBehaviour();\r\n    evidenceRenderer_1.EvidenceRenderer.optionDropdown();\r\n};\r\ninitializeMenu();\r\n(0, initializeGhosts_1.initializeGhosts)();\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/main.ts?");

/***/ }),

/***/ "./src/renderer/evidenceRenderer.ts":
/*!******************************************!*\
  !*** ./src/renderer/evidenceRenderer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EvidenceRenderer = void 0;\r\nconst interactiveDatabase_1 = __webpack_require__(/*! ../db/interactiveDatabase */ \"./src/db/interactiveDatabase.ts\");\r\nclass EvidenceRenderer {\r\n    static optionBehaviour() {\r\n        const evidences = document.getElementsByClassName('evidenceInput');\r\n        for (const evidence of evidences) {\r\n            evidence.addEventListener(\"change\", interactiveDatabase_1.interactiveDatabase.triggerEvidence);\r\n        }\r\n        const evidenceGivenCount = document.getElementById('evidencesCount');\r\n        evidenceGivenCount === null || evidenceGivenCount === void 0 ? void 0 : evidenceGivenCount.addEventListener(\"change\", (e) => {\r\n            const target = e.target;\r\n            const evidenceCount = Number(target.value);\r\n            if (evidenceCount == 0) {\r\n                const hideAll = document.getElementsByClassName('evidence');\r\n                for (const hide of hideAll) {\r\n                    const currentElement = hide;\r\n                    if (!currentElement.classList.contains(\"ghost-orb\")) {\r\n                        currentElement.style.display = \"none\";\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const showAll = document.getElementsByClassName('evidence');\r\n                for (const show of showAll) {\r\n                    const currentElement = show;\r\n                    currentElement.style.display = \"table-row\";\r\n                }\r\n            }\r\n            interactiveDatabase_1.interactiveDatabase.resetEvidences();\r\n        });\r\n        const ghostSpeed = document.getElementById('ghostSpeed');\r\n        ghostSpeed.addEventListener(\"change\", interactiveDatabase_1.interactiveDatabase.triggerGhostSpeedRender);\r\n        const subEvidences = document.getElementsByClassName('subevidenceInput');\r\n        for (const subEvidence of subEvidences) {\r\n            subEvidence.addEventListener(\"change\", interactiveDatabase_1.interactiveDatabase.triggerEvidence);\r\n        }\r\n        const btnReset = document.querySelector('.resetMenuBtn');\r\n        btnReset.addEventListener('click', interactiveDatabase_1.interactiveDatabase.resetEvidences);\r\n    }\r\n    static optionDropdown() {\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-interactions', '.interactions');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-interactionsEvidences', '.interactionsEvidences');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-ghostEvents', '.ghostEvents');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-curses', '.curses');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-curseObject', '.curseObject');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntWait', '.huntWait');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntVisual', '.huntVisual');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntInteract', '.huntInteract');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntBehaviour', '.huntBehaviour');\r\n    }\r\n    static dropdown(query, targetQuery) {\r\n        const interactionDropdown = document.querySelector(query);\r\n        interactionDropdown.addEventListener(\"click\", (e) => {\r\n            if (interactionDropdown.innerText === \"+\") {\r\n                const allInteractions = [...document.querySelectorAll(targetQuery)];\r\n                for (const interaction of allInteractions) {\r\n                    interaction.style.display = \"table-row\";\r\n                }\r\n            }\r\n            else {\r\n                const allInteractions = [...document.querySelectorAll(targetQuery)];\r\n                for (const interaction of allInteractions) {\r\n                    interaction.style.display = \"none\";\r\n                }\r\n            }\r\n            interactionDropdown.innerText = interactionDropdown.innerText === \"+\" ? \"-\" : \"+\";\r\n        });\r\n    }\r\n}\r\nexports.EvidenceRenderer = EvidenceRenderer;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/renderer/evidenceRenderer.ts?");

/***/ }),

/***/ "./src/renderer/ghostRenderer.ts":
/*!***************************************!*\
  !*** ./src/renderer/ghostRenderer.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GhostRenderer = void 0;\r\nconst ghosts_1 = __webpack_require__(/*! ../db/ghosts */ \"./src/db/ghosts.ts\");\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst database_1 = __webpack_require__(/*! ../db/database */ \"./src/db/database.ts\");\r\nclass GhostRenderer {\r\n    static render(speed = '100') {\r\n        const ghosts = (0, ghosts_1.GHOST_DATABASE)(speed, speed !== '100' ? 1.5 : 1);\r\n        const ghostsContainer = [];\r\n        for (const ghostID in ghosts) {\r\n            const currentGhost = ghosts[ghostID];\r\n            let evidencesIcons = '';\r\n            for (const evidence of currentGhost.evidences) {\r\n                evidencesIcons += `<img src=\"./assets/icons/${database_1.Database.evidenceIcons[evidence]}\" alt=\"${evidence}\" />`;\r\n            }\r\n            ghostsContainer.push(client_1.LazyDoc.newTag('details', {\r\n                attributes: {\r\n                    'animated': '',\r\n                    'shr_duration': '200',\r\n                    'shr_ease': 'linear',\r\n                    'exp_duration': '200',\r\n                    'exp_ease': 'linear',\r\n                    'name': currentGhost.name\r\n                },\r\n                id: ghostID,\r\n                class: ['ghostContainer'],\r\n                innerHTML: `\r\n                <summary class=\"ghostSummary\">\r\n                    <div>\r\n                        <h2>${currentGhost.name}</h2>\r\n                        <div>${evidencesIcons}</div>\r\n                        <p>${currentGhost.sanity}%</p>\r\n                    </div>\r\n                </summary>\r\n                <content class=\"ghostContent\">\r\n                    <p class=\"ghostDesc\"><span desc fullDesc> ${currentGhost.description} </span></p>\r\n                    <p><span desc strenght>Force :</span> <span>${currentGhost.strenght}</span></p>\r\n                    <p><span desc weakness>Faiblesse :</span> <span>${currentGhost.weakness}</span></p>\r\n                    <section>\r\n                        <hr><br>\r\n                        <h3>Abilit</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.ability}\r\n                        <h3>Comportement</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.behaviour}\r\n                        <h3>Chasse</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.hunt}\r\n                        <h3>Vitesse</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.speed}\r\n                    </section>\r\n                </content>\r\n                `\r\n            }));\r\n        }\r\n        return ghostsContainer;\r\n    }\r\n}\r\nexports.GhostRenderer = GhostRenderer;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/renderer/ghostRenderer.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;