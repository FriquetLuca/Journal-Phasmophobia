/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@lazy-toolbox/client/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyView = exports.LazyTheme = exports.LazyTristate = exports.LazyTabularTextArea = exports.LazySlideContent = exports.LazySchedule = exports.LazyInteractivity = exports.LazyHtNetwork = exports.LazyHashRouter = exports.LazyFile = exports.LazyDualstate = exports.LazyDoc = exports.LazyClient = exports.LazyCaret = exports.LazyAnimate = void 0;\r\nvar lazyAnimate_1 = __webpack_require__(/*! ./lazyAnimate */ \"./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js\");\r\nObject.defineProperty(exports, \"LazyAnimate\", ({ enumerable: true, get: function () { return lazyAnimate_1.LazyAnimate; } }));\r\nvar lazyCaret_1 = __webpack_require__(/*! ./lazyCaret */ \"./node_modules/@lazy-toolbox/client/dist/lazyCaret.js\");\r\nObject.defineProperty(exports, \"LazyCaret\", ({ enumerable: true, get: function () { return lazyCaret_1.LazyCaret; } }));\r\nvar lazyClient_1 = __webpack_require__(/*! ./lazyClient */ \"./node_modules/@lazy-toolbox/client/dist/lazyClient.js\");\r\nObject.defineProperty(exports, \"LazyClient\", ({ enumerable: true, get: function () { return lazyClient_1.LazyClient; } }));\r\nvar lazyDoc_1 = __webpack_require__(/*! ./lazyDoc */ \"./node_modules/@lazy-toolbox/client/dist/lazyDoc.js\");\r\nObject.defineProperty(exports, \"LazyDoc\", ({ enumerable: true, get: function () { return lazyDoc_1.LazyDoc; } }));\r\nvar lazyDualstate_1 = __webpack_require__(/*! ./lazyDualstate */ \"./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js\");\r\nObject.defineProperty(exports, \"LazyDualstate\", ({ enumerable: true, get: function () { return lazyDualstate_1.LazyDualstate; } }));\r\nvar lazyFile_1 = __webpack_require__(/*! ./lazyFile */ \"./node_modules/@lazy-toolbox/client/dist/lazyFile.js\");\r\nObject.defineProperty(exports, \"LazyFile\", ({ enumerable: true, get: function () { return lazyFile_1.LazyFile; } }));\r\nvar lazyHashRouter_1 = __webpack_require__(/*! ./lazyHashRouter */ \"./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js\");\r\nObject.defineProperty(exports, \"LazyHashRouter\", ({ enumerable: true, get: function () { return lazyHashRouter_1.LazyHashRouter; } }));\r\nvar lazyHtNetwork_1 = __webpack_require__(/*! ./lazyHtNetwork */ \"./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js\");\r\nObject.defineProperty(exports, \"LazyHtNetwork\", ({ enumerable: true, get: function () { return lazyHtNetwork_1.LazyHtNetwork; } }));\r\nvar lazyInteractivity_1 = __webpack_require__(/*! ./lazyInteractivity */ \"./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js\");\r\nObject.defineProperty(exports, \"LazyInteractivity\", ({ enumerable: true, get: function () { return lazyInteractivity_1.LazyInteractivity; } }));\r\nvar lazySchedule_1 = __webpack_require__(/*! ./lazySchedule */ \"./node_modules/@lazy-toolbox/client/dist/lazySchedule.js\");\r\nObject.defineProperty(exports, \"LazySchedule\", ({ enumerable: true, get: function () { return lazySchedule_1.LazySchedule; } }));\r\nvar lazySlideContent_1 = __webpack_require__(/*! ./lazySlideContent */ \"./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js\");\r\nObject.defineProperty(exports, \"LazySlideContent\", ({ enumerable: true, get: function () { return lazySlideContent_1.LazySlideContent; } }));\r\nvar lazyTabularTextArea_1 = __webpack_require__(/*! ./lazyTabularTextArea */ \"./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js\");\r\nObject.defineProperty(exports, \"LazyTabularTextArea\", ({ enumerable: true, get: function () { return lazyTabularTextArea_1.LazyTabularTextArea; } }));\r\nvar lazyTristate_1 = __webpack_require__(/*! ./lazyTristate */ \"./node_modules/@lazy-toolbox/client/dist/lazyTristate.js\");\r\nObject.defineProperty(exports, \"LazyTristate\", ({ enumerable: true, get: function () { return lazyTristate_1.LazyTristate; } }));\r\nvar lazyTheme_1 = __webpack_require__(/*! ./lazyTheme */ \"./node_modules/@lazy-toolbox/client/dist/lazyTheme.js\");\r\nObject.defineProperty(exports, \"LazyTheme\", ({ enumerable: true, get: function () { return lazyTheme_1.LazyTheme; } }));\r\nvar lazyView_1 = __webpack_require__(/*! ./lazyView */ \"./node_modules/@lazy-toolbox/client/dist/lazyView.js\");\r\nObject.defineProperty(exports, \"LazyView\", ({ enumerable: true, get: function () { return lazyView_1.LazyView; } }));\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/index.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyAnimate = void 0;\r\nconst lazySlideContent_1 = __webpack_require__(/*! ./lazySlideContent */ \"./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js\");\r\n/**\r\n * A way to inject some animation into elements.\r\n */\r\nclass LazyAnimate {\r\n    /**\r\n     * Add a sliding content to all HTML details elements that passed through the function.\r\n     * @param {HTMLDetailsElement[]} detailsElements HTML details elements that need a sliding content.\r\n     */\r\n    static details(...detailsElements) {\r\n        detailsElements.forEach((element) => {\r\n            new lazySlideContent_1.LazySlideContent(element);\r\n        });\r\n    }\r\n    /**\r\n     * Inject into the HTML new element behaviour.\r\n     */\r\n    static loadDefault() {\r\n        document.querySelectorAll('details[animated]').forEach((el) => {\r\n            new lazySlideContent_1.LazySlideContent(el);\r\n        });\r\n    }\r\n}\r\nexports.LazyAnimate = LazyAnimate;\r\n/**\r\n * The `prefers-reduced-motion: reduce` media query to check for animations.\r\n */\r\nLazyAnimate.MediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyCaret.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyCaret.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyCaret = void 0;\r\n/**\r\n * A lazy way to handle caret and tabulation on textarea.\r\n */\r\nclass LazyCaret {\r\n    /**\r\n     * Set the caret position of the textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @param {number} position The position to set the caret to.\r\n     */\r\n    static setCaretPosition(txtArea, position) {\r\n        txtArea.selectionStart = position;\r\n        txtArea.selectionEnd = position;\r\n        txtArea.focus();\r\n    }\r\n    ;\r\n    /**\r\n     * Get the caret position of the textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @returns {number} Return the caret position of the textarea.\r\n     */\r\n    static getCaretPosition(txtArea) {\r\n        return txtArea.selectionStart;\r\n    }\r\n    ;\r\n    /**\r\n     * Check if the textarea has the selection.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @returns {boolean} Return true if the textare has the selection.\r\n     */\r\n    static hasSelection(txtArea) {\r\n        if (txtArea.selectionStart == txtArea.selectionEnd) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    ;\r\n    /**\r\n     * Get the selected text in a textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @returns {string} The selected text.\r\n     */\r\n    static getSelectedText(txtArea) {\r\n        return txtArea.value.substring(txtArea.selectionStart, txtArea.selectionEnd);\r\n    }\r\n    ;\r\n    /**\r\n     * Set a selection on the textarea.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @param {number} start The start position of the selection.\r\n     * @param {number} end The end position of the selection.\r\n     */\r\n    static setSelection(txtArea, start, end) {\r\n        txtArea.selectionStart = start;\r\n        txtArea.selectionEnd = end;\r\n        txtArea.focus();\r\n    }\r\n    ;\r\n    /**\r\n     * Do a tabulation on a textarea where the caret is currently at.\r\n     * @param {HTMLTextAreaElement} txtArea The textarea.\r\n     * @param {boolean} antiTab If true, it will do an anti-tabulation, removing space instead of adding it.\r\n     * @param {number} tabLength The length of the tabulation.\r\n     */\r\n    static tabulation(txtArea, antiTab = false, tabLength = 4) {\r\n        let newCaretPosition;\r\n        const caretPos = LazyCaret.getCaretPosition(txtArea);\r\n        const carretContent = txtArea.value.substring(0, caretPos);\r\n        let move = 0;\r\n        if (antiTab) {\r\n            for (let i = carretContent.length - 1; i >= carretContent.length - tabLength && i >= 0; i--) {\r\n                if (carretContent[i] !== ' ') {\r\n                    if (carretContent[i] !== '\\n') {\r\n                        move--;\r\n                    }\r\n                    break;\r\n                }\r\n                move++;\r\n            }\r\n            if (move < 0) {\r\n                move = 0;\r\n            }\r\n            txtArea.value = txtArea.value.substring(0, caretPos - move) + txtArea.value.substring(caretPos, txtArea.value.length);\r\n            newCaretPosition = caretPos - move;\r\n        }\r\n        else {\r\n            let letterTillLine = 0;\r\n            for (let i = carretContent.length - 1; i >= 0; i--) {\r\n                if (carretContent[i] === '\\n') {\r\n                    break;\r\n                }\r\n                letterTillLine++;\r\n            }\r\n            move = tabLength - (letterTillLine % tabLength);\r\n            const generateSpace = (n) => {\r\n                let r = '';\r\n                while (n > 0) {\r\n                    r = `${r} `;\r\n                    n--;\r\n                }\r\n                return r;\r\n            };\r\n            txtArea.value = txtArea.value.substring(0, caretPos) + generateSpace(move) + txtArea.value.substring(caretPos, txtArea.value.length);\r\n            newCaretPosition = caretPos + move;\r\n        }\r\n        LazyCaret.setCaretPosition(txtArea, newCaretPosition);\r\n    }\r\n}\r\nexports.LazyCaret = LazyCaret;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyCaret.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyClient.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyClient = void 0;\r\nconst lazySchedule_1 = __webpack_require__(/*! ./lazySchedule */ \"./node_modules/@lazy-toolbox/client/dist/lazySchedule.js\");\r\n/**\r\n * A lazy socket client to setup a websocket communication.\r\n * @method send Send a packet with datas to the server.\r\n * @method sender Register a sender function to execute when the connection to the server is established.\r\n * @method senders Register an array of sender functions to execute when the connection to the server is established.\r\n * @method hook Add an event to a specific packet.\r\n * @method hooks Add events to specifics packets.\r\n * @method hookObject Add events to specifics packets represented in an object.\r\n * @method start Start listening to the server.\r\n * @method disconnect Disconnect this client.\r\n */\r\nclass LazyClient {\r\n    /**\r\n     * Setup a simple websocket connection.\r\n     * @param {string} host The host to connect to.\r\n     * @param {number} port The port used by the server.\r\n     */\r\n    constructor(host, port) {\r\n        this.timer = new lazySchedule_1.LazySchedule(() => {\r\n            this.disconnect();\r\n            this.connect();\r\n        }, this.reconnectAfterMs, -1);\r\n        this.fns = [];\r\n        this.fnr = {};\r\n        this.socketURL = `ws://${host}:${port}`;\r\n        this.ws = new WebSocket(this.socketURL);\r\n    }\r\n    /**\r\n     * Send a packet with datas to the server.\r\n     * @param {string} packet The name of the packet to send.\r\n     * @param {any} obj The object to send.\r\n     */\r\n    send(packet, obj) {\r\n        obj['_packet'] = packet;\r\n        this.ws.send(JSON.stringify(obj));\r\n    }\r\n    /**\r\n     *  Register a sender function to execute when the connection to the server is established.\r\n     * @param {{ (f:(packet: string, obj: any) => any): void }} f A function taking as argument a sender function that has two parameters: the packet name and the object to send.\r\n     */\r\n    sender(f) {\r\n        this.fns.push(f);\r\n    }\r\n    /**\r\n     * Register an array of sender functions to execute when the connection to the server is established.\r\n     * @param {{ (f:(packet: string, obj: any) => any): void }[]} fns An array of function taking as argument a sender function that has two parameters: the packet name and the object to send.\r\n     */\r\n    senders(...fns) {\r\n        this.fns.push(...fns);\r\n    }\r\n    /**\r\n     * Add an event to a specific packet.\r\n     * @param {string} packet The packet's name.\r\n     * @param {(obj: any, websocket: WebSocket) => void} fn The function to execute when the packet is triggered.\r\n     */\r\n    hook(packet, fn) {\r\n        if (this.fnr[packet]) { // Check if the packet is defined.\r\n            this.fnr[packet].push(fn);\r\n        }\r\n        else {\r\n            this.fnr[packet] = [fn];\r\n        }\r\n    }\r\n    /**\r\n     * Add events to specifics packets.\r\n     * @param {{packet: string, fn: (obj: any, websocket: WebSocket) => void}[]} hooking An array of object containing the packet's name and a function to execute when the packet is triggered.\r\n     */\r\n    hooks(...hooking) {\r\n        for (const hook of hooking) {\r\n            this.hook(hook.packet, hook.fn);\r\n        }\r\n    }\r\n    /**\r\n     * Add events to specifics packets represented in an object.\r\n     * @param {{[packet:string]: (obj: any, websocket: WebSocket) => void}} fns An object containing all the packet's name with it's own associated function.\r\n     */\r\n    hookObject(fns) {\r\n        for (const fn in fns) {\r\n            this.hook(fn, fns[fn]);\r\n        }\r\n    }\r\n    /**\r\n     * Start listening to the server.\r\n     */\r\n    start() {\r\n        this.open();\r\n        this.receive();\r\n        this.onError();\r\n        this.close();\r\n    }\r\n    /**\r\n     * Disconnect this client.\r\n     */\r\n    disconnect() {\r\n        this.ws.onopen = function () { };\r\n        this.ws.onmessage = function () { };\r\n        this.ws.onclose = function () { };\r\n        this.ws.close();\r\n    }\r\n    reconnectAfterMs(tries) {\r\n        return [500, 1000, 2000, 5000][tries - 1] || 10000;\r\n    }\r\n    /**\r\n     * Parse and filter the datas receive and give back the packet and the parsed data.\r\n     * @param {string} data The data to parse and filter.\r\n     * @returns {{packet:string, datas:any}} An object containing both the packet and the datas.\r\n     */\r\n    static filterPacket(data) {\r\n        const jsonFile = JSON.parse(data);\r\n        const packet = jsonFile._packet;\r\n        delete jsonFile._packet;\r\n        return {\r\n            packet: packet,\r\n            datas: jsonFile\r\n        };\r\n    }\r\n    connect() {\r\n        this.ws = new WebSocket(this.socketURL);\r\n        this.start();\r\n    }\r\n    open() {\r\n        this.ws.onopen = () => {\r\n            for (const fn of this.fns) {\r\n                fn((packet, obj) => {\r\n                    this.send(packet, obj);\r\n                });\r\n            }\r\n        };\r\n    }\r\n    receive() {\r\n        this.ws.onmessage = (e) => __awaiter(this, void 0, void 0, function* () {\r\n            const msg = LazyClient.filterPacket(e.data.toString());\r\n            for (const fn of this.fnr[msg.packet]) {\r\n                fn(msg.datas, this.ws);\r\n            }\r\n        });\r\n    }\r\n    onError() {\r\n        this.ws.onerror = (e) => __awaiter(this, void 0, void 0, function* () {\r\n            console.error(e.message);\r\n        });\r\n    }\r\n    close() {\r\n        this.ws.onclose = (e) => __awaiter(this, void 0, void 0, function* () {\r\n            if (e.code === 1006) { // Connection's lost\r\n                this.timer.start();\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyClient = LazyClient;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyClient.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyDoc.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyDoc.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyDoc = void 0;\r\n/**\r\n * A lazy way to write document.something.\r\n */\r\nclass LazyDoc {\r\n    static newTag(tagName, element) {\r\n        const eventSection = document.createElement(tagName);\r\n        if (element) {\r\n            if (element.id) {\r\n                eventSection.setAttribute('id', element.id);\r\n            }\r\n            if (element.class) {\r\n                element.class.forEach(c => eventSection.classList.add(c));\r\n            }\r\n            if (element.attributes) {\r\n                for (const att in element.attributes) {\r\n                    eventSection.setAttribute(att, element.attributes[att]);\r\n                }\r\n            }\r\n            if (element.innerHTML) {\r\n                eventSection.innerHTML = element.innerHTML;\r\n            }\r\n            if (element.innerText) {\r\n                eventSection.innerText = element.innerText;\r\n            }\r\n            if (element.childs) {\r\n                for (const child of element.childs) {\r\n                    eventSection.appendChild(child);\r\n                }\r\n            }\r\n            if (element.eventListeners) {\r\n                for (const evt in element.eventListeners) {\r\n                    eventSection.addEventListener(evt, element.eventListeners[evt]);\r\n                }\r\n            }\r\n        }\r\n        return eventSection;\r\n    }\r\n    static onEvent(query, type, listener, options) {\r\n        const currentElement = document.querySelector(query);\r\n        currentElement === null || currentElement === void 0 ? void 0 : currentElement.addEventListener(type, listener, options);\r\n    }\r\n    static onEventAll(query, type, listener, options) {\r\n        const allElements = document.querySelectorAll(query);\r\n        for (let currentElement of allElements) {\r\n            currentElement.addEventListener(type, listener, options);\r\n        }\r\n    }\r\n    static removeEvent(query, type, listener, options) {\r\n        const currentElement = document.querySelector(query);\r\n        currentElement === null || currentElement === void 0 ? void 0 : currentElement.removeEventListener(type, listener, options);\r\n    }\r\n    static removeEventAll(query, type, listener, options) {\r\n        const allElements = document.querySelectorAll(query);\r\n        for (const currentElement of allElements) {\r\n            currentElement.removeEventListener(type, listener, options);\r\n        }\r\n    }\r\n}\r\nexports.LazyDoc = LazyDoc;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyDoc.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyDualstate = void 0;\r\nconst lazyTristate_1 = __webpack_require__(/*! ./lazyTristate */ \"./node_modules/@lazy-toolbox/client/dist/lazyTristate.js\");\r\nconst DUAL_STATE = {\r\n    true: 'true',\r\n    false: 'false',\r\n    TRUE: 'true',\r\n    FALSE: 'false'\r\n};\r\n/**\r\n * A lazy way to use two states.\r\n */\r\nclass LazyDualstate {\r\n    constructor(item) {\r\n        var _a;\r\n        const itemValue = (_a = (item.value !== \"\" ? item.value : undefined)) !== null && _a !== void 0 ? _a : 'false';\r\n        item.readOnly = true;\r\n        item.size = 1;\r\n        if (!itemValue) {\r\n            item.value = lazyTristate_1.LazyTristate.FALSE;\r\n            item.innerText = lazyTristate_1.LazyTristate.FALSE;\r\n        }\r\n        else {\r\n            const stateSymbol = LazyDualstate.getState(itemValue);\r\n            item.value = stateSymbol;\r\n            item.innerText = stateSymbol;\r\n        }\r\n        item.addEventListener('click', (e) => {\r\n            const nextVal = LazyDualstate.nextState(e.target.value);\r\n            item.value = nextVal;\r\n            item.innerText = nextVal;\r\n            if (\"createEvent\" in document) {\r\n                var evt = document.createEvent(\"Event\");\r\n                evt.initEvent(\"change\", false, true);\r\n                item.dispatchEvent(evt);\r\n            }\r\n            else {\r\n                item.dispatchEvent(new Event('change'));\r\n            }\r\n        });\r\n    }\r\n    static stateToBool(actualDualstate) {\r\n        switch (actualDualstate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return true;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return false;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    static getState(actualDualstate) {\r\n        switch (actualDualstate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return lazyTristate_1.LazyTristate.TRUE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return lazyTristate_1.LazyTristate.FALSE;\r\n        }\r\n    }\r\n    static nextState(actualDualstate) {\r\n        switch (actualDualstate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return lazyTristate_1.LazyTristate.FALSE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return lazyTristate_1.LazyTristate.TRUE;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n}\r\nexports.LazyDualstate = LazyDualstate;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyFile.js":
/*!************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyFile.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyFile = void 0;\r\n/**\r\n * An easy way to manage file from a browser.\r\n */\r\nclass LazyFile {\r\n    /**\r\n     * Save a string content as a file.\r\n     * @param {string} fileName Name of the file.\r\n     * @param {string} content Content of the file.\r\n     */\r\n    static saveAs(fileName, content = \"\") {\r\n        const a = document.createElement(\"a\");\r\n        a.href = window.URL.createObjectURL(new Blob([content], { type: \"text/plain\" }));\r\n        a.download = fileName;\r\n        LazyFile.fakeClick(a);\r\n    }\r\n    static fakeClick(node) {\r\n        try {\r\n            node.dispatchEvent(new MouseEvent('click'));\r\n        }\r\n        catch (e) {\r\n            let evt = document.createEvent('MouseEvents');\r\n            evt === null || evt === void 0 ? void 0 : evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\r\n            node.dispatchEvent(evt);\r\n        }\r\n    }\r\n}\r\nexports.LazyFile = LazyFile;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyFile.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyHashRouter = void 0;\r\n/**\r\n * A lazy way to handle url parameters on a page.\r\n */\r\nclass LazyHashRouter {\r\n    /**\r\n     * Get the page route and an object represented in the url.\r\n     * @param {string | undefined} url The url to get the params from. If no url is provided, it's going to search the current url on the page.\r\n     * @returns {getter} A getter containing the page route and the resulting object represented in the url.\r\n     */\r\n    static getAllUrlParams(url) {\r\n        let queryString;\r\n        // get query string from url (optional) or window\r\n        if (url) {\r\n            const splitUrl = url.split('?');\r\n            splitUrl.shift();\r\n            queryString = splitUrl.join('?');\r\n        }\r\n        else {\r\n            queryString = window.location.search.slice(1);\r\n        }\r\n        let getPage = queryString.split('?');\r\n        queryString = getPage.length > 1 ? getPage[1] : getPage[0];\r\n        const getter = {\r\n            page: getPage.length > 1 ? getPage[0] : undefined,\r\n            result: undefined\r\n        };\r\n        // we'll store the parameters here\r\n        const obj = {};\r\n        // if query string exists\r\n        if (queryString) {\r\n            // stuff after # is not part of query string, so get rid of it\r\n            queryString = queryString.split('#')[0];\r\n            // split our query string into its component parts\r\n            const arr = queryString.split('&');\r\n            for (var i = 0; i < arr.length; i++) {\r\n                // separate the keys and the values\r\n                const a = arr[i].split('=');\r\n                // set parameter name and value (use 'false' if empty)\r\n                let paramName = a[0];\r\n                let paramValue = typeof (a[1]) === 'undefined' ? false : JSON.parse(decodeURIComponent(a[1]));\r\n                // (optional) keep case consistent\r\n                paramName = paramName.toLowerCase();\r\n                if (typeof paramValue === 'string') {\r\n                    paramValue = paramValue.toLowerCase();\r\n                }\r\n                // if the paramName ends with square brackets, e.g. colors[] or colors[2]\r\n                if (paramName.match(/\\[(\\d+)?\\]$/)) {\r\n                    // create key if it doesn't exist\r\n                    const key = paramName.replace(/\\[(\\d+)?\\]/, '');\r\n                    if (!obj[key]) {\r\n                        obj[key] = [];\r\n                    }\r\n                    // if it's an indexed array e.g. colors[2]\r\n                    if (paramName.match(/\\[\\d+\\]$/)) {\r\n                        // get the index value and add the entry at the appropriate position\r\n                        const index = /\\[(\\d+)\\]/.exec(paramName)[1];\r\n                        obj[key][index] = paramValue;\r\n                    }\r\n                    else {\r\n                        // otherwise add the value to the end of the array\r\n                        obj[key].push(paramValue);\r\n                    }\r\n                }\r\n                else {\r\n                    // we're dealing with a string\r\n                    if (!obj[paramName]) {\r\n                        // if it doesn't exist, create property\r\n                        obj[paramName] = paramValue;\r\n                    }\r\n                    else if (obj[paramName] && typeof obj[paramName] === 'string') {\r\n                        // if property does exist and it's a string, convert it to an array\r\n                        obj[paramName] = [obj[paramName]];\r\n                        obj[paramName].push(paramValue);\r\n                    }\r\n                    else {\r\n                        // otherwise add the property\r\n                        obj[paramName].push(paramValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        getter.result = obj;\r\n        return getter;\r\n    }\r\n    /**\r\n     * Create a string containing the parameters from a page route and an object.\r\n     * @param {string} page The route of the page.\r\n     * @param {{[name: string]: any}} object The object to make the parameters.\r\n     * @returns {string} The string containing the parameters from a page route and an object.\r\n     */\r\n    static setAllUrlParams(page, object) {\r\n        let result = `?${encodeURIComponent(page)}`;\r\n        let i = 0;\r\n        for (const objName in object) {\r\n            result += `${i++ == 0 ? '?' : '&'}${objName}=${encodeURIComponent(JSON.stringify(object[objName]))}`;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LazyHashRouter = LazyHashRouter;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyHashRouter.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyHtNetwork = void 0;\r\n/**\r\n * A lazy way to handle JS fetch API.\r\n * @function post Post data the same way an HTML form does.\r\n * @function postJSON Post a stringify JSON to an URL.\r\n * @function getJSON Get a stringify JSON from an URL.\r\n */\r\nclass LazyHtNetwork {\r\n    /**\r\n     * Post data the same way an HTML form does.\r\n     * @param {string} path The URL where we post datas.\r\n     * @param {{[name: string]: any}} datas The datas to post.\r\n     * @param {(json: Promise<any>) => void} execute A function to execute for any callback from the server.\r\n     * @param {(e: any) => void} error A function to handle any potential error.\r\n     */\r\n    static post(path, datas, execute = (e) => { }, error = (e) => console.error(e)) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const form = new FormData();\r\n                for (let data in datas) {\r\n                    form.append(data, datas[data]);\r\n                }\r\n                const fetchResult = yield fetch(path, {\r\n                    method: 'POST',\r\n                    body: form\r\n                });\r\n                const jsonData = yield fetchResult.json();\r\n                execute(jsonData);\r\n            }\r\n            catch (e) {\r\n                error(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Post a stringify JSON to an URL.\r\n     * @param {string} path The URL where we post datas.\r\n     * @param {{[name: string]: any}} datas The datas to post.\r\n     * @param {(json: Promise<any>) => void} execute A function to execute for any callback from the server.\r\n     * @param {(e: any) => void} error A function to handle any potential error.\r\n     */\r\n    static postJSON(path, datas, execute = (e) => { }, error = (e) => console.error(e)) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const fetchResult = yield fetch(path, {\r\n                    method: 'POST',\r\n                    body: JSON.stringify(datas),\r\n                    headers: {\r\n                        \"Accept\": \"application/json\",\r\n                        \"Content-type\": \"application/json\"\r\n                    }\r\n                });\r\n                const jsonData = yield fetchResult.json();\r\n                execute(jsonData);\r\n            }\r\n            catch (e) {\r\n                error(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Get a stringify JSON from an URL.\r\n     * @param {string} path The URL where the JSON file is located.\r\n     * @param {(json: Promise<any>) => void} execute A function to execute for the fetched JSON.\r\n     * @param {(e: any) => void} error A function to handle any potential error.\r\n     */\r\n    static getJSON(path, execute = (e) => { }, error = (e) => console.error(e)) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const fetchResult = yield fetch(path);\r\n                const jsonData = yield fetchResult.json();\r\n                execute(jsonData);\r\n            }\r\n            catch (e) {\r\n                error(e);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyHtNetwork = LazyHtNetwork;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyHtNetwork.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyInteractivity = void 0;\r\nconst lazyDualstate_1 = __webpack_require__(/*! ./lazyDualstate */ \"./node_modules/@lazy-toolbox/client/dist/lazyDualstate.js\");\r\nconst lazyTristate_1 = __webpack_require__(/*! ./lazyTristate */ \"./node_modules/@lazy-toolbox/client/dist/lazyTristate.js\");\r\n/**\r\n * A lazy way to make interactive elements.\r\n */\r\nclass LazyInteractivity {\r\n    /**\r\n     * Inject into the HTML new element behaviour.\r\n     */\r\n    static loadDefault() {\r\n        document.querySelectorAll('input[tristate]').forEach((el) => {\r\n            new lazyTristate_1.LazyTristate(el);\r\n        });\r\n        document.querySelectorAll('input[dualstate]').forEach((el) => {\r\n            new lazyDualstate_1.LazyDualstate(el);\r\n        });\r\n    }\r\n    /**\r\n     * Add support for an input with two states acting like boolean.\r\n     * @param {HTMLInputElement[]} inputsElements HTML input elements that need a dualstate.\r\n     */\r\n    static dualstate(...inputsElements) {\r\n        inputsElements.forEach((element) => {\r\n            if (element.getAttribute('dualstate') !== null) {\r\n                new lazyDualstate_1.LazyDualstate(element);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Add support for an input with three states acting like some kind of boolean.\r\n     * @param {HTMLInputElement[]} inputsElements HTML input elements that need a tristate.\r\n     */\r\n    static tristate(...inputsElements) {\r\n        inputsElements.forEach((element) => {\r\n            if (element.getAttribute('tristate') !== null) {\r\n                new lazyTristate_1.LazyTristate(element);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyInteractivity = LazyInteractivity;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyInteractivity.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazySchedule.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazySchedule.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazySchedule = void 0;\r\n/**\r\n * A lazy way to create a smart setInterval that handle a number of tries and can be paused.\r\n * @method start Start the schedule.\r\n * @method stop Stop the schedule. If the schedule had to be triggered in 30ms, when you'll start the schedule again, the schedule would be executed after those remaining 30ms.\r\n * @method reset Reset the schedule as if it has never started to begin with.\r\n */\r\nclass LazySchedule {\r\n    /**\r\n     * Create a new schedule.\r\n     * @param {(tries: number) => void} callback The callback function to execute when the interval's done.\r\n     * @param {(tries: number) => number} timerCalc A function to get the delay for the next schedule depending on the number of tries.\r\n     * @param {number} maxTries The maximum number of times to execute the schedule. If it's less than 0 then there's no maxTries and it will go on forever.\r\n     */\r\n    constructor(callback, timerCalc, maxTries = 1) {\r\n        this.startingTime = -1;\r\n        this.deltaTime = 0;\r\n        this.isStopped = false;\r\n        this.hasBeenStarted = false;\r\n        this.callback = callback;\r\n        this.timerCalc = timerCalc;\r\n        this.timer = undefined;\r\n        this.tries = 0;\r\n        this.maxTries = maxTries;\r\n    }\r\n    /**\r\n     * Reset the schedule as if it has never started to begin with.\r\n     */\r\n    reset() {\r\n        this.startingTime = -1;\r\n        this.tries = 0;\r\n        this.deltaTime = 0;\r\n        this.isStopped = false;\r\n        this.hasBeenStarted = false;\r\n        clearTimeout(this.timer);\r\n    }\r\n    /**\r\n     * Stop the schedule. If the schedule had to be triggered in 30ms, when you'll start the schedule again, the schedule would be executed after those remaining 30ms.\r\n     */\r\n    stop() {\r\n        clearTimeout(this.timer);\r\n        if (!this.isStopped && this.hasBeenStarted) {\r\n            this.deltaTime = Date.now() - this.startingTime;\r\n            this.tries--;\r\n        }\r\n        this.isStopped = true;\r\n    }\r\n    /**\r\n     * Start the schedule.\r\n     */\r\n    start() {\r\n        clearTimeout(this.timer);\r\n        this.hasBeenStarted = true;\r\n        this.isStopped = false;\r\n        // Either maxTries is not defined or maxTries is greater than the number of tries\r\n        if ((this.maxTries < 0) || (this.tries < this.maxTries)) {\r\n            this.startingTime = Date.now();\r\n            this.timer = setTimeout(() => {\r\n                this.tries = this.tries + 1;\r\n                this.callback(this.tries);\r\n            }, this.timerCalc(this.tries + 1) - this.deltaTime);\r\n            this.deltaTime = 0;\r\n        }\r\n    }\r\n}\r\nexports.LazySchedule = LazySchedule;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazySchedule.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazySlideContent = void 0;\r\nconst lazyAnimate_1 = __webpack_require__(/*! ./lazyAnimate */ \"./node_modules/@lazy-toolbox/client/dist/lazyAnimate.js\");\r\n/**\r\n * Insert a smooth sliding effect in a `HTMLDetailsElement`. This `HTMLDetailsElement` should contain a `<summary>` element and a `<content>` element to be valid for the animation.\r\n * `shr_duration`: Shrinking duration. By default it's set to `200` ms.\r\n * `shr_ease`: Shrinking easing. By default it's set to \"ease-out\".\r\n * `exp_duration`: Expending duration. By default it's set to `200` ms.\r\n * `exp_ease`: Expending easing. By default it's set to \"ease-out\".\r\n */\r\nclass LazySlideContent {\r\n    constructor(el) {\r\n        var _a;\r\n        this.isClosing = false; // Store if the element is closing\r\n        this.isExpanding = false; // Store if the element is expanding\r\n        this.el = el; // Store the <details> element\r\n        this.summary = el.querySelector('summary'); // Store the <summary> element\r\n        this.content = el.querySelector('content'); // Store the <content> element\r\n        this.animation = null; // Store the animation object (so we can cancel it if needed)\r\n        // Detect user clicks on the summary element\r\n        (_a = this.summary) === null || _a === void 0 ? void 0 : _a.addEventListener('click', (e) => this.onClick(e));\r\n    }\r\n    onClick(e) {\r\n        if (lazyAnimate_1.LazyAnimate.MediaQuery && !lazyAnimate_1.LazyAnimate.MediaQuery.matches) { // Execute the animation only if the user allow animation being executed\r\n            e.preventDefault(); // Stop default behaviour from the browser\r\n            this.el.style.overflow = 'hidden'; // Add an overflow on the <details> to avoid content overflowing\r\n            if (this.isClosing || !this.el.open) { // Check if the element is being closed or is already closed\r\n                this.open();\r\n            }\r\n            else if (this.isExpanding || this.el.open) { // Check if the element is being openned or is already open\r\n                this.shrink();\r\n            }\r\n        }\r\n    }\r\n    shrink() {\r\n        var _a, _b, _c;\r\n        this.isClosing = true; // Set the element as \"being closed\"\r\n        const startHeight = `${this.el.offsetHeight}px`; // Store the current height of the element\r\n        const endHeight = `${(_a = this.summary) === null || _a === void 0 ? void 0 : _a.offsetHeight}px`; // Calculate the height of the summary\r\n        if (this.animation) { // If there is already an animation running\r\n            this.animation.cancel(); // Cancel the current animation\r\n        }\r\n        this.animation = this.el.animate({\r\n            height: [startHeight, endHeight] // Set the keyframes from the startHeight to endHeight\r\n        }, {\r\n            duration: Number((_b = this.el.getAttribute('shr_duration')) !== null && _b !== void 0 ? _b : 250),\r\n            easing: (_c = this.el.getAttribute('shr_ease')) !== null && _c !== void 0 ? _c : \"ease-out\"\r\n        });\r\n        this.animation.onfinish = () => this.onAnimationFinish(false); // When the animation is complete, call onAnimationFinish()\r\n        this.animation.oncancel = () => this.isClosing = false; // If the animation is cancelled, isClosing variable is set to false\r\n    }\r\n    open() {\r\n        this.el.style.height = `${this.el.offsetHeight}px`; // Apply a fixed height on the element\r\n        this.el.open = true; // Force the [open] attribute on the details element\r\n        window.requestAnimationFrame(() => this.expand()); // Wait for the next frame to call the expand function\r\n    }\r\n    expand() {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        this.isExpanding = true; // Set the element as \"being expanding\"\r\n        const startHeight = `${this.el.offsetHeight}px`; // Get the current fixed height of the element\r\n        const endHeight = `${((_b = (_a = this.summary) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = this.content) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0)}px`; // Calculate the open height of the element (summary height + content height)\r\n        if (this.animation) { // If there is already an animation running\r\n            this.animation.cancel(); // Cancel the current animation\r\n        }\r\n        this.animation = this.el.animate({\r\n            height: [startHeight, endHeight] // Set the keyframes from the startHeight to endHeight\r\n        }, {\r\n            duration: Number((_e = this.el.getAttribute('exp_duration')) !== null && _e !== void 0 ? _e : 250),\r\n            easing: (_f = this.el.getAttribute('exp_ease')) !== null && _f !== void 0 ? _f : \"ease-out\"\r\n        });\r\n        this.animation.onfinish = () => this.onAnimationFinish(true); // When the animation is complete, call onAnimationFinish()\r\n        this.animation.oncancel = () => this.isExpanding = false; // If the animation is cancelled, isExpanding variable is set to false\r\n    }\r\n    onAnimationFinish(open) {\r\n        this.el.open = open; // Set the open attribute based on the parameter\r\n        this.animation = null; // Clear the stored animation\r\n        // Reset isClosing & isExpanding\r\n        this.isClosing = false;\r\n        this.isExpanding = false;\r\n        this.el.style.height = this.el.style.overflow = ''; // Remove the overflow hidden and the fixed height\r\n    }\r\n}\r\nexports.LazySlideContent = LazySlideContent;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazySlideContent.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyTabularTextArea = void 0;\r\nconst lazyCaret_1 = __webpack_require__(/*! ./lazyCaret */ \"./node_modules/@lazy-toolbox/client/dist/lazyCaret.js\");\r\n/**\r\n * Add support for tabulation in a text area.\r\n */\r\nclass LazyTabularTextArea {\r\n    constructor(el, tabLength = 4) {\r\n        this.tabLength = tabLength;\r\n        this.editor = el;\r\n        this.onKeydown();\r\n    }\r\n    onKeydown() {\r\n        this.editor.addEventListener('keydown', (event) => {\r\n            if (event.key === 'Tab') {\r\n                lazyCaret_1.LazyCaret.tabulation(this.editor, event.shiftKey, this.tabLength);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LazyTabularTextArea = LazyTabularTextArea;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyTabularTextArea.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyTheme.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyTheme.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyTheme = void 0;\r\n/**\r\n * A lazy theme implementation.\r\n * @method theme Get the current theme used.\r\n * @method setNextTheme Change the theme to the next one available in the list.\r\n * @method setPreviousTheme Change the theme to the previous one available in the list.\r\n * @method setTheme Set the current theme on the page.\r\n * @method useTheme Use a theme that exist on the page otherwise it will use the current theme.\r\n */\r\nclass LazyTheme {\r\n    /**\r\n     * Create a theme handle by giving it a bunch of CSS classes for theme and all the elements that should be affected by it.\r\n     * @param themesClasses An array of all CSS classes that handle the theme.\r\n     * @param elementsQueries An array of all queries of the HTML elements that are affected by the theme.\r\n     */\r\n    constructor(themesClasses, elementsQueries) {\r\n        this.defaultTheme = 0;\r\n        this.themes = themesClasses;\r\n        this.elements = elementsQueries;\r\n    }\r\n    /**\r\n     * Get the current theme used.\r\n     * @returns {string} The name of the current CSS class that handle the theme.\r\n     */\r\n    theme() {\r\n        return this.themes[this.defaultTheme];\r\n    }\r\n    /**\r\n     * Change the theme to the next one available in the list.\r\n     */\r\n    setNextTheme() {\r\n        this.defaultTheme++;\r\n        this.toggleTheme();\r\n        this.setTheme();\r\n    }\r\n    /**\r\n     * Change the theme to the previous one available in the list.\r\n     */\r\n    setPreviousTheme() {\r\n        this.defaultTheme--;\r\n        this.toggleTheme();\r\n        this.setTheme();\r\n    }\r\n    /**\r\n     * Set the current theme on the page.\r\n     */\r\n    setTheme() {\r\n        const useTheme = this.themes[this.defaultTheme];\r\n        for (const element of this.elements) {\r\n            this.setNewTheme(element, useTheme);\r\n        }\r\n    }\r\n    /**\r\n     * Use a theme that exist on the page otherwise it will use the current theme.\r\n     * @param {string} newTheme The name of the theme to use.\r\n     */\r\n    useTheme(newTheme) {\r\n        let useTheme = newTheme;\r\n        if (!this.themes.includes(newTheme)) {\r\n            useTheme = this.themes[this.defaultTheme];\r\n        }\r\n        for (const element of this.elements) {\r\n            this.setNewTheme(element, useTheme);\r\n        }\r\n    }\r\n    /**\r\n     * Clamp the value of the defaultTheme with modulo.\r\n     */\r\n    toggleTheme() {\r\n        this.defaultTheme = this.defaultTheme - Math.floor(this.defaultTheme / this.themes.length) * this.themes.length;\r\n    }\r\n    /**\r\n     * Handle the DOM changes for the theme.\r\n     * @param elementQuery\r\n     * @param newTheme\r\n     */\r\n    setNewTheme(elementQuery, newTheme) {\r\n        const elements = document.querySelectorAll(elementQuery);\r\n        for (const e of elements) {\r\n            for (const t of this.themes) {\r\n                e.classList.remove(t);\r\n            }\r\n            e.classList.add(newTheme);\r\n        }\r\n    }\r\n}\r\nexports.LazyTheme = LazyTheme;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyTheme.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyTristate.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyTristate.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyTristate = void 0;\r\nconst TRISTATE_STATE = {\r\n    true: 'true',\r\n    false: 'false',\r\n    neutral: 'neutral',\r\n    TRUE: 'TRUE',\r\n    FALSE: 'FALSE',\r\n    NEUTRAL: 'NEUTRAL'\r\n};\r\n/**\r\n * A lazy way to use three states.\r\n */\r\nclass LazyTristate {\r\n    constructor(item) {\r\n        var _a;\r\n        const itemValue = (_a = (item.value !== \"\" ? item.value : undefined)) !== null && _a !== void 0 ? _a : 'neutral';\r\n        item.readOnly = true;\r\n        item.size = 1;\r\n        if (!itemValue) {\r\n            item.value = LazyTristate.NEUTRAL;\r\n            item.innerText = LazyTristate.NEUTRAL;\r\n        }\r\n        else {\r\n            const stateSymbol = LazyTristate.getState(itemValue);\r\n            item.value = stateSymbol;\r\n            item.innerText = stateSymbol;\r\n        }\r\n        item.addEventListener('click', (e) => {\r\n            const nextVal = LazyTristate.nextState(e.target.value);\r\n            item.value = nextVal;\r\n            item.innerText = nextVal;\r\n            if (\"createEvent\" in document) {\r\n                var evt = document.createEvent(\"Event\");\r\n                evt.initEvent(\"change\", false, true);\r\n                item.dispatchEvent(evt);\r\n            }\r\n            else {\r\n                item.dispatchEvent(new Event('change'));\r\n            }\r\n        });\r\n    }\r\n    static stateToString(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return \"true\";\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return \"neutral\";\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return \"false\";\r\n            default:\r\n                return \"undefined\";\r\n        }\r\n    }\r\n    static getState(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return LazyTristate.TRUE;\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return LazyTristate.NEUTRAL;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return LazyTristate.FALSE;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    static nextState(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return LazyTristate.FALSE;\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return LazyTristate.TRUE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return LazyTristate.NEUTRAL;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    static previousState(actualTristate) {\r\n        switch (actualTristate) {\r\n            case true:\r\n            case '\\u2705':\r\n            case 'true':\r\n            case 'TRUE':\r\n                return LazyTristate.NEUTRAL;\r\n            case '\\u2753':\r\n            case 'neutral':\r\n            case 'NEUTRAL':\r\n                return LazyTristate.FALSE;\r\n            case false:\r\n            case '\\u274C':\r\n            case 'false':\r\n            case 'FALSE':\r\n                return LazyTristate.TRUE;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n}\r\nexports.LazyTristate = LazyTristate;\r\nLazyTristate.TRUE = '\\u2705';\r\nLazyTristate.FALSE = '\\u274C';\r\nLazyTristate.NEUTRAL = '\\u2753';\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyTristate.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/client/dist/lazyView.js":
/*!************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/client/dist/lazyView.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyView = void 0;\r\n/**\r\n * A bunch of lazy ways to handle some HTML injection or extraction.\r\n * @function replaceInsert Replace entirely an HTML <insert data=\"MyDataName\">Just some HTML comment code</insert> to any value contained inside the `newHTMLContent`.\r\n * @function inject Inject a bunch of datas inside a HTML document.\r\n * @function toNode Convert some HTML content into a ChildNode (if possible). If there's multiple HTML elements, only the first one will be returned.\r\n * @function toNodeList Convert some HTML content to a NodeListOf<ChildNode>.\r\n * @function toArray Convert some HTML content to an array of ChildNode.\r\n * @function toText Convert an array of ChildNode to string.\r\n */\r\nclass LazyView {\r\n    /**\r\n     * Get the innerHTML of the div element.\r\n     * @returns The innerHTML of the div element.\r\n     */\r\n    static extractHTML() {\r\n        const result = LazyView.div.innerHTML;\r\n        LazyView.div.innerHTML = '';\r\n        return result;\r\n    }\r\n    /**\r\n     * Replace entirely an HTML <insert data=\"MyDataName\">Just some HTML comment code</insert> to any value contained inside the `newHTMLContent`.\r\n     * @param {HTMLElement} actualElement An HTML element.\r\n     * @param {string} targetElement The value's name contained inside an insert tag.\r\n     * @param {string} newHTMLContent The content to inject.\r\n     */\r\n    static replaceInsert(actualElement, targetElement, newHTMLContent) {\r\n        while (true) {\r\n            let i, tmp, elm, last;\r\n            // find our target\r\n            const target = actualElement.querySelector(`insert[data=${targetElement}]`);\r\n            if (!target) {\r\n                break;\r\n            }\r\n            // create a temporary div or tr (to support tds)\r\n            tmp = document.createElement(newHTMLContent.indexOf('<td') != -1 ? 'tr' : 'div');\r\n            // fill that div with our html, this generates our children\r\n            tmp.innerHTML = newHTMLContent;\r\n            // step through the temporary div's children and insertBefore our target\r\n            i = tmp.childNodes.length;\r\n            last = target;\r\n            if (target.parentNode) {\r\n                while (i--) {\r\n                    target.parentNode.insertBefore((elm = tmp.childNodes[i]), last);\r\n                    last = elm;\r\n                }\r\n                /// remove the target.\r\n                target.parentNode.removeChild(target);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Inject a bunch of datas inside a HTML document.\r\n     * @param {string} htmlDoc The HTML document given as a string.\r\n     * @param {{[name: string]: string}} toInject The data to inject inside the document.\r\n     * @returns {string} The new HTML string with all the injections done.\r\n     */\r\n    static inject(htmlDoc, toInject) {\r\n        LazyView.div.innerHTML = htmlDoc;\r\n        for (const inject in toInject) {\r\n            LazyView.replaceInsert(LazyView.div, inject, toInject[inject]);\r\n        }\r\n        return LazyView.extractHTML();\r\n    }\r\n    /**\r\n     * Convert some HTML content into a ChildNode (if possible). If there's multiple HTML elements, only the first one will be returned.\r\n     * @param {string} content The HTML to convert into a ChildNode.\r\n     * @returns {ChildNode | null} The ChildNode made from the HTML string.\r\n     */\r\n    static toNode(content) {\r\n        LazyView.div.innerHTML = content;\r\n        const node = LazyView.div.firstChild;\r\n        LazyView.div.innerHTML = '';\r\n        return node;\r\n    }\r\n    /**\r\n     * Convert some HTML content to a NodeListOf<ChildNode>.\r\n     * @param {string} content The HTML to convert into a ChildNode.\r\n     * @returns {NodeListOf<ChildNode>} The NodeListOf<ChildNode> made from the HTML string.\r\n     */\r\n    static toNodeList(content) {\r\n        LazyView.div.innerHTML = content;\r\n        const nodes = LazyView.div.childNodes;\r\n        LazyView.div.innerHTML = '';\r\n        return nodes;\r\n    }\r\n    /**\r\n     * Convert some HTML content to an array of ChildNode.\r\n     * @param {string} content The HTML to convert into a ChildNode.\r\n     * @returns {ChildNode[]} The array of ChildNode made from the HTML string.\r\n     */\r\n    static toArray(content) {\r\n        LazyView.div.innerHTML = content;\r\n        const nodes = [...LazyView.div.childNodes];\r\n        LazyView.div.innerHTML = '';\r\n        return nodes;\r\n    }\r\n    /**\r\n     * Convert an array of ChildNode to string.\r\n     * @param {ChildNode[]} content The array of ChildNode to convert.\r\n     * @returns {string} The string made with the array of ChildNode.\r\n     */\r\n    static toText(content) {\r\n        for (const node of content) {\r\n            LazyView.div.appendChild(node);\r\n        }\r\n        return LazyView.extractHTML();\r\n    }\r\n}\r\nexports.LazyView = LazyView;\r\ntry {\r\n    LazyView.div = document.createElement('div');\r\n}\r\ncatch (e) { }\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/client/dist/lazyView.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.dateLogMS = exports.dateLog = exports.getType = exports.LazyRule = exports.LazyPattern = exports.LazyParsing = exports.LazyText = exports.LazyDataGraph = exports.LazyMapper = exports.LazyMath = void 0;\r\nvar lazyMath_1 = __webpack_require__(/*! ./lazyMath */ \"./node_modules/@lazy-toolbox/portable/dist/lazyMath.js\");\r\nObject.defineProperty(exports, \"LazyMath\", ({ enumerable: true, get: function () { return lazyMath_1.LazyMath; } }));\r\nvar lazyMapper_1 = __webpack_require__(/*! ./lazyMapper */ \"./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js\");\r\nObject.defineProperty(exports, \"LazyMapper\", ({ enumerable: true, get: function () { return lazyMapper_1.LazyMapper; } }));\r\nvar lazyDataGraph_1 = __webpack_require__(/*! ./lazyDataGraph */ \"./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js\");\r\nObject.defineProperty(exports, \"LazyDataGraph\", ({ enumerable: true, get: function () { return lazyDataGraph_1.LazyDataGraph; } }));\r\nvar lazyText_1 = __webpack_require__(/*! ./lazyText */ \"./node_modules/@lazy-toolbox/portable/dist/lazyText.js\");\r\nObject.defineProperty(exports, \"LazyText\", ({ enumerable: true, get: function () { return lazyText_1.LazyText; } }));\r\nvar lazyParsing_1 = __webpack_require__(/*! ./parser/lazyParsing */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js\");\r\nObject.defineProperty(exports, \"LazyParsing\", ({ enumerable: true, get: function () { return lazyParsing_1.LazyParsing; } }));\r\nvar lazyPattern_1 = __webpack_require__(/*! ./parser/lazyPattern */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js\");\r\nObject.defineProperty(exports, \"LazyPattern\", ({ enumerable: true, get: function () { return lazyPattern_1.LazyPattern; } }));\r\nvar lazyRule_1 = __webpack_require__(/*! ./parser/lazyRule */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js\");\r\nObject.defineProperty(exports, \"LazyRule\", ({ enumerable: true, get: function () { return lazyRule_1.LazyRule; } }));\r\nvar lazyTypeof_1 = __webpack_require__(/*! ./lazyTypeof */ \"./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js\");\r\nObject.defineProperty(exports, \"getType\", ({ enumerable: true, get: function () { return lazyTypeof_1.getType; } }));\r\nvar lazyLog_1 = __webpack_require__(/*! ./lazyLog */ \"./node_modules/@lazy-toolbox/portable/dist/lazyLog.js\");\r\nObject.defineProperty(exports, \"dateLog\", ({ enumerable: true, get: function () { return lazyLog_1.dateLog; } }));\r\nObject.defineProperty(exports, \"dateLogMS\", ({ enumerable: true, get: function () { return lazyLog_1.dateLogMS; } }));\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/index.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyDataGraph = void 0;\r\n/**\r\n * A non-visual graph to analyze variation in datas.\r\n */\r\nclass LazyDataGraph {\r\n    /**\r\n     * Create a new graph with some points.\r\n     * @param {GraphPoint[]} datas An array of points on the graph.\r\n     */\r\n    constructor(...datas) {\r\n        this._points = [...datas];\r\n        this.isTan = false;\r\n    }\r\n    /**\r\n     * Get the points on the graph.\r\n     */\r\n    get points() {\r\n        return [...this._points];\r\n    }\r\n    /**\r\n     * Set the points on the graph.\r\n     */\r\n    set points(pts) {\r\n        this._points = [...pts];\r\n    }\r\n    /**\r\n     * Check if the graph is a tangent graph or a root graph.\r\n     * @returns {boolean} True if the graph is a tangent graph.\r\n     */\r\n    isTangentGraph() {\r\n        return this.isTan;\r\n    }\r\n    /**\r\n     * Get the tangent graph, showing the difference happening between each points and the increased / decreased percentage.\r\n     * @returns {LazyDataGraph} The tangent graph.\r\n     */\r\n    getTangentGraph() {\r\n        const tanGraph = new LazyDataGraph(...this.generateSlope());\r\n        tanGraph.isTan = true;\r\n        return tanGraph;\r\n    }\r\n    /**\r\n     * Generate a bunch of tangent points from this graph.\r\n     * @returns {GraphPoint[]} The tangent points array.\r\n     */\r\n    generateSlope() {\r\n        if (this._points.length <= 1) {\r\n            return [];\r\n        }\r\n        const lastI = this._points.length - 1;\r\n        const slope = [];\r\n        for (let i = 0; i < lastI; i++) {\r\n            const actual = this._points[i];\r\n            const next = this._points[i + 1];\r\n            const preSlope = next.value - actual.value;\r\n            const result = {\r\n                value: preSlope,\r\n                label: `${actual.label}-${next.label}`,\r\n                increasePercent: preSlope / (actual.value != 0 ? actual.value : 1)\r\n            };\r\n            slope.push(result);\r\n        }\r\n        return slope;\r\n    }\r\n}\r\nexports.LazyDataGraph = LazyDataGraph;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyDataGraph.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyLog.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyLog.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.dateLog = exports.dateLogMS = void 0;\r\n/**\r\n * Create a message with the time display up to the ms.\r\n *\r\n * It will be showned as `[HH:MM:SS.DCM] MY_MESSAGE`.\r\n * @param {any} msg The message to display.\r\n * @returns {string} The string with the time displayed.\r\n */\r\nfunction dateLogMS(msg) {\r\n    const actualTime = new Date(Date.now());\r\n    let hours = `${actualTime.getHours()}`;\r\n    hours = hours.length == 1 ? `0${hours}` : hours;\r\n    let min = `${actualTime.getMinutes()}`;\r\n    min = min.length == 1 ? `0${min}` : min;\r\n    let sec = `${actualTime.getSeconds()}`;\r\n    sec = sec.length == 1 ? `0${sec}` : sec;\r\n    let milSec = `${actualTime.getMilliseconds()}`;\r\n    milSec = milSec.length == 1 ? `00${milSec}` : milSec.length == 2 ? `0${milSec}` : milSec;\r\n    return `[${hours}:${min}:${sec}.${milSec}] ${msg.toString()}`;\r\n}\r\nexports.dateLogMS = dateLogMS;\r\n;\r\n/**\r\n * Create a message with the time display up to the s.\r\n *\r\n * It will be showned as `[HH:MM:SS] MY_MESSAGE`.\r\n * @param {any} msg The message to display.\r\n * @returns {string} The string with the time displayed.\r\n */\r\nfunction dateLog(msg) {\r\n    const actualTime = new Date(Date.now());\r\n    let hours = `${actualTime.getHours()}`;\r\n    hours = hours.length == 1 ? `0${hours}` : hours;\r\n    let min = `${actualTime.getMinutes()}`;\r\n    min = min.length == 1 ? `0${min}` : min;\r\n    let sec = `${actualTime.getSeconds()}`;\r\n    sec = sec.length == 1 ? `0${sec}` : sec;\r\n    return `[${hours}:${min}:${sec}] ${msg.toString()}`;\r\n}\r\nexports.dateLog = dateLog;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyLog.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyMapper = void 0;\r\n/**\r\n * A mapper to allow some filtering for retrieved variables that could be undefined.\r\n */\r\nclass LazyMapper {\r\n    /**\r\n     * Filter a data and set a default value if the data is undefined. If it's defined, transform the data the way you want then filter whatever the result is.\r\n     * @param {any} data The data to filter.\r\n     * @param {T} defaultValue The default value to set to your data in case it's undefined.\r\n     * @param {(d: any) => T} transform A function to transform your any data type into your actual type.\r\n     * @param {(d: T) => T} filter A function to filter your data.\r\n     * @returns {T} The data with your choosen filtered data type.\r\n     */\r\n    static filterData(data, defaultValue, transform, filter) {\r\n        let result = defaultValue;\r\n        if (data !== undefined) {\r\n            result = transform(data);\r\n        }\r\n        return filter(result);\r\n    }\r\n    /**\r\n     * Filter the value of a received number or the default number in case the received number was undefined.\r\n     * @param {any} data The data to filter.\r\n     * @param {number} defaultValue The default number to set.\r\n     * @param {(d: number) => number} filter The filtering function.\r\n     * @returns {number} The filtered number.\r\n     */\r\n    static filterNumber(data, defaultValue, filter) {\r\n        return LazyMapper.filterData(data, defaultValue, (d) => d === null ? 0 : Number(d), filter);\r\n    }\r\n    /**\r\n     * Filter the value of a received string or the default string in case the received string was undefined.\r\n     * @param {any} data The data to filter.\r\n     * @param {string} defaultValue The default string to set.\r\n     * @param {(d: string) => string} filter The filtering function.\r\n     * @returns {string} The filtered number.\r\n     */\r\n    static filterString(data, defaultValue, filter) {\r\n        return LazyMapper.filterData(data, defaultValue, (d) => d === null ? defaultValue : String(d), filter);\r\n    }\r\n    /**\r\n     * Filter a data and set a default value if the data is undefined. If it's defined, transform the data the way you want.\r\n     * @param {any} data The data to filter.\r\n     * @param {T} defaultValue The default value to set to your data in case it's undefined.\r\n     * @param {(d: any) => T} transform A function to transform your any data type into your actual type.\r\n     * @returns {T} The data with your choosen filtered data type.\r\n     */\r\n    static defaultData(data, defaultValue, transform) {\r\n        return LazyMapper.filterData(data, defaultValue, transform, (d) => d);\r\n    }\r\n    /**\r\n     * Retrieve a boolean from a data. If the data is undefined, the value will be set to a default value.\r\n     * @param {any} data The data to filter.\r\n     * @param {boolean} defaultValue The default value to set to your data in case it's undefined.\r\n     * @returns {boolean} The filtered data.\r\n     */\r\n    static defaultBoolean(data, defaultValue) {\r\n        return LazyMapper.defaultData(data, defaultValue, (d) => d === null ? defaultValue : Boolean(d));\r\n    }\r\n    /**\r\n     * Retrieve a number from a data. If the data is undefined, the value will be set to a default value.\r\n     * @param {any} data The data to filter.\r\n     * @param {number} defaultValue The default value to set to your data in case it's undefined.\r\n     * @returns {number} The filtered data.\r\n     */\r\n    static defaultNumber(data, defaultValue) {\r\n        return LazyMapper.defaultData(data, defaultValue, (d) => d === null ? 0 : Number(d));\r\n    }\r\n    /**\r\n     * Retrieve a string from a data. If the data is undefined, the value will be set to a default value.\r\n     * @param {any} data The data to filter.\r\n     * @param {string} defaultValue The default value to set to your data in case it's undefined.\r\n     * @returns {string} The filtered data.\r\n     */\r\n    static defaultString(data, defaultValue) {\r\n        return LazyMapper.defaultData(data, defaultValue, (d) => d === null ? defaultValue : String(d));\r\n    }\r\n    /**\r\n     * Convert a data to a boolean type. If undefined, it's set to false by default.\r\n     * @param {any} data The data to convert.\r\n     * @returns {boolean} The boolean representation of the data.\r\n     */\r\n    static boolean(data) {\r\n        return LazyMapper.defaultData(data, false, (d) => Boolean(d));\r\n    }\r\n    /**\r\n     * Convert a data to a number type. If undefined, it's set to 0 by default.\r\n     * @param {any} data The data to convert.\r\n     * @returns {number} The number representation of the data.\r\n     */\r\n    static number(data) {\r\n        return LazyMapper.defaultData(data, 0, (d) => Number(d));\r\n    }\r\n    /**\r\n     * Convert a data to a string type. If undefined, it's set to \"\" by default.\r\n     * @param {any} data The data to convert.\r\n     * @returns {string} The string representation of the data.\r\n     */\r\n    static string(data) {\r\n        return LazyMapper.defaultData(data, \"\", (d) => d.toString());\r\n    }\r\n}\r\nexports.LazyMapper = LazyMapper;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyMapper.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyMath.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyMath.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyMath = void 0;\r\n/**\r\n * Add some lazy math that should have been available at first on JS.\r\n*/\r\nclass LazyMath {\r\n    /**\r\n     * Compute the remainder of a / b. a % b IS NOT modulo in JS for some reason.\r\n     * @param {number} a What we want the remainder from.\r\n     * @param {number} b What's dividing a.\r\n     * @returns A value between 0 (included) and the remainder of the divisor (not included).\r\n     */\r\n    static modulo(a, b) {\r\n        return a - Math.floor(a / b) * b;\r\n    }\r\n    /**\r\n     * Get the leftover to obtain an integer less or equal to n.\r\n     * @param {number} n The number to get the fractional part from.\r\n     * @returns {number} The fractional part of the number a.\r\n     */\r\n    static frac(n) {\r\n        return n - Math.floor(n);\r\n    }\r\n    /**\r\n     * Clamp a value between 0 and 1.\r\n     * @param {number} a The number to clamp.\r\n     * @returns {number} A value between 0 and 1.\r\n     */\r\n    static saturate(a) {\r\n        return (a > 1) ? 1 : (a < 0) ? 0 : a;\r\n    }\r\n    /**\r\n     * Iterative sum of f.\r\n     * @param {number} k The start index.\r\n     * @param {number} n The last index.\r\n     * @param {(i: number) => number} f A function to execute.\r\n     * @returns {number} The result of the sum.\r\n     */\r\n    static sum(k, n, f) {\r\n        let result = 0;\r\n        for (let i = k; i <= n; i++) {\r\n            result += f(i);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Iterative product of f.\r\n     * @param {number} k The start index.\r\n     * @param {number} n The last index.\r\n     * @param {(i: number) => number} f A function to execute.\r\n     * @returns {number} The result of the product.\r\n     */\r\n    static product(k, n, f) {\r\n        let result = 1;\r\n        for (let i = k; i <= n; i++) {\r\n            result *= f(i);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * A primary test that will return true if the number is prime. Since JS use floating point arithmetic on number, the number is floored before the test.\r\n     * @param {number} n The number to test.\r\n     * @returns {boolean} True if the number is prime.\r\n     */\r\n    static isPrime(n) {\r\n        n = Math.floor(n);\r\n        if (n <= 3) {\r\n            if (n < 0) {\r\n                n = -n;\r\n            }\r\n            if (n <= 3) {\r\n                return (n > 1);\r\n            }\r\n        }\r\n        if (n % 2 == 0 || n % 3 == 0) {\r\n            return false;\r\n        }\r\n        for (let i = 5; i * i <= n; i += 6) {\r\n            if (n % i == 0 || n % (i + 2) == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Return 1 if x is gequal to n, otherwise n.\r\n     * @param {number} n Number to apply step.\r\n     * @param {number} x Step comparison.\r\n     * @returns {number} The result of the operation.\r\n     */\r\n    static step(n, x) {\r\n        return x >= n ? 1 : n;\r\n    }\r\n    /**\r\n     * Do a linear interpolation between a and b using the parameter t for the interpolated distance.\r\n     * @param {number} a The starting position.\r\n     * @param {number} b The ending position.\r\n     * @param {number} t A value between 0 and 1 (0 being 0% and 1 being 100%), determining how much we interpolate between a and b.\r\n     * @returns {number} A number between a and b depending on t.\r\n     */\r\n    static lerp(a, b, t) {\r\n        return a + (b - a) * t;\r\n    }\r\n    /**\r\n     * Get the interpolated distance of p on the line from a to b.\r\n     * @param {number} a The starting position.\r\n     * @param {number} b The ending position.\r\n     * @param {number} p A value between a and b.\r\n     * @returns {number} A value between 0 and 1 representing the interpolated percentage between a and b.\r\n     */\r\n    static unlerp(a, b, p) {\r\n        return (p - a) / (b - a);\r\n    }\r\n    /**\r\n     * Compute the number of ways to choose an unordered subset of k elements from a fixed set of n elements. n ≥ k ≥ 0.\r\n     * @param {number} n Number of elements.\r\n     * @param {number} k Number of subset.\r\n     * @returns {number} The positive integers that occur as coefficients in the binomial theorem.\r\n     */\r\n    static binomialCoefficient(n, k) {\r\n        const mid = n / 2;\r\n        if (k > n) {\r\n            throw new Error(\"k can't be greater than n.\");\r\n        }\r\n        if (k == n) {\r\n            return 1;\r\n        }\r\n        if (k > mid) {\r\n            let num = 1;\r\n            let den = 1;\r\n            for (let i = k + 1, j = 1; i <= n; i++, j++) {\r\n                num *= i;\r\n                den *= j;\r\n            }\r\n            return num / den;\r\n        }\r\n        else if (n % 2 == 0 && mid == k) {\r\n            let num = 1;\r\n            let den = 1;\r\n            let i;\r\n            for (i = 1; i <= mid; i++) {\r\n                den *= i;\r\n            }\r\n            for (; i <= n; i++) {\r\n                num *= i;\r\n            }\r\n            return num / den;\r\n        }\r\n        else {\r\n            const nk = n - k;\r\n            let num = 1;\r\n            let den = 1;\r\n            for (let i = nk + 1, j = 1; i <= n; i++, j++) {\r\n                num *= i;\r\n                den *= j;\r\n            }\r\n            return num / den;\r\n        }\r\n    }\r\n    /**\r\n     * Evaluate the derivative of a function f at a point x. d/dx f(x)\r\n     * @param {number} x Evaluation point.\r\n     * @param {number} f Function f.\r\n     * @returns {number} The result of f'(x).\r\n     */\r\n    static derivative(x, f) {\r\n        const eps = 0.000000000000000919191919;\r\n        return (f(x + eps) - f(x)) / eps;\r\n    }\r\n    /**\r\n     * Evaluate the anti-derivative of a function f' at a point x. ∫ f'(x) dx\r\n     * @param {number} x Evaluation point.\r\n     * @param {number} f Function f'.\r\n     * @param {number} subdivide The number of subdivision to use. The more you have, the better the approximation.\r\n     * @returns {number} The result of F(x).\r\n     */\r\n    static antiDerivative(x, f, subdivide = 50) {\r\n        if (subdivide <= 0) {\r\n            subdivide = 1;\r\n        }\r\n        let result = 0;\r\n        const offset = x / subdivide;\r\n        for (let i = 0; i < subdivide; i++) {\r\n            result += f(offset * i) * offset;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Evaluate the area under the curve of a function f' from a to b. ∫_a^b f'(x) dx\r\n     * @param {number} a The point to start.\r\n     * @param {number} b The point to end.\r\n     * @param {number} f Function f'.\r\n     * @param {number} subdivide The number of subdivision to use. The more you have, the better the approximation.\r\n     * @returns {number} The result of F(b) - F(a).\r\n     */\r\n    static integral(a, b, f, subdivide = 50) {\r\n        if (subdivide <= 0) {\r\n            subdivide = 1;\r\n        }\r\n        let result = 0;\r\n        const offset = (b - a) / subdivide;\r\n        for (let i = 0; i < subdivide; i++) {\r\n            result += f(a + offset * i) * offset;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Return an array of ordered combination without repetition of n objets (a string array) classified in k groups.\r\n     * @param {T[]} objects An array of object to reorder.\r\n     * @param {number} k The number of classified groups.\r\n     * @returns {any[]} Return an array where each cell contain the grouping result of the object.\r\n     */\r\n    static combinationArrayNRNO(objects, k) {\r\n        let n = objects.length; // Assign n as the length of all objets or the number passed through the function\r\n        if (n < k) // n must be greater or equal to k...\r\n         {\r\n            throw new Error('The number of object must be greater or equal to k.');\r\n        }\r\n        const offset = n - k + 1; // The offset generated by the number of group\r\n        let result = []; // Declare the result\r\n        for (let i = 0; i < offset; i++) // Loop through all possible values on the first element\r\n         {\r\n            let content = [];\r\n            content.push(objects[i]);\r\n            let generated = LazyMath.combinationArrayDepthNRNO(objects, // Pass our objects\r\n            i + 1, // Go to the next index to get the start of the next element\r\n            offset + 1, // Subgroup gain a start offset of 1\r\n            k - 1, // Align k for depth check since array start at 0\r\n            0, // No depth, it's the 1st subgroup\r\n            content // Pass the container of objets itself for referencing\r\n            );\r\n            Array.prototype.push.apply(result, generated); // Combine result\r\n        }\r\n        return result; // Return the result\r\n    }\r\n    /***\r\n     * Generate an array of the entire set of element made out of binomial coefficient by taking the depth stack into account.\r\n     */\r\n    static combinationArrayDepthNRNO(objects, index, offset, k, depth = 0, content = []) {\r\n        if (depth >= k) { // If our depth is grater or equal to k, then we have all we need\r\n            return [content]; // We return the new array of objects made on the way.\r\n        }\r\n        let result = []; // Declare a result\r\n        for (let i = index; i < offset; i++) // Loop through the possible values between index and offset - 1\r\n         {\r\n            let copyContent = [...content, objects[i]];\r\n            let generated = LazyMath.combinationArrayDepthNRNO(objects, i + 1, // Go to the next index to get the start of the next element\r\n            offset + 1, // Subgroup gain a start offset of 1\r\n            k, // Just passing k along, it's already align if nothing goes wrong\r\n            depth + 1, // Next depth of the stack\r\n            copyContent // Pass the container of newly packed objets itself for referencing\r\n            ); // Go into nested combinations\r\n            Array.prototype.push.apply(result, generated); // Combine result\r\n        }\r\n        return result; // Return the result\r\n    }\r\n}\r\nexports.LazyMath = LazyMath;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyMath.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyText.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyText.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyText = void 0;\r\n/**\r\n * Shorthand static class for special string functions.\r\n */\r\nclass LazyText {\r\n    /**\r\n     * A shorthand function to extract a certain number of character from a string.\r\n     * @param {string} content The string where we want to extract content from.\r\n     * @param {number} index The index from which we start.\r\n     * @param {number} nbrLetters The number of letters to extract.\r\n     * @returns {string} Return a string of nbrLetters characters if there is that many from a starting point.\r\n     */\r\n    static extract(content, index, nbrLetters) {\r\n        return content.substring(index, index + nbrLetters);\r\n    }\r\n    /**\r\n     * Extract the content from a string starting at a specific index until the predicate is false.\r\n     * @param {string} content The source string from which we get the content to extract.\r\n     * @param {number} startIndex The starting index.\r\n     * @param {(c: string, i: number, txt: string)=>boolean} predicate A function to check if we include the character.\r\n     * @returns {{lastIndex: number, value:string}} An object containing the substring made by following the predicate rule and the last index extracted.\r\n     */\r\n    static extractFromUntil(content, startIndex, predicate) {\r\n        let lastIndex = startIndex;\r\n        for (let i = startIndex; content.length; i++) {\r\n            if (!predicate(content[i], i, content)) {\r\n                break;\r\n            }\r\n            lastIndex = i;\r\n        }\r\n        return {\r\n            value: LazyText.extract(content, startIndex, lastIndex - startIndex),\r\n            lastIndex: lastIndex\r\n        };\r\n    }\r\n    /**\r\n     * Return the number of lines contained inside a string.\r\n     * @param {string} content The string content from which we want to count the lines.\r\n     * @returns {number} The number of lines contained in the string.\r\n     */\r\n    static countLines(content) {\r\n        let line = 1;\r\n        for (let i = 0; i < content.length; i++) {\r\n            if (content[i] === '\\n') {\r\n                line++;\r\n            }\r\n        }\r\n        return line;\r\n    }\r\n    /**\r\n     * Find the number of lines from the start of a string until a specified index, finding the character position of that element on the way.\r\n     * @param {string} content The string we're going to look.\r\n     * @param {number} maxIndex The last index we're going to look.\r\n     * @returns {{lines: number; lineChar: number;}} An object containing the number of lines found and the character position of the last index in it's current line.\r\n     */\r\n    static countLinesChar(content, maxIndex) {\r\n        const result = {\r\n            lines: 1,\r\n            lineChar: 0\r\n        };\r\n        const lastIndex = maxIndex !== null && maxIndex !== void 0 ? maxIndex : content.length - 1;\r\n        for (let i = 0; i <= lastIndex; i++) {\r\n            result.lineChar++;\r\n            if (content[i] === '\\n') {\r\n                result.lines++;\r\n                result.lineChar = 0;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LazyText = LazyText;\r\nLazyText.letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\r\n    'á', 'à', 'ä', 'â',\r\n    'é', 'è', 'ë', 'ê',\r\n    'í', 'ì', 'ï', 'î',\r\n    'ó', 'ò', 'ö', 'ô',\r\n    'ú', 'ù', 'ü', 'û',\r\n    'Ç', 'ç'\r\n];\r\nLazyText.digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\r\nLazyText.variables = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\r\n    '_', '$', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\r\n];\r\nLazyText.controls = ['\\n', '\\t'];\r\nLazyText.whitespaces = [' '];\r\nLazyText.symbols = ['§', '@', '¥', '€', '¬', '&', '|', '#', '^', '*', '$', '%', '±', '=', '+', '-', '*', '/', '\\\\', '<', '>', '~', '°', '_', '`', '´', '¨', '(', ')', '[', ']', '{', '}'];\r\nLazyText.punctuations = ['.', ',', ';', ':', '?', '!', '\"', '\\'', '«', '»', '“', '„'];\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyText.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getType = void 0;\r\n/**\r\n * Get the type of the parameter, extending `typeof` to support `class` and `array` as native options.\r\n * @param {any} parameter The parameter to test.\r\n * @returns {string} The type attributed to the parameter.\r\n */\r\nfunction getType(parameter) {\r\n    if (typeof parameter === 'function' && /^\\s*class\\s+/.test(parameter.toString())) {\r\n        return 'class';\r\n    }\r\n    if (Array.isArray(parameter)) {\r\n        return 'array';\r\n    }\r\n    return typeof parameter;\r\n}\r\nexports.getType = getType;\r\n;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyParsing = void 0;\r\nconst lazyText_1 = __webpack_require__(/*! ../lazyText */ \"./node_modules/@lazy-toolbox/portable/dist/lazyText.js\");\r\nconst lazyPattern_1 = __webpack_require__(/*! ./lazyPattern */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js\");\r\nconst lazyTypeof_1 = __webpack_require__(/*! ../lazyTypeof */ \"./node_modules/@lazy-toolbox/portable/dist/lazyTypeof.js\");\r\n/**\r\n * A more natural way to parse datas with custom rules set in specific testing order.\r\n */\r\nclass LazyParsing {\r\n    /**\r\n     * The constructor of the parser.\r\n     * @param {BasicRule[]} rules The rules to implement into the parser.\r\n     */\r\n    constructor(...rules) {\r\n        this.rules = [];\r\n        this.rules.push(...rules);\r\n    }\r\n    /**\r\n     * Add rules to the parser.\r\n     * @param {BasicRule[]} rules The rules to implement into the parser.\r\n     */\r\n    addRules(...rules) {\r\n        this.rules.push(...rules);\r\n    }\r\n    /**\r\n     * Remove rules from the parser.\r\n     * @param {string[]} rulesName The name of the rules to remove from the parser.\r\n     */\r\n    removeRules(...rulesName) {\r\n        for (const ruleName of rulesName) {\r\n            for (let i = this.rules.length - 1; i >= 0; i--) {\r\n                if (this.rules[i].name && this.rules[i].name === ruleName) {\r\n                    delete this.rules[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Convert a string to an object representation following specific rules.\r\n     * @param {string} text The text to parse.\r\n     * @returns {PatternFound[]} The parsed content.\r\n     */\r\n    parse(text) {\r\n        return LazyParsing.parse(text, LazyParsing.createSet(...this.rules)).result;\r\n    }\r\n    /**\r\n     * Create a set of patterns from a set of rules.\r\n     * @param {BasicRule[]} rules The set of rules to use.\r\n     * @returns {LazyPattern[]} An array of all patterns.\r\n     */\r\n    static createSet(...rules) {\r\n        const result = [];\r\n        for (const pattern of rules) {\r\n            result.push(new lazyPattern_1.LazyPattern(pattern));\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n    * Search every pattern to parse it into an object.\r\n    * @param {string} txtContent The string we're currently parsing.\r\n    * @param {LazyPattern[]} patternSet A list of different pattern to compute.\r\n    * @param {number} i The index with default value to 0. Can be modified for nested searching.\r\n    * @param {(index: number, c: string, text: string) => boolean} endPattern A function to check if a pattern ended.\r\n    * @return {{isPatternEnd: boolean, result: PatternFound[], lastIndex: number}} Return an object representing the value parsed.\r\n    */\r\n    static parse(txtContent, patternSet, i = 0, endPattern = (i, c, t) => { return false; }) {\r\n        var _a;\r\n        const subdivided = []; // A result called subdivided since it's the input subdivided in multiple pieces.\r\n        for (; i < txtContent.length; i++) // Let's navigate the input\r\n         {\r\n            if (endPattern(i, txtContent[i], txtContent)) // We're in a nested pattern that just ended\r\n             {\r\n                return {\r\n                    isPatternEnd: true,\r\n                    result: subdivided,\r\n                    lastIndex: i\r\n                };\r\n            }\r\n            for (let j = 0; j < patternSet.length; j++) // Let's check all the possible patterns\r\n             {\r\n                if (patternSet[j].isActualPattern(i, txtContent[i], txtContent)) // It's the pattern, let's execute something\r\n                 {\r\n                    const lineData = lazyText_1.LazyText.countLinesChar(txtContent, i);\r\n                    const fetchResult = patternSet[j].fetchContent(i, txtContent[i], txtContent, patternSet, patternSet[j]); // Execute something then return the fetched result\r\n                    if (fetchResult.lastIndex !== undefined) {\r\n                        i = fetchResult.lastIndex; // Assign the new index\r\n                    }\r\n                    else {\r\n                        throw new Error('Missing returned lastIndex in a fetch.');\r\n                    }\r\n                    let resultObject = {\r\n                        name: (_a = patternSet[j]) === null || _a === void 0 ? void 0 : _a.name,\r\n                        currentName: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.name,\r\n                        begin: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.begin,\r\n                        end: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.end,\r\n                        nested: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.nested,\r\n                        content: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.content,\r\n                        error: fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.error,\r\n                        line: lineData === null || lineData === void 0 ? void 0 : lineData.lines,\r\n                        lineChar: lineData === null || lineData === void 0 ? void 0 : lineData.lineChar\r\n                    };\r\n                    subdivided.push(resultObject); // Insert an array of 2 elements (name and content) of the tested pattern inside our subdivided variable.\r\n                    break; // No need to check more pattern, we've got one already\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            isPatternEnd: false,\r\n            result: subdivided,\r\n            lastIndex: i - 1\r\n        };\r\n    }\r\n    /**\r\n     * Convert the result of a pattern to a string representation.\r\n     * @param {PatternResult | PatternFound[]} content The parsed content.\r\n     * @param {boolean} spacing If true, the result will be written while taking into account the spacing of every elements.\r\n     * @returns {string} The stringified content of the pattern.\r\n     */\r\n    static toString(content, spacing = false) {\r\n        return LazyParsing.extractString((0, lazyTypeof_1.getType)(content) !== 'array' ? content.result : content, spacing);\r\n    }\r\n    /**\r\n     * Convert the result of a pattern to a string representation with some datas represented.\r\n     * @param {PatternResult | PatternFound[]} content The parsed content.\r\n     * @param spacing If true, the result will be written while taking into account the spacing of every elements.\r\n     * @returns {string} The stringified content of the pattern.\r\n     */\r\n    static toStringDebug(content, spacing = false) {\r\n        return LazyParsing.stringifyParse((0, lazyTypeof_1.getType)(content) !== 'array' ? content.result : content, spacing);\r\n    }\r\n    static generateSpace(d) {\r\n        let spacing = '';\r\n        for (let i = 0; i < d; i++) {\r\n            spacing = `${spacing}    `;\r\n        }\r\n        return spacing;\r\n    }\r\n    static extractString(nodes, spacing = false, depth = 0) {\r\n        const space = spacing ? LazyParsing.generateSpace(depth) : '';\r\n        const lineReturn = spacing ? '\\n' : '';\r\n        let result = '';\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].nested) { // This node is a sub element (an array if nothing goes wrong)\r\n                result = `${result}${space}${nodes[i].begin}${lineReturn}`;\r\n                if (!nodes[i].error) {\r\n                    result = `${result}${LazyParsing.extractString(nodes[i].content, spacing, depth + 1)}${lineReturn}${space}${nodes[i].end}${lineReturn}`;\r\n                }\r\n            }\r\n            else { // It's a string, ez pz let's write it with some spacing\r\n                result = `${result}${space}${nodes[i].content}${lineReturn}`;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static stringifyParse(nodes, spacing = false, depth = 0) {\r\n        const space = spacing ? LazyParsing.generateSpace(depth) : '';\r\n        const lineReturn = spacing ? '\\n' : '';\r\n        let result = '';\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            if (nodes[i].nested) { // This node is a sub element (an array if nothing goes wrong)\r\n                result = `${result}${space}[${nodes[i].name}][Nested]: ${nodes[i].begin}${lineReturn}`;\r\n                if (!nodes[i].error) {\r\n                    result = `${result}${LazyParsing.stringifyParse(nodes[i].content, spacing, depth + 1)}${space}${nodes[i].end}${lineReturn}`;\r\n                }\r\n            }\r\n            else { // It's a string, ez pz let's write it with some spacing\r\n                result = `${result}${space}[${nodes[i].name}]: ${nodes[i].content}${lineReturn}`;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.LazyParsing = LazyParsing;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyPattern = void 0;\r\n/**\r\n * LazyPattern is a generic class made to check for pattern while looking inside a string.\r\n * It fetch it's inner value with the pattern founded and then return it's last index.\r\n */\r\nclass LazyPattern {\r\n    /**\r\n    * Create a pattern object with a bunch of parameters for full customisation.\r\n    * @param {BasicRule} pattern\r\n    */\r\n    constructor(pattern) {\r\n        var _a;\r\n        this._name = (_a = pattern.name) !== null && _a !== void 0 ? _a : \"\";\r\n        this.defaultValue = pattern.defaultValue;\r\n        this.isPattern = pattern.isPattern;\r\n        this.isPatternEnd = pattern.isPatternEnd;\r\n        this.fetch = pattern.fetch;\r\n    }\r\n    /**\r\n    * Get the name of the current pattern.\r\n    */\r\n    get name() {\r\n        return this._name;\r\n    }\r\n    /**\r\n    * Check if we found the pattern.\r\n    * @param {number} i The actual index tested.\r\n    * @param {string} c The actual character tested.\r\n    * @param {string} t The actual text content parsed for special cases.\r\n    * @returns True only if it match the pattern.\r\n    */\r\n    isActualPattern(i, c, t) {\r\n        if (this.isPattern !== undefined && this.isPattern !== null) {\r\n            return this.isPattern(i, c, t);\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * Check if the pattern ended, used to handle nesting.\r\n    * @param {number} i The actual index tested.\r\n    * @param {string} c The actual character tested.\r\n    * @param {string} t The actual text content parsed for special cases.\r\n    * @returns True only if it match the pattern.\r\n    */\r\n    isEndPattern(i, c, t) {\r\n        if (this.isPatternEnd !== undefined && this.isPatternEnd !== null) {\r\n            return this.isPatternEnd(i, c, t);\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * Assign the new content matching the desired pattern then return the last index of the pattern.\r\n    * @param {number} i The actual index tested.\r\n    * @param {string} c The actual character tested.\r\n    * @param {string} t The actual text content parsed for special cases.\r\n    * @param {LazyPattern[]} patternSet The actual text content parsed for special cases.\r\n    * @param {LazyPattern} actualPattern The actual pattern we're testing, used for referencing.\r\n    * @returns An object containing the last index of the pattern and the content to fetch. Content is equal to the default value in case fetch isn't defined.\r\n    */\r\n    fetchContent(i, c, t, patternSet, actualPattern) {\r\n        if (this.fetch !== undefined && this.fetch !== null) {\r\n            return this.fetch(i, c, t, actualPattern.isPatternEnd, patternSet);\r\n        }\r\n        return {\r\n            lastIndex: i,\r\n            content: this.defaultValue\r\n        };\r\n    }\r\n}\r\nexports.LazyPattern = LazyPattern;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/parser/lazyPattern.js?");

/***/ }),

/***/ "./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LazyRule = void 0;\r\nconst lazyParsing_1 = __webpack_require__(/*! ./lazyParsing */ \"./node_modules/@lazy-toolbox/portable/dist/parser/lazyParsing.js\");\r\nconst lazyText_1 = __webpack_require__(/*! ../lazyText */ \"./node_modules/@lazy-toolbox/portable/dist/lazyText.js\");\r\n/**\r\n * A generic rule maker. It creates rules for LazyParsing.\r\n */\r\nclass LazyRule {\r\n    /**\r\n     * A basic pattern to extract a specific character.\r\n     * @param {string} name Name of the pattern.\r\n     * @param {(c:string) => boolean} predicate The function to test the character.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static simpleChar(name, predicate) {\r\n        return {\r\n            name: name,\r\n            defaultValue: null,\r\n            isPattern: (i, c, txt) => { return predicate(c); },\r\n            fetch: (index, c, txt) => {\r\n                return { name: name, content: c, lastIndex: index };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern to extract a specific string.\r\n     * @param {string} name Name of the pattern.\r\n     * @param {string} extractString The function to test the string.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static simpleKeys(name, ...extractStrings) {\r\n        return {\r\n            name: name,\r\n            defaultValue: null,\r\n            isPattern: (i, c, txt) => {\r\n                for (let extracted of extractStrings) {\r\n                    if (txt.substring(i, i + extracted.length) === extracted) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                let result = {\r\n                    name: name,\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                for (let extracted of extractStrings) {\r\n                    if (txt.substring(index, index + extracted.length) === extracted) {\r\n                        result.content = txt.substring(index, index + extracted.length);\r\n                        result.lastIndex = index + extracted.length - 1;\r\n                        break;\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic charbox that will contain the nested in-between string content.\r\n     * @param {string} name The name of the charbox.\r\n     * @param {string} begin The string that begin the charbox.\r\n     * @param {string} end The string that end the charbox.\r\n     * @param {LazyPattern[] | undefined} overridePatternSet An override to use new rules inside the charbox.\r\n     * @param {(i: number, c: string, txt: string) => boolean | undefined} overrideIsPatternEnd An override to use a new end pattern to handle special cases.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static simpleCharbox(name, begin, end, overridePatternSet, overrideIsPatternEnd) {\r\n        return {\r\n            name: name,\r\n            defaultValue: begin,\r\n            begin: begin,\r\n            end: end,\r\n            isPattern: (i, c, txt) => { return txt.substring(i, i + begin.length) === begin; },\r\n            isPatternEnd: (i, c, txt) => {\r\n                if (overrideIsPatternEnd) {\r\n                    return overrideIsPatternEnd(i, c, txt);\r\n                }\r\n                return txt.substring(i, i + end.length) === end;\r\n            },\r\n            fetch: (index, c, txt, endPattern, patternSet) => {\r\n                const p = lazyParsing_1.LazyParsing.parse(txt, overridePatternSet ? (overridePatternSet.length == 0 ? (patternSet !== null && patternSet !== void 0 ? patternSet : []) : overridePatternSet) : (patternSet !== null && patternSet !== void 0 ? patternSet : []), index + begin.length, overrideIsPatternEnd !== null && overrideIsPatternEnd !== void 0 ? overrideIsPatternEnd : endPattern); // Let's look for nested pattern over here..\r\n                // We could filter patternSet if we wanted to get rid of some functions for this case or use whatever we want anyway.\r\n                if (p.isPatternEnd) // It's the end of our pattern\r\n                 {\r\n                    return {\r\n                        name: name,\r\n                        content: p.result,\r\n                        error: false,\r\n                        nested: true,\r\n                        begin: begin,\r\n                        end: end,\r\n                        lastIndex: p.lastIndex + end.length - 1\r\n                    }; // Return what we got\r\n                }\r\n                else // Something went wrong with brackets (user input) since it was never closed.\r\n                 {\r\n                    return {\r\n                        name: name,\r\n                        content: begin,\r\n                        nested: true,\r\n                        error: true,\r\n                        begin: begin,\r\n                        end: end,\r\n                        lastIndex: index\r\n                    };\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract words. Words can only be made with letters.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static word() {\r\n        return {\r\n            name: 'word',\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => { return lazyText_1.LazyText.letters.includes(c); },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'word',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                for (let i = index; i < txt.length; i++) {\r\n                    if (!lazyText_1.LazyText.letters.includes(txt[i])) { // Not a letter?\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                }\r\n                result.content = txt.substring(index, result.lastIndex + 1);\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract numbers. The number can only be written in the form `125` or either `1.2123` if `comaOverDot = false` otherwise `1,2123`.\r\n     * @param {boolean} comaOverDot If true, numbers must be written as \"x,y\" instead of \"x.y\".\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static number(comaOverDot = false, exp = false) {\r\n        let dot = comaOverDot ? ',' : '.';\r\n        return {\r\n            name: 'number',\r\n            defaultValue: 0,\r\n            isPattern: (i, c, txt) => {\r\n                const isDecimal = c === dot && lazyText_1.LazyText.digits.includes(lazyText_1.LazyText.extract(txt, i + 1, 1));\r\n                return lazyText_1.LazyText.digits.includes(c) || isDecimal;\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'number',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                let alreadyDecimal = false;\r\n                let isExp = false;\r\n                for (let i = index; i < txt.length; i++) {\r\n                    if (!lazyText_1.LazyText.digits.includes(txt[i])) // Not a digit?\r\n                     {\r\n                        if (txt[i] === 'e' && exp && !isExp) {\r\n                            isExp = true;\r\n                            if (\r\n                            // e+D || e-D || eD\r\n                            (i + 2 < txt.length && (txt[i + 1] === '+' || txt[i + 1] === '-') && lazyText_1.LazyText.digits.includes(txt[i + 2]))\r\n                                || (i + 1 < txt.length && lazyText_1.LazyText.digits.includes(txt[i + 1]))) {\r\n                                result.content = `${result.content}${txt[i]}${txt[i + 1]}`;\r\n                                result.lastIndex = ++i; // Assign the last index\r\n                                continue;\r\n                            }\r\n                            else { // Is not an exponent ! => e?\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!alreadyDecimal && txt[i] === dot) // It's decimal number\r\n                         {\r\n                            alreadyDecimal = true; // We defined it as decimal to skip problems in case of multiple decimal marks\r\n                            if (result.content.length == 0) // .5 as example\r\n                             {\r\n                                result.content = `0.`; // 0.5 now\r\n                            }\r\n                            else {\r\n                                result.content = `${result.content}.`; // xxx.yyy\r\n                            }\r\n                            result.lastIndex = i; // Assign the last index\r\n                            continue;\r\n                        }\r\n                        result.lastIndex = i - 1; // Since this index is something we shouldn't bother with, let him tested by something else\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                    result.content = `${result.content}${txt[i]}`;\r\n                }\r\n                result.content = result.content; // Type hack\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract a variable name. The variable name must be composed of only letters and underscores.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static variable() {\r\n        return {\r\n            name: 'variable',\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => {\r\n                return lazyText_1.LazyText.letters.includes(c) || (c === '_'); // begin with _\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'variable',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                for (let i = index; i < txt.length; i++) {\r\n                    if (!lazyText_1.LazyText.letters.includes(txt[i]) && txt[i] !== '_') // Not a letter and not underscore\r\n                     {\r\n                        result.lastIndex = i - 1; // Since this index is something we shouldn't bother with, let him tested by something else\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                }\r\n                result.content = txt.substring(index, result.lastIndex + 1);\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic rule to extract keywords. They must begin by a letter or an underscore and can only contains letters or underscores.\r\n     * @param {string[]} keywordList A list of keywords.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static keyword(...keywordList) {\r\n        return {\r\n            name: 'keyword',\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => {\r\n                const sizeLeft = txt.length - i;\r\n                for (const keyword of keywordList) {\r\n                    if (keyword.length <= sizeLeft) {\r\n                        const currentContent = txt.substring(i, i + keyword.length);\r\n                        if (currentContent === keyword) { // Probably keyword\r\n                            const currentNextIndex = i + keyword.length;\r\n                            if (!(currentNextIndex < txt.length && (lazyText_1.LazyText.letters.includes(txt[currentNextIndex]) || txt[currentNextIndex] === '_'))) {\r\n                                // Definitly keyword\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: 'keyword',\r\n                    content: '',\r\n                    lastIndex: index\r\n                };\r\n                const sizeLeft = txt.length - index;\r\n                for (let keyword of keywordList) {\r\n                    if (keyword.length <= sizeLeft) {\r\n                        const currentContent = txt.substring(index, index + keyword.length);\r\n                        if (currentContent === keyword) { // Probably keyword\r\n                            const currentNextIndex = index + keyword.length;\r\n                            if (!(currentNextIndex < txt.length && (lazyText_1.LazyText.letters.includes(txt[currentNextIndex]) || txt[currentNextIndex] === '_'))) {\r\n                                // Definitly keyword\r\n                                result.content = currentContent;\r\n                                result.lastIndex = currentNextIndex - 1;\r\n                                return result;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern to extract any character without exception.\r\n     * @param {string} name Name of the rule.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static any(name) {\r\n        return {\r\n            name: name,\r\n            defaultValue: null,\r\n            isPattern: (i, c, txt) => true,\r\n            fetch: (index, c, txt) => {\r\n                return { name: name, content: c, lastIndex: index };\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern to extract a string like syntax. It will work the same as c/c++/c#/js/java/... string. So whatever is your `between` value, if it's \"\\\\myStringValue\", it will be escaped.\r\n     * @param {string} name Name of the rule.\r\n     * @param {string} between The string container. If between = '\"', then it will parse a string the same way js does.\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static parseString(name, between) {\r\n        return {\r\n            name: name,\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => txt.substring(i, i + between.length) === between,\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: name,\r\n                    content: '',\r\n                    error: false,\r\n                    lastIndex: index\r\n                };\r\n                let isOut = false;\r\n                for (let i = index + between.length; i < txt.length; i++) {\r\n                    if (txt[i] === \"\\\\\") { // is anti-slash\r\n                        i++;\r\n                        result.lastIndex = i; // Assign the last index\r\n                        continue; // Skip next iteration\r\n                    }\r\n                    else if (txt.substring(i, i + between.length) === between) {\r\n                        isOut = true;\r\n                        break;\r\n                    }\r\n                    result.lastIndex = i; // Assign the last index\r\n                }\r\n                if (isOut) {\r\n                    result.content = txt.substring(index + between.length, result.lastIndex + 1);\r\n                    result.lastIndex = result.lastIndex + between.length;\r\n                }\r\n                else {\r\n                    result.error = true;\r\n                    result.lastIndex = index + between.length;\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * A basic pattern rule to test a regex. Note: when you write your regex, think like you're at the start of the string for the test.\r\n     * @param {string} name Name of the rule.\r\n     * @param {RegExp} regex The regex\r\n     * @returns {BasicRule} Return a rule.\r\n     */\r\n    static regex(name, regex) {\r\n        let regExpResult;\r\n        return {\r\n            name: name,\r\n            defaultValue: '',\r\n            isPattern: (i, c, txt) => {\r\n                const result = regex.exec(txt.slice(i));\r\n                if (result && result.index == 0) {\r\n                    regExpResult = result;\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            },\r\n            fetch: (index, c, txt) => {\r\n                const result = {\r\n                    name: name,\r\n                    content: txt.substring(index, index + regExpResult[0].length),\r\n                    lastIndex: index + regExpResult[0].length - 1\r\n                };\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n}\r\nexports.LazyRule = LazyRule;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./node_modules/@lazy-toolbox/portable/dist/parser/lazyRule.js?");

/***/ }),

/***/ "./src/db/database.ts":
/*!****************************!*\
  !*** ./src/db/database.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Database = void 0;\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst ghosts_1 = __webpack_require__(/*! ./ghosts */ \"./src/db/ghosts.ts\");\r\nclass Database {\r\n    static getEvidences() {\r\n        var _a;\r\n        const allEvidences = document.querySelectorAll(\".evidenceInput\");\r\n        const result = {};\r\n        for (const evidence of allEvidences) {\r\n            result[(_a = evidence.getAttribute('id')) !== null && _a !== void 0 ? _a : ''] = client_1.LazyTristate.stateToString(evidence.value);\r\n        }\r\n        return result;\r\n    }\r\n    static getEvidencesByValue(value) {\r\n        const result = [];\r\n        const evidences = Database.getEvidences();\r\n        for (const evidence in evidences) {\r\n            const evidenceValue = evidences[evidence];\r\n            if (evidenceValue === value) {\r\n                result.push(evidence);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.Database = Database;\r\nDatabase.ghostDB = (0, ghosts_1.GHOST_DATABASE)();\r\nDatabase.evidenceIcons = {\r\n    'dots': 'dots-projector.webp',\r\n    'emf-5': 'emf-reader.webp',\r\n    'fingerprints': 'fingerprints.webp',\r\n    'freezing-temperatures': 'thermometer.webp',\r\n    'ghost-orb': 'ghost-orb.webp',\r\n    'ghost-writing': 'writing-book.webp',\r\n    'spirit-box': 'spirit-box.webp'\r\n};\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/db/database.ts?");

/***/ }),

/***/ "./src/db/ghosts.ts":
/*!**************************!*\
  !*** ./src/db/ghosts.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GHOST_DATABASE = void 0;\r\nconst GHOST_DATABASE = (ghostSpeed = '100', difficultyMultiplier = 1.0) => {\r\n    return {\r\n        'banshee': {\r\n            name: 'Banshee',\r\n            evidences: [\r\n                'dots',\r\n                'fingerprints',\r\n                'ghost-orb'\r\n            ],\r\n            strenght: \"Ne s'attaque qu'à une victime à la fois.\",\r\n            weakness: \"Ses cris s'entendent au microphone parabolique.\",\r\n            description: \"La sirène qui chante, connue pour attirer ses victimes à travers ses chants. Elle est connue pour isoler sa proie avant de mettre le coup fatal.\",\r\n            ability: \"<p>Elle choisie une cible au début du jeu et ne changera de cible que si cette dernière meurt (ou quitte la partie).</p>\",\r\n            behaviour: `\r\n                <p>Elle a 33% de chance de faire un son paranormal unique lorsque le <strong class=\"italic\">microphone parabolique</strong> est utilisé.</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/banshee-scream.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>Lorsqu'elle décide d'èrer, si la cible est dans la zone d'investigation, il y a 66% de chance qu'elle ère dans la direction de sa cible, s'arrêtant sur sa cible si possible.</p>\r\n                <p>Elle préfère causer des événements où elle chante. Si elle fait un événement fantômatique où elle chante, que l'événement soit dirigé vers sa cible et que sa cible la fait disparaître prématurément en la touchant, alors il perdra 15% de santé mentale au lieu de 10%.</p>\r\n            `,\r\n            hunt: `\r\n                <p>La chasse est basée sur la santé mentale de la cible de la Banshee, ainsi une chasse sera démarrée si sa cible est en dessous de 50% de santé mentale. Ça signifie qu'une chasse peut débuter entre 87,5% et 12,5% de santé mentale moyenne.</p>\r\n                <p>Tous les joueurs, autres que sa cible, seront ignorés durant une chasse. Si une chasse démarre sans sa cible présente dans la zone d'investigation, elle chassera comme les autres fantômes.</p>\r\n                <p>L'objectif <strong class=\"italic\">\"repousser le fantôme lorsqu'il chasse quelqu'un\"</strong> n'est pas possible avec de <strong class=\"italic\">l'encent</strong> (à moins qu'elle ne chasse sa cible lorsque ça se produit).</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'demon': {\r\n            name: 'Démon',\r\n            evidences: [\r\n                'fingerprints',\r\n                'freezing-temperatures',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Ils chassent plus souvent que les autres entités.\",\r\n            weakness: \"L'effet du crucifix est accrus contre eux jusqu'à 5 mètres.\",\r\n            description: \"Un démon est l'une des pires entités que l'on puisse rencontrer. Il est connu pour attaquer sans raison.\",\r\n            ability: \"<p>Il peut décider de démarrer une chasse quand il le désire.</p>\",\r\n            behaviour: \"<p>La portée du <strong class=\\\"italic\\\">crucifix</strong> est de 5 mètres pour lui (au lieu de 3 mètres pour les autres).</p>\",\r\n            hunt: `\r\n                <p>Il peut démarrer des chasses dès que la santé moyenne de l'équipe est en dessous de 70%.</p>\r\n                <p>Le Démon peut démarrer une chasse toutes les 20 secondes (contrairement aux autres entités peuvent démarrer une chasse toutes les 25 secondes).</p>\r\n                <p>Si l'encent est employé sur le démon, son temps avant de pouvoir relancer une chasse est de 60 secondes au lieu de 90 secondes.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 100\r\n        },\r\n        'deogen': {\r\n            name: 'Deogen',\r\n            evidences: [\r\n                'dots',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strongEvidence: 'spirit-box',\r\n            strenght: \"Ils sentent constamment les vivants durant une chasse et avancent rapidement vers leurs positions.\",\r\n            weakness: \"Ils avancent lentement quand ils voient leurs victimes.\",\r\n            description: \"Parfois entourés d'un brouillard sans fin, les Deogen ont échappé aux chasseurs de fantômes pendant des années. Les rapports indiquent que ces entités trouvent même leurs proies les mieux cachés, avant de les harcelées jusqu'à l'épuisement.\",\r\n            ability: \"<p>Il connaît la position de tous les joueurs.</p>\",\r\n            behaviour: `\r\n                <p>Il a 33% de chance par question de produire une réponse unique à la <strong class=\"italic\">Spirit Box </strong> lorsque le joueur est situé à 1 mètre de ce dernier: une respiration lourde et constante durant 3 à 4 secondes.</p>\r\n                <audio controls id=\"deogen-breath\" class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/deogen-breath.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            hunt: `\r\n                <p>Il ne peut démarrer une chasse que lorsque la santé mentale est en dessous de 40%.</p>\r\n                <p>Lors du début d'une chasse, il ira vers le joueur le plus proche de lui. Il peut occasionnellement choisir un joueur au hasard.</p>\r\n                <p>Durant une chasse, sa vitesse est déterminée par la distance qui le sépare du joueur (2.5 à 6 mètres de distance). Au plus le joueur est loin, au plus il sera rapide.</p>\r\n                <p>Si il est à plus de 6 mètres, il avancera à 3 m/s et si il est à moins de 2.5 mètres, alors il avancera à 0.4 m/s. Sa vitesse entre les deux distances ralentie au plus il s'approche du joueur.</p>\r\n                <p>Il clignotte plus rapidement ; il est visible durant de plus long intervales et/ou il est invisible durant de plus court intervales.</p>\r\n                <p>Si on utilise l'encent contre lui ou qu'il ne chasse pas d'autres joueurs, sa vitesse restera constante, où sera de 1.6 m/s si sa vitesse actuelle est supérieur à 3 m/s.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse proche d'une victime :</strong> ${difficultyMultiplier * 0.4} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/0.40.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Vitesse loin d'une victime :</strong> ${difficultyMultiplier * 3} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/3.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 40\r\n        },\r\n        'goryo': {\r\n            name: 'Goryo',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'fingerprints'\r\n            ],\r\n            strongEvidence: 'dots',\r\n            strenght: \"Ses interactions avec le projecteur D.O.T.S. ne sont visible qu'au travers une caméra.\",\r\n            weakness: \"Tends à rester dans sa pièce.\",\r\n            description: \"Lorsqu'un Goryo passe à travers un projecteur D.O.T.S., employer une caméra est le seul moyen pour le voir.\",\r\n            ability: `<p>Rien à signaler.</p>`,\r\n            behaviour: `\r\n                <p>Il ne peut erré que jusqu'à 5 mètres de distance, au lieu des 10 mètres maximum pour les autres fantômes.</p>\r\n                <p>Il ne peut pas changer sa pièce favorite.</p>\r\n                <p>Il ne réagit aux <strong class=\"italic\">D.O.T.S.</strong> que si aucun joueur n'est dans sa pièce.</p>\r\n                <p>Aussi, sa silhouette au <strong class=\"italic\">Projecteur D.O.T.S.</strong> n'est visible qu'au travers la caméra et n'est donc pas visible à l'oeil nu.</p>\r\n                <p>Dans quelques rares cas, il est possible de le voir avec les yeux en étant dans la même pièce: si il ère dans une pièce adjacente, il peut interagir avec le <strong class=\"italic\">Projecteur D.O.T.S.</strong>.</p>\r\n            `,\r\n            hunt: `<p>Rien à signaler.</p>`,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'hantu': {\r\n            name: 'Hantu',\r\n            evidences: [\r\n                'fingerprints',\r\n                'freezing-temperatures',\r\n                'ghost-orb'\r\n            ],\r\n            strongEvidence: 'freezing-temperatures',\r\n            strenght: \"Il avance plus rapidement dans les températures les plus basses.\",\r\n            weakness: \"Les températures les plus élevées le font ralentir.\",\r\n            description: \"Le Hantu est une entitée rare qui apprécie les climats les plus froids. Le froid tends à les rendres plus aggressif et puissant.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il ne peut pas allumer le fusible.</p>\r\n                <p>Il peut éteindre le fusible deux fois plus souvent.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Sa vitesse dépends de la température autour de lui. Lorsque le fusible est branché, il sera en conséquent plus lent parce que la maison sera chauffée.</p>\r\n                <p>Il n'accélère pas si on le garde en ligne de vue.</p>\r\n                <p>Lorsque le Hantu est visible lors d'une chasse, il émet une respiration glacée au niveau de sa tête et ce dans toutes les pièces tant que le disjoncteur est éteint (Les joueurs décédés ne peuvent pas voir ce souffle).</p>\r\n                <p>Il est conseillé de ne pas le faire tourner trop longtemps autour de fourniture lorsque la pièce est chaude puisque la simple présence du Hantu suffit à faire baisser la température et donc lui augmente sa vitesse au fur et à mesure.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse dépendante de la <strong class=\"italic\">température</strong> :</strong></p>\r\n                <p>• <strong>inférieur à 3°C :</strong> ${difficultyMultiplier * 2.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>• <strong>entre 3 - 6°C :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>• <strong>entre 6 - 9°C :</strong> ${difficultyMultiplier * 2.3} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.30.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>• <strong>entre 9 - 12°C :</strong> ${difficultyMultiplier * 2.1} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.10.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>• <strong>entre 12 - 15°C :</strong> ${difficultyMultiplier * 1.75} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.75.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p>• <strong>supérieur à 15°C :</strong> ${difficultyMultiplier * 1.4} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.40.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'jinn': {\r\n            name: 'Djinn',\r\n            evidences: [\r\n                'emf-5',\r\n                'fingerprints',\r\n                'freezing-temperatures'\r\n            ],\r\n            strenght: \"Il avance à plus grande vitesse lorsque sa victime s'éloigne.\",\r\n            weakness: \"Il ne peut pas utiliser son abilité si le courant est coupé.\",\r\n            description: \"Un Djinn est une entitée territorial qui attaque quand il est menacé. Il est également connu pour se déplacer à une vitesse signifiante.\",\r\n            ability: `\r\n                <p>Si le fusible est branché, il peut utiliser son abilité qui réduit de 25% la santé mentale de tous les joueurs présent dans la même pièce ou aux environs de 3 mètres de lui et génère au fusible un <strong class=\"italic\">EMF 2</strong> ou <strong class=\"italic\">EMF 5</strong> si la santé mentale d'un joueur a été drainée.</p>\r\n                <p>En laissant un <strong class=\"italic\">EMF</strong> au niveau du fusible, si il capte quelque chose mais que le fusible ne s'est jamais allumé ou éteint, alors il est fort probable que ce soit le Jinn.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il ne peut pas éteindre le fusible, seulement le faire sauter en allumant une lampe de trop.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si il voit un joueur, il avance jusqu'au joueur à une vitesse de 2,5 m/s instantanément jusqu'à ce qu'il soit à environs 2 mètres du joueur avant d'avancer à sa vitesse de base.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s (instantané)</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'mare': {\r\n            name: 'Cauchemar',\r\n            evidences: [\r\n                'ghost-orb',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Attaque plus souvent dans le noir.\",\r\n            weakness: \"Allumer la lumière réduit les chances qu'il attaque.\",\r\n            description: \"Le Cauchemar est la source de tous les cauchemars, le rendant plus puissant dans la pénombre.\",\r\n            ability: \"<p>Rien à signaler.</p>\",\r\n            behaviour: `\r\n                <p>Si on allume une lampe près de lui, il a une chance de l'éteindre presque immédiatement. Ça s'applique également aux télévisions et ordinateurs.</p>\r\n                <p>Il n'allume jamais de lampe. Si il décide d'erré, il choisira plus souvent des pièces qui ne sont pas éclairées.</p>\r\n                <p>Il fait plus souvent des événements où il explose des ampoules.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si les lampes sont éteintes, il peut déclancher une chasse à partir de 60% de santé mentale. Dans le cas contraire, ce sera à partir de 40%.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 60\r\n        },\r\n        'moroi': {\r\n            name: 'Moroï',\r\n            evidences: [\r\n                'freezing-temperatures',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strongEvidence: 'spirit-box',\r\n            strenght: \"Il avance relativement plus vite lorsque les enquêteurs ont peu de santé mentale. Ils peuvent également faire perdre la santé mentale des enquêteurs plus rapidement qu'usuellement durant une enquête.\",\r\n            weakness: \"L'encent les aveugles plus longtemps durant les chasses.\",\r\n            description: \"Le Moroï est sorti de sa tombe pour absorber l'énergie des vivants. Ils sont connu pour placer des malédictions sur leurs victimes, curable uniquement par antidotes ou en partant au loin.\",\r\n            ability: `\r\n                <p>Si un joueur obtient une réponse à la <strong class=\"italic\">Spirit Box</strong> où entends un bruit au <strong class=\"italic\">microphone parabolique</strong>, il maudira ce joueur tant qu'il restera dans la zone d'investigation (la lumière n'a aucune importance). Il est possible d'être maudit plusieurs fois mais pas d'accumuler la malédiction.</p>\r\n                <p>On peut briser la malédiction en prenant des <strong class=\"italic\">pillules</strong>.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Il devient plus rapide au plus la santé mentale est basse. Entre 1,5 m/s avec une santé mentale moyenne de 50% et 2,25 m/s à 0%. Il y a une augmentation de sa vitesse de 0.075 m/s pour chaque 5% de santé mentale perdue.</p>\r\n                <p>Si on utilise <strong class=\"italic\">l'encent</strong>, la durée durant laquelle il ne peut pas voir est de 12 secondes (au lieu des 6 usuelles).</p>\r\n                <p>Il accélère lorsqu'il est vu par le joueur. A sa vitesse maximum, il est plus rapide qu'un Revenant.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> entre ${difficultyMultiplier * 1.5} et ${difficultyMultiplier * 2.25} m/s</p>\r\n                <p><strong>${difficultyMultiplier * 1.5} :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>${difficultyMultiplier * 2.25} :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.25.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.25} et ${difficultyMultiplier * 3.71} m/s</p>\r\n                <p><strong>${difficultyMultiplier * 3.71} :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/3.71.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'myling': {\r\n            name: 'Myling',\r\n            evidences: [\r\n                'emf-5',\r\n                'fingerprints',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Ses pas sont plus silencieux lorsqu'il chasse.\",\r\n            weakness: \"Produit des sons paranormaux plus fréquement.\",\r\n            description: \"Le Myling est une entitée très vocale et active. Il y a des rumeurs comme quoi ils sont silencieux lorsqu'ils chassent leurs proies.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il émet beaucoup plus de son paranormal que les autres entités au <strong class=\"italic\">microphone parabolique</strong>.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Le son de ses pas ne s'entends que s'il se situe à une distance d'environs 12 mètres.</p>\r\n                <p>La distance audible des pas d'un Myling lors d'une chasse est perceptible plus ou moins lorsqu'il commence à interférer avec l'électronique.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'obake': {\r\n            name: 'Obake',\r\n            evidences: [\r\n                'emf-5',\r\n                'fingerprints',\r\n                'ghost-orb'\r\n            ],\r\n            strongEvidence: 'fingerprints',\r\n            strenght: \"Ils peuvent laisser des empruntes qui disparaissent rapidement.\",\r\n            weakness: \"Il laisse parfois une emprunte à six doigts.\",\r\n            description: \"Les Obakes sont terrifiant au changement de corps, capable de prendre bien des formes. Ils ont été vu prendre une forme humanoïde pour attirer leurs proies.\",\r\n            ability: `\r\n                <p>Il peut occasionnellement utiliser son abiliter qui réduit le temps d'existence des <strong class=\"italic\">empruntes</strong> sur la map de moitié (il peut aussi l'utiliser plusieurs fois de suite, réduisant drastiquement le temps de vie des <strong class=\"italic\">empruntes</strong>).</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Lorsqu'il interagit avec une surface, il a 75% de chance de laisser une <strong class=\"italic\">emprunte</strong> (au lieu des 100% usuel).</p>\r\n                <p>Il y a 16,7% de chance qu'il crée une <strong class=\"italic\">emprunte</strong> unique:</p>\r\n                <p>• Une trace de main à six doigts.</p>\r\n                <p>• Deux empruntes de doigts sur un interrupteur au lieu d'une seule.</p>\r\n                <p>• Cinq traces de doigts sur le clavier ou les portes de prison au lieu de quatre.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Il a 6.66% de chance à chaque fois qu'il clignotte de changer sa forme en une autre entité puis de reprendre sa forme originel. C'est garanti d'avoir lieu au moins une fois par chasse (les joueurs décédés ne peuvent pas le voir).</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'oni': {\r\n            name: 'Oni',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'freezing-temperatures'\r\n            ],\r\n            strenght: \"Augmentation des activités et des événements fantômatiques.\",\r\n            weakness: \"L'augmentation des activités des Onis les rends plus aisés à trouver.\",\r\n            description: \"Les Onis aiment effrayer leurs victimes autant que possible avant d'attaquer. Ils sont souvent vu dans une forme physique, gardant le lieu de leur décès.\",\r\n            ability: `\r\n                <p>Il draine le double de la santé mentale (20%) par rapport aux autres fantômes (10%) lorsqu'on le touche lors d'un événement fantômatique.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il est très actif et interagit plus souvent avec les objets, surtout si il y a des joueurs dans sa pièce.</p>\r\n                <p>Il peut se manifester entièrement durant un événement.</p>\r\n                <p>Il est incapable de produire l'événement de type \"ballon d'air\". Ainsi, on peut retirer l'Oni si l'on entends le son :</p>\r\n                <audio controls id=\"sound-air-breath\" class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/air-breath.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            hunt: `\r\n                <p>Il peut être vu plus longtemps lorsqu'il chasse.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'onryo': {\r\n            name: 'Onryo',\r\n            evidences: [\r\n                'freezing-temperatures',\r\n                'ghost-orb',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Une flamme qui s'éteint peu provoquer l'attaque d'un Onryo.\",\r\n            weakness: \"La présence des flammes réduit l'abilité de l'Onryo à attaquer.\",\r\n            description: \"L'Onryo est souvent référer en tant qu' « Esprit vengeur ». Ils volent les âmes des de ses victimes mourrantes pour se venger. Cette entité est connue pour être effrayée du feu, et fera tout en son pouvoir pour s'en éloigner.\",\r\n            ability: `\r\n                <p>Si une <strong class=\"italic\">bougie</strong>, un <strong class=\"italic\">briquet</strong> ou un feu de camp est éteint par ce dernier, on considère qu'il éteint une flamme.</p>\r\n                <p>L'Onryo possède un compteur de flamme éteinte (qui ne vaut que pour celles qu'il éteint lui-même).</p>\r\n                <p>Il peut éteindre deux flammes puis, lorsqu'il en éteindra une troisième, le compteur se réinitialisera et il aura une probabilité de 50% de démarrer une chasse.</p>\r\n                <p>En multijoueur, la probabilité qu'il démarre une chasse lorsqu'il éteint la troisième flamme est accue de 25% par joueur décédé.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il a une plus haute chance que les autres fantômes d'éteindre une <strong class=\"italic\">bougie</strong>.</p>\r\n                <p>Si une flamme est proche de lui, elle agit tel un <strong class=\"italic\">crucifix</strong>, l'empéchant de chasser à une distance de 4 mètres.</p>\r\n                <p>Plusieurs situations particulières peuvent avoir lieu en conséquence de son comportement et son abilité :</p>\r\n                <p>• Une <strong class=\"italic\">bougie</strong> et un <strong class=\"italic\">crucifix</strong> sont à portée de l'Oryo, et il éteint la <strong class=\"italic\">bougie</strong>. Les 50% de chances réussissent mais suite à la présence du <strong class=\"italic\">crucifix</strong>, la chasse n'a pas lieu.</p>\r\n                <p>• Deux <strong class=\"italic\">bougies</strong> sont à portée de l'Onryo et il en éteint l'une d'entre elles. Les 50% de chances réussissent mais comme il y a une autre <strong class=\"italic\">bougie</strong>, la chasse n'a pas lieu.</p>\r\n                <p>• Une <strong class=\"italic\">bougie</strong> est à portée de l'Onryo et il tente de chasser naturellement. La <strong class=\"italic\">bougie</strong> s'éteindra et la chasse n'aura pas lieu.</p>\r\n                <p> <strong class=\"italic\">Remarque:</strong> Il peut y avoir jusqu'à 6 secondes de délais avant le début de l'initialisation de la chasse.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Il peut démarrer une chasse dès que la santé mentale est en dessous de 60%.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 60\r\n        },\r\n        'phantom': {\r\n            name: 'Fantôme',\r\n            evidences: [\r\n                'dots',\r\n                'fingerprints',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Regarder un fantôme fait perdre considérablement la santé mentale.\",\r\n            weakness: \"Prendre une photo d'un fantôme le fait disparaître brièvement.\",\r\n            description: \"Un fantôme est une entitée qui peut posséder le vivant, instaurant la peur à quiconque auprès de lui. Ils sont communément invoqués depuis une Ouija.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Si il est prit en photo durant un événement, il disparaît temporairement pour le reste de l'événement mais le son de son événement continue. Les interférences cessent et il ne sera pas visible sur la photo.</p>\r\n                <p>Être aux environs de 10 mètres d'un fantôme en étant en ligne de vue de ce dernier réduit la santé mentale de ~0.5% par seconde.</p>\r\n                <p>Il peut choisir un joueur au hasard et marcher vers ce dernier créant un <strong class=\"italic\">EMF 2</strong> à la position où il a débuter son érrance.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si il est prit en photo durant une chasse, il ne sera pas visible sur la photo.</p>\r\n                <p>Le fantôme clignotte environs toutes les 1  ~ 2s comparé aux autres qui ont 0.3 ~ 1s de délais.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'poltergeist': {\r\n            name: 'Poltergeist',\r\n            evidences: [\r\n                'fingerprints',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Capable de lancer plusieurs objets en une fois.\",\r\n            weakness: \"Il deviennent impuissant sans rien autour d'eux.\",\r\n            description: \"L'une des entités les plus connues, le Poltergeist. Connu pour manipulater les objets autour de lui pour instaurer la peur en ses victimes.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il peut occasionnellement lancer de multiples objets d'un coup, créant un <strong class=\"italic\">EMF 3</strong>. Les objets sont lancés avec plus de force que tous les autres fantômes (une force de 2 ~ 6 par opposition aux autres fantômes ayant une force de 1 ~ 3).</p>\r\n                <p>La santé mentale est réduite de 2% pour chaque objet lancé.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Pendant une chasse, lance un objet toutes les 0,5 secondes si il y en a un à sa proximité contrairement aux autres entités qui n'ont que 50% de chance d'en lancer toutes les 0,5 secondes.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'raiju': {\r\n            name: 'Raiju',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'ghost-orb'\r\n            ],\r\n            strenght: \"Il avance rapidement près des objets électroniques.\",\r\n            weakness: \"Il brouille l'équipement électronique de plus loin lorsqu'il chasse.\",\r\n            description: \"Un Raiju est un démon qui se courrit du courant électrique. Généralement calme, ils peuvent commencer à s'agiter quand ils sont submergés de puissance.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Lors d'un événement, il interagit avec l'électronique dans un rayon de 15 mètres (au lieu de 10 mètres pour les autres entités).</p>\r\n            `,\r\n            hunt: `\r\n                <p>Lorsqu'un objet électronique est à porté, il peut démarré une chasse dès 65% de santé mentale, sinon il ne pourra que dès 50%.</p>\r\n                <p>Suivant la taille de la map, si il est dans la portée d'une pièce d'équipement électronique, sa vitesse sera de 2,5 m/s:</p>\r\n                <p>• 6 mètres sur une petite map.</p>\r\n                <p>• 8 mètres sur une map moyenne.</p>\r\n                <p>• 10 mètres sur une grande map.</p>\r\n                <p>Ces effets s'appliquent sur l'équipement au sol et tenu dans les mains.</p>\r\n                <p>Ne sont pas comptés à l'accélération de la vitesse :</p>\r\n                <p>• La caméra frontale</p>\r\n                <p>• Les caméras et appareils photos jetés au sol</p>\r\n                <p>• Les <strong class=\"italic\">capteurs de mouvements</strong>, les <strong class=\"italic\">capteurs sonores</strong> et les projecteurs <strong class=\"italic\">D.O.T.S.</strong> jetés au sol ou tenu en main.</p>\r\n                <p>• Les objets dans l'inventaire (sauf la <strong class=\"italic\">lampe de poche</strong> et <strong class=\"italic\">lampe de poche puissante</strong> lorsqu'elles sont allumées)</p>\r\n                <p>• Les équipements électroniques qui ne proviennent pas du camion</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Près d'équipement électronique :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 65\r\n        },\r\n        'revenant': {\r\n            name: 'Revenant',\r\n            evidences: [\r\n                'freezing-temperatures',\r\n                'ghost-orb',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Il avance beaucoup plus vite lorsqu'il perçoit ses cibles lorsqu'il chasse.\",\r\n            weakness: \"Il est très lent lorsqu'il ne chasse pas une cible.\",\r\n            description: \"Le Revenant est une entitée violente qui attaque sans discrimination. Leur vitesse peut être décevante, vu qu'ils sont lent pendant la dormance ; cependant, aussitôt qu'ils chassent ils peuvent avancer incroyablement vite.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Sa vitesse lors d'une chasse varie fortement des autres entités. Il est très lent si il n'a pas de cible en vue (1 m/s), sinon il est extrêmement rapide (3 m/s).</p>\r\n                <p>Il accélère lorsqu'il voit un joueur et continuera d'accélérer jusqu'à atteindre la dernière position connue du joueur. Ce sera seulement après qu'il ralentira durant 2.7 secondes.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 3} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/3.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'shade': {\r\n            name: 'Ombre',\r\n            evidences: [\r\n                'emf-5',\r\n                'freezing-temperatures',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Sa timidité la rends difficile à localiser et à obtenir une évidence.\",\r\n            weakness: \"Elle a moins de chance d'attaquer si plusieurs personnes sont dans les alentours.\",\r\n            description: \"Une ombre est connue pour être très timide. Plusieurs évidences supposent que l'Ombre arrêtera toute activité paranormal si il y a plusieurs personnes dans les environs.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Au plus la santé mentale est haute, au moins elle est active.</p>\r\n                <p>Elle possède 0% de chance de réussir un événement lorsque la santé mentale est à 100%. La chance de succès d'un événement croît de 2% par pourcentage de santé mentale perdue.</p>\r\n                <p>Ainsi, une ombre aura 100% de chance de pouvoir effectuer un événement lorsque la santé mentale sera de 50% et moins.</p>\r\n                <p>L'ombre préfère se hisser dans les oreilles du joueur, mais peut se manifester en tant qu'ombre (rare).</p>\r\n                <p>Il est incapable de donner une interaction <strong class=\"italic\">EMF 3</strong> lorsqu'il y a un ou plusieurs joueurs dans la même pièce que lui, mais peut le faire dans une pièce adjacente.</p>\r\n                <p>Si elle est invoqué, elle a une chance d'apparaître en tant qu'ombre noir transparente plutôt que dans sa forme complète tant qu'elle est piégée dans le cercle d'invocation.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Elle ne démarre pas de chasse tant que la santé mentale n'est pas en dessous de 35%.</p>\r\n                <p>Elle est incapable de chasser lorsqu'il y a un ou plusieurs joueurs dans la même pièce que lui.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 35\r\n        },\r\n        'spirit': {\r\n            name: 'Esprit',\r\n            evidences: [\r\n                'emf-5',\r\n                'ghost-writing',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Aucune.\",\r\n            weakness: \"L'encent est très efficace, empêchant une chasse durant plus longtemps.\",\r\n            description: \"L'Esprit est une entitée très commune. Ils sont très puissants, mais passif, et n'attaque que quand ils doivent le faire. Ils défendent coûte que coûte le lieu de leur décès, tuant quiconque est surpris à dépasser son temps d'accueil.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Si un encent est utilisé près de lui, il ne pourra pas démarrer une chasse pendant 180 secondes (au lieu de 90 secondes pour les autres entités).</p>\r\n            `,\r\n            hunt: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'thaye': {\r\n            name: 'Thayé',\r\n            evidences: [\r\n                'dots',\r\n                'ghost-orb',\r\n                'ghost-writing'\r\n            ],\r\n            strenght: \"Entrer dans leur champ d'action les rends plus actifs, défensif et agile.\",\r\n            weakness: \"Ils deviennent plus lent et moins actif au fil du temps.\",\r\n            description: \"Le Thayé est connu pour vieillir rapidement au fil du temps, même dans l'au-delà. De ce que nous avons appris, ils semblent se détériorer plus rapidement à la présence des vivants.\",\r\n            ability: `\r\n                <p>Toutes les 1 à 2 minutes, le Thayé va tenter de vieillir. Si un joueur se trouve dans la même pièce que lui, alors il vieilli. Si aucun joueur n'est présent, alors il recommencera le processus 30 secondes plus tard.</p>\r\n                <p>Il peut vieillir jusqu'à 10 fois</p>\r\n                <p>Chaque fois qu'il prends de l'âge :</p>\r\n                <p>• La santé mentale minimum pour qu'il démarre une chasse diminue de 6%.</p>\r\n                <p>• Sa vitesse se réduit de 0.175 m/s lors de la chasse.</p>\r\n                <p>• 15% de réduction sur les chances d'obtenir un événement / une interaction.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Au début de la partie, le Thayé a 200% de faire une interaction ou un événement paranormal.</p>\r\n                <p>Au fil du temps, l'âge donné par la planche Ouija augmentera.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Suite à son abilité, le Thayé n'accélère pas lors d'une chasse.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse quand il est jeune :</strong> ${difficultyMultiplier * 2.75} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.75.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Vitesse quand il est vieux :</strong> ${difficultyMultiplier} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.00.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 75\r\n        },\r\n        'mimic': {\r\n            name: 'Le Mimic',\r\n            evidences: [\r\n                'fingerprints',\r\n                'freezing-temperatures',\r\n                'ghost-orb',\r\n                'spirit-box'\r\n            ],\r\n            strongEvidence: 'ghost-orb',\r\n            strenght: \"Peut copier les abilités et les traîts des autres entitées.\",\r\n            weakness: \"Présente les orbes fantômatique en évidence secondaire.\",\r\n            description: \"Le Mimic est un fantôme insaisissable, mystérieux et imitateur qui reproduit les traits et les comportements d'autres personnes, y compris d'autres types de fantômes.\",\r\n            ability: `\r\n                <p>Il peut imiter tous les types d'entités et ainsi hérité de toutes les capacités et abilités de l'entité qu'il décide de copier.</p>\r\n                <p>Il peut copier des caractéristiques des évidences (exemple: les traces de pas invisible aux <strong class=\"italic\">lampes UV</strong> du Spectre) mais pas les évidences elles-mêmes.</p>\r\n                <p>Il peut imiter le joueur ou le Mimic, mais dans ce cas il agira alors comme un fantôme normal.</p>\r\n                <p>Lorsqu'il choisit d'imiter le Thayé, il choisira un âge aléatoire et au lieu de vieillir comme le Thayé, il imitera une autre entité.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il donne pour évidence les orbes fantômatiques en plus de ses trois évidences de base et ce qu'importe la difficulté.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Varie suivant l'entité imitée.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Varie selon l'entité qu'il incarne.</strong></p>\r\n            `,\r\n            sanity: 100\r\n        },\r\n        'twins': {\r\n            name: 'Les Jumeaux',\r\n            evidences: [\r\n                'emf-5',\r\n                'freezing-temperatures',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Les deux jumeaux peuvent lancer une chasse, mais pas en même temps.\",\r\n            weakness: \"Interagit souvent avec l'environnement en même temps.\",\r\n            description: \"Ces entités ont été signalés comme imitant les actions des autres. Ils alternent leurs attaques pour confondre leurs proies.\",\r\n            ability: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Les Jumeaux ne sont qu'une seule entité composée d'un corps principal et d'un leurre.</p>\r\n                <p>Le leurre ne fait pas marcher les <strong class=\"italic\">détecteurs de mouvements</strong>, ne réduit pas la <strong class=\"italic\">température</strong> et ne réponds pas à la <strong class=\"italic\">Spirit Box</strong>. Le leure et l'entité principale ont 25% de chance de produire un <strong class=\"italic\">EMF 5</strong> au lieu de 2 ou 3.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Si il démarre une chasse, il y a une chance sur deux que ce soit le leurre qui chasse.</p>\r\n                <p>Le leurre est 10% plus rapide qu'un fantôme usuel tandis que le corps principal est 10% plus lent.</p>\r\n                <p>Lorsqu'un <strong class=\"italic\">crucifix</strong> est utilisé pour empêcher une chasse, qu'importe le jumeau qui chasse, le <strong class=\"italic\">crucifix</strong> s'appliquera uniquement au corps principal.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} (± ${difficultyMultiplier * 0.2}) m/s</p>\r\n                <p><strong>Jumeau lent :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Jumeau rapide :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.90.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} (± ${difficultyMultiplier * 0.2}) m/s</p>\r\n                <p><strong>Jumeau lent :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.30.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Jumeau rapide :</strong></p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'wraith': {\r\n            name: 'Spectre',\r\n            evidences: [\r\n                'dots',\r\n                'emf-5',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Ils ne laissent pas de traces de pas visible à la lumière UV après avoir marché dans le sel.\",\r\n            weakness: \"Il devient plus actif si il marche dans du sel.\",\r\n            description: \"Le Spectre est l'une des entitées les plus dangereuse que vous pourrez trouver. C'est aussi la seule entitée connue qui a la capacité de voler et qui est parfois connu pour voyager à travers les murs.\",\r\n            ability: `\r\n                <p>Il a une chance de se téléporter à environs 3 mètres d'un joueur avec 75% chance de générer un <strong class=\"italic\">EMF 2</strong> et 25% chance de générer un <strong class=\"italic\">EMF 5</strong>.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Il est incapable de marcher dans le sel et donc il ne laisse aucune trace de pas visible aux <strong class=\"italic\">lumières UV</strong>.</p>\r\n            `,\r\n            hunt: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        },\r\n        'yokai': {\r\n            name: 'Yokai',\r\n            evidences: [\r\n                'dots',\r\n                'ghost-orb',\r\n                'spirit-box'\r\n            ],\r\n            strenght: \"Parler près d'un Yokai le mettra en colère, ce qui augmentera ses chances d'attaquer.\",\r\n            weakness: \"Il ne peut entendre que des voix proches de lui pendant qu'il chasse.\",\r\n            description: \"Les Yokai sont des entitées communes qui sont attirées par les voix humaines. On les trouve généralement dans les maisons familiales.\",\r\n            ability: \"<p>Rien à signaler.</p>\",\r\n            behaviour: \"<p>Si au moins un joueur parle ou émet du bruit, l'activité du Yokai augmente.</p>\",\r\n            hunt: `\r\n                <p>Si au moins un joueur parle ou émet du bruit, une chasse peut être démarrée en dessous de 80% de santé mentale, sinon il démarre une chasse à 50% comme les autres entités.</p>\r\n                <p>Il ne peut qu'entendre les joueurs ou sentir les appareils électroniques dans une portée de 2.5 mètres (sa ligne de vue n'est pas affectée).</p>\r\n                <p>Lorsque la boîte à musique est utilisée, le Yokai doit être plus proche du joueur tenant la boîte que tous les autres fantômes pour initier une chasse maudite.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 80\r\n        },\r\n        'yurei': {\r\n            name: 'Yurei',\r\n            evidences: [\r\n                'dots',\r\n                'freezing-temperatures',\r\n                'ghost-orb'\r\n            ],\r\n            strenght: \"Il affecte plus fortement la santé mentale.\",\r\n            weakness: \"Allumer de l'encent dans la pièce du Yurei réduira la fréquence de ses errances.\",\r\n            description: \"Un Yurei est une entitée qui est revenue dans le monde physique, généralement dans un but de vengeance ou de haine.\",\r\n            ability: `\r\n                <p>Il peut utiliser son abilité qui réduit de 15% la santé mentale de tous les joueurs situés dans une portée de 7.5 mètres.</p>\r\n                <p>Il ne peut utiliser son abilité que lorsque la pièce dans laquelle il se situe possède au moins une porte.</p>\r\n                <p>Lorsqu'il emploie son abilitée, une porte choisie aléatoirement dans la pièce du Yurei se fermera, produisant un <strong class=\"italic\">EMF 2</strong>.</p>\r\n                <p>Les casiers et plaquards ne sont pas affectés par l'abilité du Yurei.</p>\r\n                <p>Lorsque la porte avant (la porte de sortie) se ferme entièrement sans qu'il n'y aie eu un événement fantômatique ou une chasse, alors c'est un Yurei.</p>\r\n            `,\r\n            behaviour: `\r\n                <p>Si on emploie de <strong class=\"italic\">l'encent</strong> sur lui, en plus des effets de base, il ne quittera pas sa pièce durant 90s.</p>\r\n                <p>Il offre plus souvent des événements de type \"ballon d'air\".</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/sound-evidences/air-breath.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            hunt: `\r\n                <p>Rien à signaler.</p>\r\n            `,\r\n            speed: `\r\n                <p><strong>Vitesse de base :</strong> ${difficultyMultiplier * 1.7} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/1.70.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n                <p><strong>Victime en ligne de vue :</strong> ${difficultyMultiplier * 2.5} m/s</p>\r\n                <audio controls class=\"sound-display\">\r\n                    <source src=\"./assets/audio/footsteps/${ghostSpeed}/2.50.mp3\" type=\"audio/mpeg\" />\r\n                </audio>\r\n            `,\r\n            sanity: 50\r\n        }\r\n    };\r\n};\r\nexports.GHOST_DATABASE = GHOST_DATABASE;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/db/ghosts.ts?");

/***/ }),

/***/ "./src/db/interactiveDatabase.ts":
/*!***************************************!*\
  !*** ./src/db/interactiveDatabase.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.interactiveDatabase = void 0;\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst portable_1 = __webpack_require__(/*! @lazy-toolbox/portable */ \"./node_modules/@lazy-toolbox/portable/dist/index.js\");\r\nconst database_1 = __webpack_require__(/*! ./database */ \"./src/db/database.ts\");\r\nconst initializeGhosts_1 = __webpack_require__(/*! ../initializeGhosts */ \"./src/initializeGhosts.ts\");\r\nexports.interactiveDatabase = {\r\n    \"behaviourVisibility\": (ghostName) => {\r\n        let visibility = true;\r\n        if (visibility) {\r\n            const bansheeTestC = document.querySelector('#farEventGhost');\r\n            let currentState = client_1.LazyTristate.stateToString(bansheeTestC.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"wraith\" || ghostName === \"banshee\" || ghostName === \"mimic\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const wraithTest = document.querySelector('#saltFootsteps');\r\n            let currentState = client_1.LazyTristate.stateToString(wraithTest.value);\r\n            if (currentState === \"false\") {\r\n                visibility = visibility && (ghostName === \"wraith\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"wraith\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mareTestA = document.querySelector('#turnOnLight');\r\n            let currentState = client_1.LazyTristate.stateToString(mareTestA.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"mare\";\r\n            }\r\n            if (visibility) {\r\n                const mareTestB = document.querySelector('#notMare');\r\n                currentState = client_1.LazyTristate.stateToString(mareTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && ghostName !== \"mare\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const mareTestC = document.querySelector('#mareLight');\r\n                currentState = client_1.LazyTristate.stateToString(mareTestC.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"mare\" || ghostName === \"mimic\");\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const hantuTest = document.querySelector('#turnOnBreaker');\r\n            let currentState = client_1.LazyTristate.stateToString(hantuTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"hantu\";\r\n            }\r\n            if (visibility) {\r\n                const hantuTestB = document.querySelector('#hantuTest');\r\n                currentState = client_1.LazyTristate.stateToString(hantuTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"hantu\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"hantu\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const hantuTestB = document.querySelector('#hantuSpeedTest');\r\n                currentState = client_1.LazyTristate.stateToString(hantuTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"hantu\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"hantu\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const longSeeTest = document.querySelector('#longSeeTest');\r\n            let currentState = client_1.LazyTristate.stateToString(longSeeTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"oni\" || ghostName === \"mimic\" || ghostName === \"deogen\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"oni\" && ghostName !== \"deogen\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const jinnTest = document.querySelector('#turnOffBreaker');\r\n            let currentState = client_1.LazyTristate.stateToString(jinnTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"jinn\";\r\n            }\r\n            if (visibility) {\r\n                const jinnTestB = document.querySelector('#jinnBreaker');\r\n                let currentState = client_1.LazyTristate.stateToString(jinnTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"jinn\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"jinn\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const phantomTest = document.querySelector('#phantomTest');\r\n            let currentState = client_1.LazyTristate.stateToString(phantomTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"phantom\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"phantom\";\r\n            }\r\n            if (visibility) {\r\n                const phantomTestB = document.querySelector('#phantomPic');\r\n                let currentState = client_1.LazyTristate.stateToString(phantomTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"phantom\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"phantom\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const phantomTestB = document.querySelector('#phantomPicHunt');\r\n                let currentState = client_1.LazyTristate.stateToString(phantomTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"phantom\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"phantom\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const oniTestB = document.querySelector('#notOni');\r\n            let currentState = client_1.LazyTristate.stateToString(oniTestB.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"oni\";\r\n            }\r\n            if (visibility) {\r\n                const oniTestC = document.querySelector('#oniSanityTest');\r\n                let currentState = client_1.LazyTristate.stateToString(oniTestC.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"oni\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"oni\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const goryoTest = document.querySelector('#goryoTest');\r\n            let currentState = client_1.LazyTristate.stateToString(goryoTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"goryo\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"goryo\";\r\n            }\r\n            if (visibility) {\r\n                const goryoTestB = document.querySelector('#goryoRoaming');\r\n                let currentState = client_1.LazyTristate.stateToString(goryoTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"goryo\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"goryo\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const goryoTestB = document.querySelector('#goryoFavourite');\r\n                let currentState = client_1.LazyTristate.stateToString(goryoTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"goryo\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"goryo\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let countTests = 0;\r\n            const bansheeTest = document.querySelector('#bansheeScream');\r\n            let currentState = client_1.LazyTristate.stateToString(bansheeTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                countTests++;\r\n            }\r\n            if (visibility) {\r\n                const bansheeTestB = document.querySelector('#bansheeHuntTest');\r\n                currentState = client_1.LazyTristate.stateToString(bansheeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    countTests++;\r\n                    visibility = visibility && (ghostName !== \"banshee\");\r\n                }\r\n                if (visibility) {\r\n                    const bansheeTestC = document.querySelector('#farEventGhost');\r\n                    currentState = client_1.LazyTristate.stateToString(bansheeTestC.value);\r\n                    if (currentState === \"true\") {\r\n                        visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\" || ghostName === \"wraith\");\r\n                    }\r\n                    else if (currentState === \"false\") {\r\n                        countTests++;\r\n                    }\r\n                }\r\n            }\r\n            if (countTests == 3) {\r\n                visibility = visibility && (ghostName !== \"banshee\");\r\n            }\r\n            if (visibility) {\r\n                const bansheeTestC = document.querySelector('#bansheeSanityTest');\r\n                currentState = client_1.LazyTristate.stateToString(bansheeTestC.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"banshee\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"banshee\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const deogenTest = document.querySelector('#deogenBreath');\r\n            let currentState = client_1.LazyTristate.stateToString(deogenTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"deogen\" || ghostName === \"mimic\");\r\n            }\r\n            if (visibility) {\r\n                const deogenTestB = document.querySelector('#deogenHiding');\r\n                let currentState = client_1.LazyTristate.stateToString(deogenTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"deogen\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"deogen\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const yureiTest = document.querySelector('#yureiDoor');\r\n            let currentState = client_1.LazyTristate.stateToString(yureiTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"yurei\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"yurei\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let testCount = 0;\r\n            const obakeTestA = document.querySelector('#obakeFringer');\r\n            let currentState = client_1.LazyTristate.stateToString(obakeTestA.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"obake\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                testCount++;\r\n            }\r\n            if (visibility) {\r\n                const obakeTestB = document.querySelector('#obakeShapeshift');\r\n                currentState = client_1.LazyTristate.stateToString(obakeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"obake\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    testCount++;\r\n                }\r\n            }\r\n            if (testCount == 2) {\r\n                visibility = visibility && (ghostName !== \"obake\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const demonTest = document.querySelector('#demonTest');\r\n            let currentState = client_1.LazyTristate.stateToString(demonTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"demon\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"demon\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const spiritTest = document.querySelector('#spiritTest');\r\n            let currentState = client_1.LazyTristate.stateToString(spiritTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && ghostName !== \"spirit\";\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && (ghostName === \"spirit\" || ghostName === \"mimic\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let testCount = 0;\r\n            const shadeTestA = document.querySelector('#shadeTestA');\r\n            let currentState = client_1.LazyTristate.stateToString(shadeTestA.value);\r\n            if (currentState === \"true\") {\r\n                testCount++;\r\n            }\r\n            const shadeTestB = document.querySelector('#shadeTestB');\r\n            currentState = client_1.LazyTristate.stateToString(shadeTestB.value);\r\n            if (currentState === \"true\") {\r\n                testCount++;\r\n            }\r\n            if (testCount == 2) {\r\n                visibility = visibility && (ghostName === \"shade\" || ghostName === \"mimic\");\r\n            }\r\n            if (visibility) {\r\n                const shadeTestB = document.querySelector('#shadeTestC');\r\n                currentState = client_1.LazyTristate.stateToString(shadeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"shade\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"shade\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const shadeTestB = document.querySelector('#shadeEMFTest');\r\n                currentState = client_1.LazyTristate.stateToString(shadeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"shade\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"shade\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mylingTest = document.querySelector('#mylingTest');\r\n            let currentState = client_1.LazyTristate.stateToString(mylingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"myling\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"myling\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mylingTest = document.querySelector('#raijuGhostEvent');\r\n            let currentState = client_1.LazyTristate.stateToString(mylingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"raiju\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"raiju\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const mylingTest = document.querySelector('#onryoTest');\r\n            let currentState = client_1.LazyTristate.stateToString(mylingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"onryo\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"onryo\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const moroiTest = document.querySelector('#moroiTest');\r\n            let currentState = client_1.LazyTristate.stateToString(moroiTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"moroi\";\r\n            }\r\n            if (visibility) {\r\n                const moroiTestB = document.querySelector('#moroiHuntTest');\r\n                let currentState = client_1.LazyTristate.stateToString(moroiTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"moroi\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const moroiTestB = document.querySelector('#moroiSmudged');\r\n                let currentState = client_1.LazyTristate.stateToString(moroiTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"moroi\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#revTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"revenant\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"revenant\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#twinsSpeedTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"twins\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"twins\";\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#yureiActivityTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"yurei\" || ghostName === \"mimic\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const revTest = document.querySelector('#yokaiTest');\r\n            let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"yokai\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"yokai\";\r\n            }\r\n            if (visibility) {\r\n                const revTest = document.querySelector('#yokaiActivityTest');\r\n                let currentState = client_1.LazyTristate.stateToString(revTest.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"yokai\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"yokai\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const sprintTest = document.querySelector('#sprintTest');\r\n            let currentState = client_1.LazyTristate.stateToString(sprintTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"revenant\" || ghostName === \"mimic\" || ghostName === \"jinn\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"revenant\" || ghostName === \"jinn\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const thayeTest = document.querySelector('#thayeTest');\r\n            let currentState = client_1.LazyTristate.stateToString(thayeTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"thaye\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && ghostName !== \"thaye\";\r\n            }\r\n            if (visibility) {\r\n                const thayeTestB = document.querySelector('#thayeAge');\r\n                let currentState = client_1.LazyTristate.stateToString(thayeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"thaye\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"thaye\";\r\n                }\r\n            }\r\n            if (visibility) {\r\n                const thayeTestB = document.querySelector('#thayeAgeTesting');\r\n                let currentState = client_1.LazyTristate.stateToString(thayeTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"thaye\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    visibility = visibility && ghostName !== \"thaye\";\r\n                }\r\n            }\r\n        }\r\n        if (visibility) {\r\n            let nbrTest = 0;\r\n            const polterTestA = document.querySelector('#polterTestA');\r\n            let currentState = client_1.LazyTristate.stateToString(polterTestA.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"poltergeist\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                nbrTest++;\r\n            }\r\n            if (visibility) {\r\n                const polterTestB = document.querySelector('#polterTestB');\r\n                currentState = client_1.LazyTristate.stateToString(polterTestB.value);\r\n                if (currentState === \"true\") {\r\n                    visibility = visibility && (ghostName === \"poltergeist\" || ghostName === \"mimic\");\r\n                }\r\n                else if (currentState === \"false\") {\r\n                    nbrTest++;\r\n                }\r\n                if (visibility) {\r\n                    const polterTestC = document.querySelector('#polterTestC');\r\n                    currentState = client_1.LazyTristate.stateToString(polterTestC.value);\r\n                    if (currentState === \"true\") {\r\n                        visibility = visibility && (ghostName === \"poltergeist\" || ghostName === \"mimic\");\r\n                    }\r\n                    else if (currentState === \"false\") {\r\n                        nbrTest++;\r\n                    }\r\n                }\r\n            }\r\n            if (nbrTest === 3) {\r\n                visibility = visibility && (ghostName !== \"poltergeist\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const huntSpeedHidingTest = document.querySelector('#huntSpeedHidingTest');\r\n            let currentState = client_1.LazyTristate.stateToString(huntSpeedHidingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\" || ghostName === \"raiju\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"moroi\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\" || ghostName === \"raiju\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const huntSpeedHidingTest = document.querySelector('#huntSpeedSkipRaijuTest');\r\n            let currentState = client_1.LazyTristate.stateToString(huntSpeedHidingTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"mimic\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"moroi\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"deogen\" || ghostName === \"twins\");\r\n            }\r\n        }\r\n        if (visibility) {\r\n            const variableHuntSpeedTest = document.querySelector('#variableHuntSpeedTest');\r\n            let currentState = client_1.LazyTristate.stateToString(variableHuntSpeedTest.value);\r\n            if (currentState === \"true\") {\r\n                visibility = visibility && (ghostName === \"moroi\" || ghostName === \"thaye\" || ghostName === \"hantu\" || ghostName === \"twins\" || ghostName === \"mimic\");\r\n            }\r\n            else if (currentState === \"false\") {\r\n                visibility = visibility && !(ghostName === \"moroi\" || ghostName === \"hantu\" || ghostName === \"thaye\" || ghostName === \"twins\");\r\n            }\r\n        }\r\n        return visibility;\r\n    },\r\n    \"triggerGhostSpeedRender\": (event) => {\r\n        (0, initializeGhosts_1.initializeGhosts)(event.target.value);\r\n        exports.interactiveDatabase.triggerGhostRendering();\r\n    },\r\n    \"triggerEvidence\": (event) => {\r\n        exports.interactiveDatabase.triggerGhostRendering();\r\n    },\r\n    \"resetEvidences\": () => {\r\n        const evidences = database_1.Database.getEvidences();\r\n        for (const label in evidences) {\r\n            const evid = document.querySelector(`#${label}`);\r\n            evid.value = client_1.LazyTristate.NEUTRAL;\r\n            evid.innerText = client_1.LazyTristate.NEUTRAL;\r\n        }\r\n        const subEvidences = [...document.querySelectorAll('.subevidenceInput')];\r\n        for (const subEvidence of subEvidences) {\r\n            subEvidence.value = client_1.LazyTristate.NEUTRAL;\r\n            subEvidence.innerText = client_1.LazyTristate.NEUTRAL;\r\n        }\r\n        const allGhosts = [...document.querySelectorAll('.ghostsContainer > .ghostContainer')];\r\n        for (const ghost of allGhosts) {\r\n            ghost.style.display = \"block\";\r\n        }\r\n        const resultNumber = document.querySelector('.resultNumber');\r\n        resultNumber.innerText = `${allGhosts.length} résultat${allGhosts.length > 1 ? 's' : ''}`;\r\n    },\r\n    \"triggerGhostRendering\": () => {\r\n        const obtainedEvidences = database_1.Database.getEvidencesByValue('true');\r\n        const hiddenEvidences = database_1.Database.getEvidencesByValue('false');\r\n        const allGhosts = [...document.querySelectorAll('.ghostsContainer > .ghostContainer')];\r\n        const evidenceCount = Number(document.getElementById('evidencesCount').value);\r\n        switch (evidenceCount) {\r\n            case 3:\r\n                exports.interactiveDatabase.allEvidences(obtainedEvidences, hiddenEvidences, allGhosts);\r\n                break;\r\n            default:\r\n                exports.interactiveDatabase.fiewEvidences(obtainedEvidences, hiddenEvidences, allGhosts, evidenceCount);\r\n                break;\r\n        }\r\n    },\r\n    \"allEvidences\": (gotEvidences, notEvidences, ghosts) => {\r\n        var _a;\r\n        let ghostResults = ghosts.length;\r\n        for (const ghostHTMLElement of ghosts) {\r\n            ghostHTMLElement.style.display = \"block\";\r\n            const ghostName = (_a = ghostHTMLElement.getAttribute('id')) !== null && _a !== void 0 ? _a : \"\";\r\n            const currentGhost = database_1.Database.ghostDB[ghostName];\r\n            const hasEvidences = exports.interactiveDatabase.hasEvidences(currentGhost.evidences, gotEvidences);\r\n            if (!hasEvidences) {\r\n                ghostHTMLElement.style.display = \"none\";\r\n                ghostResults--;\r\n                continue;\r\n            }\r\n            const rejectedEvidences = exports.interactiveDatabase.hasHiddenEvidences(currentGhost.evidences, notEvidences);\r\n            if (rejectedEvidences) {\r\n                ghostHTMLElement.style.display = \"none\";\r\n                ghostResults--;\r\n                continue;\r\n            }\r\n            if (!exports.interactiveDatabase.behaviourVisibility(ghostName)) {\r\n                ghostHTMLElement.style.display = \"none\";\r\n                ghostResults--;\r\n                continue;\r\n            }\r\n        }\r\n        const resultNumber = document.querySelector('.resultNumber');\r\n        resultNumber.innerText = `${ghostResults} résultat${ghostResults > 1 ? 's' : ''}`;\r\n    },\r\n    \"fiewEvidences\": (obtainedEvidences, hiddenEvidences, ghosts, totalEvidences = 2) => {\r\n        var _a;\r\n        let ghostResults = ghosts.length;\r\n        for (const ghostHTMLElement of ghosts) {\r\n            ghostHTMLElement.style.display = \"block\";\r\n            const ghostName = (_a = ghostHTMLElement.getAttribute('id')) !== null && _a !== void 0 ? _a : \"\";\r\n            const currentGhost = database_1.Database.ghostDB[ghostName];\r\n            let actualGhost = currentGhost;\r\n            let visibility = true;\r\n            if (totalEvidences > 0) {\r\n                if (actualGhost.strongEvidence) {\r\n                    if (!obtainedEvidences.includes(actualGhost.strongEvidence) && hiddenEvidences.includes(actualGhost.strongEvidence)) {\r\n                        visibility = false;\r\n                    }\r\n                }\r\n                if (visibility) {\r\n                    visibility = exports.interactiveDatabase.behaviourVisibility(ghostName);\r\n                }\r\n                if (visibility) {\r\n                    for (let evidence of obtainedEvidences) {\r\n                        visibility = visibility && actualGhost.evidences.includes(evidence);\r\n                    }\r\n                }\r\n                if (visibility) {\r\n                    if (obtainedEvidences.length > totalEvidences) {\r\n                        if (ghostName !== 'mimic') {\r\n                            visibility = false;\r\n                        }\r\n                        else {\r\n                            let isMimic = true;\r\n                            for (const evd of obtainedEvidences) {\r\n                                if (!actualGhost.evidences.includes(evd)) {\r\n                                    isMimic = false;\r\n                                }\r\n                            }\r\n                            if (!isMimic) {\r\n                                visibility = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (totalEvidences == 2) {\r\n                            if (visibility && hiddenEvidences.length > 1 && ghostName !== 'mimic') {\r\n                                let combineHidden = portable_1.LazyMath.combinationArrayNRNO(hiddenEvidences, 2);\r\n                                for (let childCombine of combineHidden) {\r\n                                    let nbr = 0;\r\n                                    for (let child of childCombine) {\r\n                                        if (actualGhost.evidences.includes(child)) {\r\n                                            nbr++;\r\n                                        }\r\n                                    }\r\n                                    if (nbr == 2) {\r\n                                        visibility = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (totalEvidences == 1) {\r\n                            if (visibility && hiddenEvidences.length > 2 && ghostName !== 'mimic') {\r\n                                let combineHidden = portable_1.LazyMath.combinationArrayNRNO(hiddenEvidences, 3);\r\n                                for (let childCombine of combineHidden) {\r\n                                    let nbr = 0;\r\n                                    for (let child of childCombine) {\r\n                                        if (actualGhost.evidences.includes(child)) {\r\n                                            nbr++;\r\n                                        }\r\n                                    }\r\n                                    if (nbr == 3) {\r\n                                        visibility = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!visibility) {\r\n                    ghostHTMLElement.style.display = \"none\";\r\n                    ghostResults--;\r\n                }\r\n            }\r\n            else {\r\n                if (obtainedEvidences.includes('ghost-orb')) {\r\n                    if (ghostName !== 'mimic') {\r\n                        ghostHTMLElement.style.display = \"none\";\r\n                        ghostResults--;\r\n                    }\r\n                }\r\n                else {\r\n                    if (ghostName === 'mimic') {\r\n                        ghostHTMLElement.style.display = \"none\";\r\n                        ghostResults--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const resultNumber = document.querySelector('.resultNumber');\r\n        resultNumber.innerText = `${ghostResults} résultat${ghostResults > 1 ? 's' : ''}`;\r\n    },\r\n    \"hasEvidences\": (ghostEvidences, currentEvidences) => {\r\n        for (const evidence of currentEvidences) {\r\n            if (!ghostEvidences.includes(evidence)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    \"hasHiddenEvidences\": (ghostEvidences, currentEvidences) => {\r\n        for (const evidence of currentEvidences) {\r\n            if (ghostEvidences.includes(evidence)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/db/interactiveDatabase.ts?");

/***/ }),

/***/ "./src/initializeGhosts.ts":
/*!*********************************!*\
  !*** ./src/initializeGhosts.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.initializeGhosts = void 0;\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst ghostRenderer_1 = __webpack_require__(/*! ./renderer/ghostRenderer */ \"./src/renderer/ghostRenderer.ts\");\r\nconst initializeGhosts = (rndr = '100') => {\r\n    const allRenderedGhosts = ghostRenderer_1.GhostRenderer.render(rndr);\r\n    allRenderedGhosts.sort(function (a, b) {\r\n        var _a, _b;\r\n        const idA = (_a = a.getAttribute('name')) !== null && _a !== void 0 ? _a : '';\r\n        const idB = (_b = b.getAttribute('name')) !== null && _b !== void 0 ? _b : '';\r\n        return idA.localeCompare(idB);\r\n    });\r\n    const ghostContainer = document.querySelector('.ghostsContainer');\r\n    ghostContainer.innerHTML = \"\";\r\n    for (let renderedGhost of allRenderedGhosts) {\r\n        ghostContainer.appendChild(renderedGhost);\r\n    }\r\n    client_1.LazyAnimate.loadDefault();\r\n};\r\nexports.initializeGhosts = initializeGhosts;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/initializeGhosts.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __webpack_unused_export__;\n\r\n__webpack_unused_export__ = ({ value: true });\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst initializeGhosts_1 = __webpack_require__(/*! ./initializeGhosts */ \"./src/initializeGhosts.ts\");\r\nconst evidenceRenderer_1 = __webpack_require__(/*! ./renderer/evidenceRenderer */ \"./src/renderer/evidenceRenderer.ts\");\r\nconst initializeMenu = () => {\r\n    client_1.LazyInteractivity.loadDefault();\r\n    evidenceRenderer_1.EvidenceRenderer.optionBehaviour();\r\n    evidenceRenderer_1.EvidenceRenderer.optionDropdown();\r\n};\r\ninitializeMenu();\r\n(0, initializeGhosts_1.initializeGhosts)();\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/main.ts?");

/***/ }),

/***/ "./src/renderer/evidenceRenderer.ts":
/*!******************************************!*\
  !*** ./src/renderer/evidenceRenderer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EvidenceRenderer = void 0;\r\nconst interactiveDatabase_1 = __webpack_require__(/*! ../db/interactiveDatabase */ \"./src/db/interactiveDatabase.ts\");\r\nclass EvidenceRenderer {\r\n    static optionBehaviour() {\r\n        const evidences = document.getElementsByClassName('evidenceInput');\r\n        for (const evidence of evidences) {\r\n            evidence.addEventListener(\"change\", interactiveDatabase_1.interactiveDatabase.triggerEvidence);\r\n        }\r\n        const evidenceGivenCount = document.getElementById('evidencesCount');\r\n        evidenceGivenCount === null || evidenceGivenCount === void 0 ? void 0 : evidenceGivenCount.addEventListener(\"change\", (e) => {\r\n            const target = e.target;\r\n            const evidenceCount = Number(target.value);\r\n            if (evidenceCount == 0) {\r\n                const hideAll = document.getElementsByClassName('evidence');\r\n                for (const hide of hideAll) {\r\n                    const currentElement = hide;\r\n                    if (!currentElement.classList.contains(\"ghost-orb\")) {\r\n                        currentElement.style.display = \"none\";\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const showAll = document.getElementsByClassName('evidence');\r\n                for (const show of showAll) {\r\n                    const currentElement = show;\r\n                    currentElement.style.display = \"table-row\";\r\n                }\r\n            }\r\n            interactiveDatabase_1.interactiveDatabase.resetEvidences();\r\n        });\r\n        const ghostSpeed = document.getElementById('ghostSpeed');\r\n        ghostSpeed.addEventListener(\"change\", interactiveDatabase_1.interactiveDatabase.triggerGhostSpeedRender);\r\n        const subEvidences = document.getElementsByClassName('subevidenceInput');\r\n        for (const subEvidence of subEvidences) {\r\n            subEvidence.addEventListener(\"change\", interactiveDatabase_1.interactiveDatabase.triggerEvidence);\r\n        }\r\n        const btnReset = document.querySelector('.resetMenuBtn');\r\n        btnReset.addEventListener('click', interactiveDatabase_1.interactiveDatabase.resetEvidences);\r\n    }\r\n    static optionDropdown() {\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-interactions', '.interactions');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-interactionsEvidences', '.interactionsEvidences');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-ghostEvents', '.ghostEvents');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-curses', '.curses');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-curseObject', '.curseObject');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntWait', '.huntWait');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntVisual', '.huntVisual');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntInteract', '.huntInteract');\r\n        EvidenceRenderer.dropdown('.dropdownSubevidences-huntBehaviour', '.huntBehaviour');\r\n    }\r\n    static dropdown(query, targetQuery) {\r\n        const interactionDropdown = document.querySelector(query);\r\n        interactionDropdown.addEventListener(\"click\", (e) => {\r\n            if (interactionDropdown.innerText === \"+\") {\r\n                const allInteractions = [...document.querySelectorAll(targetQuery)];\r\n                for (const interaction of allInteractions) {\r\n                    interaction.style.display = \"table-row\";\r\n                }\r\n            }\r\n            else {\r\n                const allInteractions = [...document.querySelectorAll(targetQuery)];\r\n                for (const interaction of allInteractions) {\r\n                    interaction.style.display = \"none\";\r\n                }\r\n            }\r\n            interactionDropdown.innerText = interactionDropdown.innerText === \"+\" ? \"-\" : \"+\";\r\n        });\r\n    }\r\n}\r\nexports.EvidenceRenderer = EvidenceRenderer;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/renderer/evidenceRenderer.ts?");

/***/ }),

/***/ "./src/renderer/ghostRenderer.ts":
/*!***************************************!*\
  !*** ./src/renderer/ghostRenderer.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GhostRenderer = void 0;\r\nconst ghosts_1 = __webpack_require__(/*! ../db/ghosts */ \"./src/db/ghosts.ts\");\r\nconst client_1 = __webpack_require__(/*! @lazy-toolbox/client */ \"./node_modules/@lazy-toolbox/client/dist/index.js\");\r\nconst database_1 = __webpack_require__(/*! ../db/database */ \"./src/db/database.ts\");\r\nclass GhostRenderer {\r\n    static render(speed = '100') {\r\n        const ghosts = (0, ghosts_1.GHOST_DATABASE)(speed, speed !== '100' ? 1.5 : 1);\r\n        const ghostsContainer = [];\r\n        for (const ghostID in ghosts) {\r\n            const currentGhost = ghosts[ghostID];\r\n            let evidencesIcons = '';\r\n            for (const evidence of currentGhost.evidences) {\r\n                evidencesIcons += `<img src=\"./assets/icons/${database_1.Database.evidenceIcons[evidence]}\" alt=\"${evidence}\" />`;\r\n            }\r\n            ghostsContainer.push(client_1.LazyDoc.newTag('details', {\r\n                attributes: {\r\n                    'animated': '',\r\n                    'shr_duration': '200',\r\n                    'shr_ease': 'linear',\r\n                    'exp_duration': '200',\r\n                    'exp_ease': 'linear',\r\n                    'name': currentGhost.name\r\n                },\r\n                id: ghostID,\r\n                class: ['ghostContainer'],\r\n                innerHTML: `\r\n                <summary class=\"ghostSummary\">\r\n                    <div>\r\n                        <h2>${currentGhost.name}</h2>\r\n                        <div>${evidencesIcons}</div>\r\n                        <p>${currentGhost.sanity}%</p>\r\n                    </div>\r\n                </summary>\r\n                <content class=\"ghostContent\">\r\n                    <p class=\"ghostDesc\"><span desc fullDesc>“ ${currentGhost.description} „</span></p>\r\n                    <p><span desc strenght>Force :</span> <span>${currentGhost.strenght}</span></p>\r\n                    <p><span desc weakness>Faiblesse :</span> <span>${currentGhost.weakness}</span></p>\r\n                    <section>\r\n                        <hr><br>\r\n                        <h3>Abilité</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.ability}\r\n                        <h3>Comportement</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.behaviour}\r\n                        <h3>Chasse</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.hunt}\r\n                        <h3>Vitesse</h3>\r\n                        <hr><br>\r\n                        ${currentGhost.speed}\r\n                    </section>\r\n                </content>\r\n                `\r\n            }));\r\n        }\r\n        return ghostsContainer;\r\n    }\r\n}\r\nexports.GhostRenderer = GhostRenderer;\r\n\n\n//# sourceURL=webpack://journal-phasmophobia/./src/renderer/ghostRenderer.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;